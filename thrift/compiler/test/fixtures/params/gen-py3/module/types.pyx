#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.bytes cimport PyBytes_AsStringAndSize
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from libcpp.utility cimport move as cmove
from cpython cimport bool as pbool
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types cimport (
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    constant_shared_ptr,
    default_inst,
    NOTSET as __NOTSET,
    EnumData as __EnumData,
    EnumFlagsData as __EnumFlagsData,
    UnionTypeEnumData as __UnionTypeEnumData,
    createEnumDataForUnionType as __createEnumDataForUnionType,
)
cimport thrift.py3.std_libcpp as std_libcpp
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
import weakref as __weakref
import builtins as _builtins

cimport module.types_reflection as _types_reflection



@__cython.auto_pickle(False)
cdef class List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cint32_t]] c_items):
        __fbthrift_inst = <List__i32>List__i32.__new__(List__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__i32 self):
        cdef shared_ptr[vector[cint32_t]] cpp_obj = make_shared[vector[cint32_t]](
            deref(self._cpp_obj)
        )
        return List__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint32_t]] c_inst = make_shared[vector[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cint32_t]] c_inst
        cdef cint32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cint32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[cint32_t].iterator, cint32_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef vector[cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef vector[cint32_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[cint32_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cint32_t].iterator loc = std_libcpp.find[vector[cint32_t].iterator, cint32_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <cint64_t> std_libcpp.count[vector[cint32_t].iterator, cint32_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__i32()


Sequence.register(List__i32)

@__cython.auto_pickle(False)
cdef class Map__i32_List__i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__i32_List__i32):
            self._cpp_obj = (<Map__i32_List__i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__i32_List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[cint32_t,vector[cint32_t]]] c_items):
        __fbthrift_inst = <Map__i32_List__i32>Map__i32_List__i32.__new__(Map__i32_List__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__i32_List__i32 self):
        cdef shared_ptr[cmap[cint32_t,vector[cint32_t]]] cpp_obj = make_shared[cmap[cint32_t,vector[cint32_t]]](
            deref(self._cpp_obj)
        )
        return Map__i32_List__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[cint32_t,vector[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cint32_t,vector[cint32_t]]] c_inst = make_shared[cmap[cint32_t,vector[cint32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <cint32_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)

                deref(c_inst)[key] = deref((<List__i32>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[cint32_t,vector[cint32_t]].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[vector[cint32_t]] citem = reference_shared_ptr_Map__i32_List__i32(self._cpp_obj, deref(iter).second)
        return List__i32.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cmap[cint32_t,vector[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef cint32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef shared_ptr[vector[cint32_t]] citem
        cdef cmap[cint32_t,vector[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__i32_List__i32(self._cpp_obj, deref(loc).second)
            yield List__i32.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef cint32_t ckey
        cdef shared_ptr[vector[cint32_t]] citem
        cdef cmap[cint32_t,vector[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__i32_List__i32(self._cpp_obj, deref(loc).second)
            yield (ckey, List__i32.create(citem))
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__i32_List__i32()


Mapping.register(Map__i32_List__i32)

@__cython.auto_pickle(False)
cdef class Set__i32(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cint32_t]] c_items):
        __fbthrift_inst = <Set__i32>Set__i32.__new__(Set__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Set__i32 self):
        cdef shared_ptr[cset[cint32_t]] cpp_obj = make_shared[cset[cint32_t]](
            deref(self._cpp_obj)
        )
        return Set__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cint32_t]] c_inst = make_shared[cset[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cset[cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[cint32_t]] cself, cother
        cdef cset[cint32_t].iterator loc
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = (<Set__i32> self)._cpp_obj
            cother = (<Set__i32> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(__fbthrift_move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(__fbthrift_move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(__fbthrift_move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(__fbthrift_move_shared(shretval))


    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__i32()


Set.register(Set__i32)

@__cython.auto_pickle(False)
cdef class Map__i32_Set__i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__i32_Set__i32):
            self._cpp_obj = (<Map__i32_Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__i32_Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[cint32_t,cset[cint32_t]]] c_items):
        __fbthrift_inst = <Map__i32_Set__i32>Map__i32_Set__i32.__new__(Map__i32_Set__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__i32_Set__i32 self):
        cdef shared_ptr[cmap[cint32_t,cset[cint32_t]]] cpp_obj = make_shared[cmap[cint32_t,cset[cint32_t]]](
            deref(self._cpp_obj)
        )
        return Map__i32_Set__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[cint32_t,cset[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cint32_t,cset[cint32_t]]] c_inst = make_shared[cmap[cint32_t,cset[cint32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <cint32_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.AbstractSet[int]")
                if not isinstance(item, Set__i32):
                    item = Set__i32(item)

                deref(c_inst)[key] = deref((<Set__i32>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[cint32_t,cset[cint32_t]].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cset[cint32_t]] citem = reference_shared_ptr_Map__i32_Set__i32(self._cpp_obj, deref(iter).second)
        return Set__i32.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cmap[cint32_t,cset[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef cint32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef shared_ptr[cset[cint32_t]] citem
        cdef cmap[cint32_t,cset[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__i32_Set__i32(self._cpp_obj, deref(loc).second)
            yield Set__i32.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef cint32_t ckey
        cdef shared_ptr[cset[cint32_t]] citem
        cdef cmap[cint32_t,cset[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__i32_Set__i32(self._cpp_obj, deref(loc).second)
            yield (ckey, Set__i32.create(citem))
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__i32_Set__i32()


Mapping.register(Map__i32_Set__i32)

@__cython.auto_pickle(False)
cdef class Map__i32_i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__i32_i32):
            self._cpp_obj = (<Map__i32_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__i32_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[cint32_t,cint32_t]] c_items):
        __fbthrift_inst = <Map__i32_i32>Map__i32_i32.__new__(Map__i32_i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__i32_i32 self):
        cdef shared_ptr[cmap[cint32_t,cint32_t]] cpp_obj = make_shared[cmap[cint32_t,cint32_t]](
            deref(self._cpp_obj)
        )
        return Map__i32_i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[cint32_t,cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cint32_t,cint32_t]] c_inst = make_shared[cmap[cint32_t,cint32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <cint32_t> key
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item

                deref(c_inst)[key] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[cint32_t,cint32_t].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef cint32_t citem = deref(iter).second
        return citem

    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cmap[cint32_t,cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef cint32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cmap[cint32_t,cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            return
        cdef cint32_t ckey
        cdef cint32_t citem
        cdef cmap[cint32_t,cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey, citem)
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__i32_i32()


Mapping.register(Map__i32_i32)

@__cython.auto_pickle(False)
cdef class List__Map__i32_i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Map__i32_i32):
            self._cpp_obj = (<List__Map__i32_i32> items)._cpp_obj
        else:
            self._cpp_obj = List__Map__i32_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cmap[cint32_t,cint32_t]]] c_items):
        __fbthrift_inst = <List__Map__i32_i32>List__Map__i32_i32.__new__(List__Map__i32_i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__Map__i32_i32 self):
        cdef shared_ptr[vector[cmap[cint32_t,cint32_t]]] cpp_obj = make_shared[vector[cmap[cint32_t,cint32_t]]](
            deref(self._cpp_obj)
        )
        return List__Map__i32_i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cmap[cint32_t,cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cmap[cint32_t,cint32_t]]] c_inst = make_shared[vector[cmap[cint32_t,cint32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[int, int]")
                if not isinstance(item, Map__i32_i32):
                    item = Map__i32_i32(item)
                deref(c_inst).push_back(deref((<Map__i32_i32>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[cint32_t,cint32_t]]] c_inst
        cdef shared_ptr[cmap[cint32_t,cint32_t]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[cint32_t,cint32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Map__i32_i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Map__i32_i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return Map__i32_i32.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__i32_i32):
                item = Map__i32_i32(item)
        except Exception:
            return False
        if not isinstance(item, Map__i32_i32):
            return False
        return std_libcpp.find[vector[cmap[cint32_t,cint32_t]].iterator, cmap[cint32_t,cint32_t]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__i32_i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cmap[cint32_t,cint32_t]] citem
        cdef vector[cmap[cint32_t,cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Map__i32_i32(self._cpp_obj, deref(loc))
            yield Map__i32_i32.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cmap[cint32_t,cint32_t]] citem
        cdef vector[cmap[cint32_t,cint32_t]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Map__i32_i32(self._cpp_obj, deref(loc))
            yield Map__i32_i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__i32_i32):
                item = Map__i32_i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__i32_i32):
            raise err
        cdef vector[cmap[cint32_t,cint32_t]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cmap[cint32_t,cint32_t]].iterator loc = std_libcpp.find[vector[cmap[cint32_t,cint32_t]].iterator, cmap[cint32_t,cint32_t]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Map__i32_i32>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__i32_i32):
                item = Map__i32_i32(item)
        except Exception:
            return 0
        if not isinstance(item, Map__i32_i32):
            return 0
        return <cint64_t> std_libcpp.count[vector[cmap[cint32_t,cint32_t]].iterator, cmap[cint32_t,cint32_t]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__i32_i32>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Map__i32_i32()


Sequence.register(List__Map__i32_i32)

@__cython.auto_pickle(False)
cdef class List__Set__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Set__i32):
            self._cpp_obj = (<List__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cset[cint32_t]]] c_items):
        __fbthrift_inst = <List__Set__i32>List__Set__i32.__new__(List__Set__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__Set__i32 self):
        cdef shared_ptr[vector[cset[cint32_t]]] cpp_obj = make_shared[vector[cset[cint32_t]]](
            deref(self._cpp_obj)
        )
        return List__Set__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cset[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cset[cint32_t]]] c_inst = make_shared[vector[cset[cint32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[int]")
                if not isinstance(item, Set__i32):
                    item = Set__i32(item)
                deref(c_inst).push_back(deref((<Set__i32>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[cint32_t]]] c_inst
        cdef shared_ptr[cset[cint32_t]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[cint32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Set__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return Set__i32.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return False
        if not isinstance(item, Set__i32):
            return False
        return std_libcpp.find[vector[cset[cint32_t]].iterator, cset[cint32_t]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cset[cint32_t]] citem
        cdef vector[cset[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(loc))
            yield Set__i32.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cset[cint32_t]] citem
        cdef vector[cset[cint32_t]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(loc))
            yield Set__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Set__i32):
            raise err
        cdef vector[cset[cint32_t]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cset[cint32_t]].iterator loc = std_libcpp.find[vector[cset[cint32_t]].iterator, cset[cint32_t]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Set__i32>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return 0
        if not isinstance(item, Set__i32):
            return 0
        return <cint64_t> std_libcpp.count[vector[cset[cint32_t]].iterator, cset[cint32_t]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__i32>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Set__i32()


Sequence.register(List__Set__i32)

@__cython.auto_pickle(False)
cdef class Map__i32_Map__i32_Set__i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__i32_Map__i32_Set__i32):
            self._cpp_obj = (<Map__i32_Map__i32_Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__i32_Map__i32_Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]] c_items):
        __fbthrift_inst = <Map__i32_Map__i32_Set__i32>Map__i32_Map__i32_Set__i32.__new__(Map__i32_Map__i32_Set__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__i32_Map__i32_Set__i32 self):
        cdef shared_ptr[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]] cpp_obj = make_shared[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]](
            deref(self._cpp_obj)
        )
        return Map__i32_Map__i32_Set__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]] c_inst = make_shared[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <cint32_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[int, _typing.AbstractSet[int]]")
                if not isinstance(item, Map__i32_Set__i32):
                    item = Map__i32_Set__i32(item)

                deref(c_inst)[key] = deref((<Map__i32_Set__i32>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cmap[cint32_t,cset[cint32_t]]] citem = reference_shared_ptr_Map__i32_Map__i32_Set__i32(self._cpp_obj, deref(iter).second)
        return Map__i32_Set__i32.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef cint32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef shared_ptr[cmap[cint32_t,cset[cint32_t]]] citem
        cdef cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__i32_Map__i32_Set__i32(self._cpp_obj, deref(loc).second)
            yield Map__i32_Set__i32.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef cint32_t ckey
        cdef shared_ptr[cmap[cint32_t,cset[cint32_t]]] citem
        cdef cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__i32_Map__i32_Set__i32(self._cpp_obj, deref(loc).second)
            yield (ckey, Map__i32_Set__i32.create(citem))
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__i32_Map__i32_Set__i32()


Mapping.register(Map__i32_Map__i32_Set__i32)

@__cython.auto_pickle(False)
cdef class List__Map__i32_Map__i32_Set__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Map__i32_Map__i32_Set__i32):
            self._cpp_obj = (<List__Map__i32_Map__i32_Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__Map__i32_Map__i32_Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]] c_items):
        __fbthrift_inst = <List__Map__i32_Map__i32_Set__i32>List__Map__i32_Map__i32_Set__i32.__new__(List__Map__i32_Map__i32_Set__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__Map__i32_Map__i32_Set__i32 self):
        cdef shared_ptr[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]] cpp_obj = make_shared[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]](
            deref(self._cpp_obj)
        )
        return List__Map__i32_Map__i32_Set__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]] c_inst = make_shared[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[int, _typing.Mapping[int, _typing.AbstractSet[int]]]")
                if not isinstance(item, Map__i32_Map__i32_Set__i32):
                    item = Map__i32_Map__i32_Set__i32(item)
                deref(c_inst).push_back(deref((<Map__i32_Map__i32_Set__i32>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]] c_inst
        cdef shared_ptr[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Map__i32_Map__i32_Set__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Map__i32_Map__i32_Set__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return Map__i32_Map__i32_Set__i32.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__i32_Map__i32_Set__i32):
                item = Map__i32_Map__i32_Set__i32(item)
        except Exception:
            return False
        if not isinstance(item, Map__i32_Map__i32_Set__i32):
            return False
        return std_libcpp.find[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]].iterator, cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__i32_Map__i32_Set__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]] citem
        cdef vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Map__i32_Map__i32_Set__i32(self._cpp_obj, deref(loc))
            yield Map__i32_Map__i32_Set__i32.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]] citem
        cdef vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Map__i32_Map__i32_Set__i32(self._cpp_obj, deref(loc))
            yield Map__i32_Map__i32_Set__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__i32_Map__i32_Set__i32):
                item = Map__i32_Map__i32_Set__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__i32_Map__i32_Set__i32):
            raise err
        cdef vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]].iterator loc = std_libcpp.find[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]].iterator, cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Map__i32_Map__i32_Set__i32>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__i32_Map__i32_Set__i32):
                item = Map__i32_Map__i32_Set__i32(item)
        except Exception:
            return 0
        if not isinstance(item, Map__i32_Map__i32_Set__i32):
            return 0
        return <cint64_t> std_libcpp.count[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]].iterator, cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__i32_Map__i32_Set__i32>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Map__i32_Map__i32_Set__i32()


Sequence.register(List__Map__i32_Map__i32_Set__i32)

@__cython.auto_pickle(False)
cdef class List__List__Map__i32_Map__i32_Set__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__List__Map__i32_Map__i32_Set__i32):
            self._cpp_obj = (<List__List__Map__i32_Map__i32_Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__List__Map__i32_Map__i32_Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]]] c_items):
        __fbthrift_inst = <List__List__Map__i32_Map__i32_Set__i32>List__List__Map__i32_Map__i32_Set__i32.__new__(List__List__Map__i32_Map__i32_Set__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__List__Map__i32_Map__i32_Set__i32 self):
        cdef shared_ptr[vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]]] cpp_obj = make_shared[vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]]](
            deref(self._cpp_obj)
        )
        return List__List__Map__i32_Map__i32_Set__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]]] c_inst = make_shared[vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[_typing.Mapping[int, _typing.Mapping[int, _typing.AbstractSet[int]]]]")
                if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
                    item = List__Map__i32_Map__i32_Set__i32(item)
                deref(c_inst).push_back(deref((<List__Map__i32_Map__i32_Set__i32>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]]] c_inst
        cdef shared_ptr[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__List__Map__i32_Map__i32_Set__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__List__Map__i32_Map__i32_Set__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return List__Map__i32_Map__i32_Set__i32.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
                item = List__Map__i32_Map__i32_Set__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
            return False
        return std_libcpp.find[vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]].iterator, vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__Map__i32_Map__i32_Set__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]] citem
        cdef vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__List__Map__i32_Map__i32_Set__i32(self._cpp_obj, deref(loc))
            yield List__Map__i32_Map__i32_Set__i32.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]] citem
        cdef vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__List__Map__i32_Map__i32_Set__i32(self._cpp_obj, deref(loc))
            yield List__Map__i32_Map__i32_Set__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
                item = List__Map__i32_Map__i32_Set__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
            raise err
        cdef vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]].iterator loc = std_libcpp.find[vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]].iterator, vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<List__Map__i32_Map__i32_Set__i32>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
                item = List__Map__i32_Map__i32_Set__i32(item)
        except Exception:
            return 0
        if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
            return 0
        return <cint64_t> std_libcpp.count[vector[vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]].iterator, vector[cmap[cint32_t,cmap[cint32_t,cset[cint32_t]]]]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__Map__i32_Map__i32_Set__i32>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__List__Map__i32_Map__i32_Set__i32()


Sequence.register(List__List__Map__i32_Map__i32_Set__i32)


/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/complex-struct/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/complex-struct/gen-cpp2/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/complex-struct/gen-cpp2/module_data.h"


namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyStruct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 28;
  static constexpr folly::StringPiece _names[] = {
    "MyIntField",
    "MyStringField",
    "MyDataField",
    "myEnum",
    "MyBoolField",
    "MyByteField",
    "MyShortField",
    "MyLongField",
    "MyDoubleField",
    "lDouble",
    "lShort",
    "lInteger",
    "lLong",
    "lString",
    "lBool",
    "lByte",
    "mShortString",
    "mIntegerString",
    "mStringMyStruct",
    "mStringBool",
    "mIntegerInteger",
    "mIntegerBool",
    "sShort",
    "sMyStruct",
    "sLong",
    "sString",
    "sByte",
    "mListList",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
  };
  static constexpr TType _types[] = {
    TType::T_I64,
    TType::T_STRING,
    TType::T_STRUCT,
    TType::T_I32,
    TType::T_BOOL,
    TType::T_BYTE,
    TType::T_I16,
    TType::T_I64,
    TType::T_DOUBLE,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_SET,
    TType::T_SET,
    TType::T_SET,
    TType::T_SET,
    TType::T_SET,
    TType::T_MAP,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStruct::MyStruct() :
      MyIntField(0),
      myEnum( ::cpp2::MyEnum::MyValue1),
      MyBoolField(0),
      MyByteField(0),
      MyShortField(0),
      MyLongField(0),
      MyDoubleField(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


MyStruct::~MyStruct() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStruct::MyStruct(apache::thrift::FragileConstructor, int64_t MyIntField__arg, ::std::string MyStringField__arg,  ::cpp2::MyDataItem MyDataField__arg,  ::cpp2::MyEnum myEnum__arg, bool MyBoolField__arg, int8_t MyByteField__arg, int16_t MyShortField__arg, int64_t MyLongField__arg, double MyDoubleField__arg, ::std::vector<double> lDouble__arg, ::std::vector<int16_t> lShort__arg, ::std::vector<int32_t> lInteger__arg, ::std::vector<int64_t> lLong__arg, ::std::vector<::std::string> lString__arg, ::std::vector<bool> lBool__arg, ::std::vector<int8_t> lByte__arg, ::std::map<int16_t, ::std::string> mShortString__arg, ::std::map<int32_t, ::std::string> mIntegerString__arg, ::std::map<::std::string,  ::cpp2::MyStruct> mStringMyStruct__arg, ::std::map<::std::string, bool> mStringBool__arg, ::std::map<int32_t, int32_t> mIntegerInteger__arg, ::std::map<int32_t, bool> mIntegerBool__arg, ::std::set<int16_t> sShort__arg, ::std::set< ::cpp2::MyStruct> sMyStruct__arg, ::std::set<int64_t> sLong__arg, ::std::set<::std::string> sString__arg, ::std::set<int8_t> sByte__arg, ::std::map<::std::vector<int32_t>, ::std::vector<int32_t>> mListList__arg) :
    MyIntField(std::move(MyIntField__arg)),
    MyStringField(std::move(MyStringField__arg)),
    MyDataField(std::move(MyDataField__arg)),
    myEnum(std::move(myEnum__arg)),
    MyBoolField(std::move(MyBoolField__arg)),
    MyByteField(std::move(MyByteField__arg)),
    MyShortField(std::move(MyShortField__arg)),
    MyLongField(std::move(MyLongField__arg)),
    MyDoubleField(std::move(MyDoubleField__arg)),
    lDouble(std::move(lDouble__arg)),
    lShort(std::move(lShort__arg)),
    lInteger(std::move(lInteger__arg)),
    lLong(std::move(lLong__arg)),
    lString(std::move(lString__arg)),
    lBool(std::move(lBool__arg)),
    lByte(std::move(lByte__arg)),
    mShortString(std::move(mShortString__arg)),
    mIntegerString(std::move(mIntegerString__arg)),
    mStringMyStruct(std::move(mStringMyStruct__arg)),
    mStringBool(std::move(mStringBool__arg)),
    mIntegerInteger(std::move(mIntegerInteger__arg)),
    mIntegerBool(std::move(mIntegerBool__arg)),
    sShort(std::move(sShort__arg)),
    sMyStruct(std::move(sMyStruct__arg)),
    sLong(std::move(sLong__arg)),
    sString(std::move(sString__arg)),
    sByte(std::move(sByte__arg)),
    mListList(std::move(mListList__arg)) {
  __isset.MyIntField = true;
  __isset.MyStringField = true;
  __isset.MyDataField = true;
  __isset.myEnum = true;
  __isset.MyBoolField = true;
  __isset.MyByteField = true;
  __isset.MyShortField = true;
  __isset.MyLongField = true;
  __isset.MyDoubleField = true;
  __isset.lDouble = true;
  __isset.lShort = true;
  __isset.lInteger = true;
  __isset.lLong = true;
  __isset.lString = true;
  __isset.lBool = true;
  __isset.lByte = true;
  __isset.mShortString = true;
  __isset.mIntegerString = true;
  __isset.mStringMyStruct = true;
  __isset.mStringBool = true;
  __isset.mIntegerInteger = true;
  __isset.mIntegerBool = true;
  __isset.sShort = true;
  __isset.sMyStruct = true;
  __isset.sLong = true;
  __isset.sString = true;
  __isset.sByte = true;
  __isset.mListList = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MyStruct::__clear() {
  // clear all fields
  MyIntField = 0;
  MyStringField = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  myEnum =  ::cpp2::MyEnum::MyValue1;
  MyBoolField = 0;
  MyByteField = 0;
  MyShortField = 0;
  MyLongField = 0;
  MyDoubleField = 0;
  lDouble.clear();
  lShort.clear();
  lInteger.clear();
  lLong.clear();
  lString.clear();
  lBool.clear();
  lByte.clear();
  mShortString.clear();
  mIntegerString.clear();
  mStringMyStruct.clear();
  mStringBool.clear();
  mIntegerInteger.clear();
  mIntegerBool.clear();
  sShort.clear();
  sMyStruct.clear();
  sLong.clear();
  sString.clear();
  sByte.clear();
  mListList.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MyStruct::operator==(const MyStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.MyIntField == rhs.MyIntField)) {
    return false;
  }
  if (!(lhs.MyStringField == rhs.MyStringField)) {
    return false;
  }
  if (!(lhs.MyDataField == rhs.MyDataField)) {
    return false;
  }
  if (!(lhs.myEnum == rhs.myEnum)) {
    return false;
  }
  if (!(lhs.MyBoolField == rhs.MyBoolField)) {
    return false;
  }
  if (!(lhs.MyByteField == rhs.MyByteField)) {
    return false;
  }
  if (!(lhs.MyShortField == rhs.MyShortField)) {
    return false;
  }
  if (!(lhs.MyLongField == rhs.MyLongField)) {
    return false;
  }
  if (!(lhs.MyDoubleField == rhs.MyDoubleField)) {
    return false;
  }
  if (!(lhs.lDouble == rhs.lDouble)) {
    return false;
  }
  if (!(lhs.lShort == rhs.lShort)) {
    return false;
  }
  if (!(lhs.lInteger == rhs.lInteger)) {
    return false;
  }
  if (!(lhs.lLong == rhs.lLong)) {
    return false;
  }
  if (!(lhs.lString == rhs.lString)) {
    return false;
  }
  if (!(lhs.lBool == rhs.lBool)) {
    return false;
  }
  if (!(lhs.lByte == rhs.lByte)) {
    return false;
  }
  if (!(lhs.mShortString == rhs.mShortString)) {
    return false;
  }
  if (!(lhs.mIntegerString == rhs.mIntegerString)) {
    return false;
  }
  if (!(lhs.mStringMyStruct == rhs.mStringMyStruct)) {
    return false;
  }
  if (!(lhs.mStringBool == rhs.mStringBool)) {
    return false;
  }
  if (!(lhs.mIntegerInteger == rhs.mIntegerInteger)) {
    return false;
  }
  if (!(lhs.mIntegerBool == rhs.mIntegerBool)) {
    return false;
  }
  if (!(lhs.sShort == rhs.sShort)) {
    return false;
  }
  if (!(lhs.sMyStruct == rhs.sMyStruct)) {
    return false;
  }
  if (!(lhs.sLong == rhs.sLong)) {
    return false;
  }
  if (!(lhs.sString == rhs.sString)) {
    return false;
  }
  if (!(lhs.sByte == rhs.sByte)) {
    return false;
  }
  if (!(lhs.mListList == rhs.mListList)) {
    return false;
  }
  return true;
}

bool MyStruct::operator<(const MyStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.MyIntField == rhs.MyIntField)) {
    return lhs.MyIntField < rhs.MyIntField;
  }
  if (!(lhs.MyStringField == rhs.MyStringField)) {
    return lhs.MyStringField < rhs.MyStringField;
  }
  if (!(lhs.MyDataField == rhs.MyDataField)) {
    return lhs.MyDataField < rhs.MyDataField;
  }
  if (!(lhs.myEnum == rhs.myEnum)) {
    return lhs.myEnum < rhs.myEnum;
  }
  if (!(lhs.MyBoolField == rhs.MyBoolField)) {
    return lhs.MyBoolField < rhs.MyBoolField;
  }
  if (!(lhs.MyByteField == rhs.MyByteField)) {
    return lhs.MyByteField < rhs.MyByteField;
  }
  if (!(lhs.MyShortField == rhs.MyShortField)) {
    return lhs.MyShortField < rhs.MyShortField;
  }
  if (!(lhs.MyLongField == rhs.MyLongField)) {
    return lhs.MyLongField < rhs.MyLongField;
  }
  if (!(lhs.MyDoubleField == rhs.MyDoubleField)) {
    return lhs.MyDoubleField < rhs.MyDoubleField;
  }
  if (!(lhs.lDouble == rhs.lDouble)) {
    return lhs.lDouble < rhs.lDouble;
  }
  if (!(lhs.lShort == rhs.lShort)) {
    return lhs.lShort < rhs.lShort;
  }
  if (!(lhs.lInteger == rhs.lInteger)) {
    return lhs.lInteger < rhs.lInteger;
  }
  if (!(lhs.lLong == rhs.lLong)) {
    return lhs.lLong < rhs.lLong;
  }
  if (!(lhs.lString == rhs.lString)) {
    return lhs.lString < rhs.lString;
  }
  if (!(lhs.lBool == rhs.lBool)) {
    return lhs.lBool < rhs.lBool;
  }
  if (!(lhs.lByte == rhs.lByte)) {
    return lhs.lByte < rhs.lByte;
  }
  if (!(lhs.mShortString == rhs.mShortString)) {
    return lhs.mShortString < rhs.mShortString;
  }
  if (!(lhs.mIntegerString == rhs.mIntegerString)) {
    return lhs.mIntegerString < rhs.mIntegerString;
  }
  if (!(lhs.mStringMyStruct == rhs.mStringMyStruct)) {
    return lhs.mStringMyStruct < rhs.mStringMyStruct;
  }
  if (!(lhs.mStringBool == rhs.mStringBool)) {
    return lhs.mStringBool < rhs.mStringBool;
  }
  if (!(lhs.mIntegerInteger == rhs.mIntegerInteger)) {
    return lhs.mIntegerInteger < rhs.mIntegerInteger;
  }
  if (!(lhs.mIntegerBool == rhs.mIntegerBool)) {
    return lhs.mIntegerBool < rhs.mIntegerBool;
  }
  if (!(lhs.sShort == rhs.sShort)) {
    return lhs.sShort < rhs.sShort;
  }
  if (!(lhs.sMyStruct == rhs.sMyStruct)) {
    return lhs.sMyStruct < rhs.sMyStruct;
  }
  if (!(lhs.sLong == rhs.sLong)) {
    return lhs.sLong < rhs.sLong;
  }
  if (!(lhs.sString == rhs.sString)) {
    return lhs.sString < rhs.sString;
  }
  if (!(lhs.sByte == rhs.sByte)) {
    return lhs.sByte < rhs.sByte;
  }
  if (!(lhs.mListList == rhs.mListList)) {
    return lhs.mListList < rhs.mListList;
  }
  return false;
}

const  ::cpp2::MyDataItem& MyStruct::get_MyDataField() const& {
  return MyDataField;
}

 ::cpp2::MyDataItem MyStruct::get_MyDataField() && {
  return std::move(MyDataField);
}

const ::std::vector<double>& MyStruct::get_lDouble() const& {
  return lDouble;
}

::std::vector<double> MyStruct::get_lDouble() && {
  return std::move(lDouble);
}

const ::std::vector<int16_t>& MyStruct::get_lShort() const& {
  return lShort;
}

::std::vector<int16_t> MyStruct::get_lShort() && {
  return std::move(lShort);
}

const ::std::vector<int32_t>& MyStruct::get_lInteger() const& {
  return lInteger;
}

::std::vector<int32_t> MyStruct::get_lInteger() && {
  return std::move(lInteger);
}

const ::std::vector<int64_t>& MyStruct::get_lLong() const& {
  return lLong;
}

::std::vector<int64_t> MyStruct::get_lLong() && {
  return std::move(lLong);
}

const ::std::vector<::std::string>& MyStruct::get_lString() const& {
  return lString;
}

::std::vector<::std::string> MyStruct::get_lString() && {
  return std::move(lString);
}

const ::std::vector<bool>& MyStruct::get_lBool() const& {
  return lBool;
}

::std::vector<bool> MyStruct::get_lBool() && {
  return std::move(lBool);
}

const ::std::vector<int8_t>& MyStruct::get_lByte() const& {
  return lByte;
}

::std::vector<int8_t> MyStruct::get_lByte() && {
  return std::move(lByte);
}

const ::std::map<int16_t, ::std::string>& MyStruct::get_mShortString() const& {
  return mShortString;
}

::std::map<int16_t, ::std::string> MyStruct::get_mShortString() && {
  return std::move(mShortString);
}

const ::std::map<int32_t, ::std::string>& MyStruct::get_mIntegerString() const& {
  return mIntegerString;
}

::std::map<int32_t, ::std::string> MyStruct::get_mIntegerString() && {
  return std::move(mIntegerString);
}

const ::std::map<::std::string,  ::cpp2::MyStruct>& MyStruct::get_mStringMyStruct() const& {
  return mStringMyStruct;
}

::std::map<::std::string,  ::cpp2::MyStruct> MyStruct::get_mStringMyStruct() && {
  return std::move(mStringMyStruct);
}

const ::std::map<::std::string, bool>& MyStruct::get_mStringBool() const& {
  return mStringBool;
}

::std::map<::std::string, bool> MyStruct::get_mStringBool() && {
  return std::move(mStringBool);
}

const ::std::map<int32_t, int32_t>& MyStruct::get_mIntegerInteger() const& {
  return mIntegerInteger;
}

::std::map<int32_t, int32_t> MyStruct::get_mIntegerInteger() && {
  return std::move(mIntegerInteger);
}

const ::std::map<int32_t, bool>& MyStruct::get_mIntegerBool() const& {
  return mIntegerBool;
}

::std::map<int32_t, bool> MyStruct::get_mIntegerBool() && {
  return std::move(mIntegerBool);
}

const ::std::set<int16_t>& MyStruct::get_sShort() const& {
  return sShort;
}

::std::set<int16_t> MyStruct::get_sShort() && {
  return std::move(sShort);
}

const ::std::set< ::cpp2::MyStruct>& MyStruct::get_sMyStruct() const& {
  return sMyStruct;
}

::std::set< ::cpp2::MyStruct> MyStruct::get_sMyStruct() && {
  return std::move(sMyStruct);
}

const ::std::set<int64_t>& MyStruct::get_sLong() const& {
  return sLong;
}

::std::set<int64_t> MyStruct::get_sLong() && {
  return std::move(sLong);
}

const ::std::set<::std::string>& MyStruct::get_sString() const& {
  return sString;
}

::std::set<::std::string> MyStruct::get_sString() && {
  return std::move(sString);
}

const ::std::set<int8_t>& MyStruct::get_sByte() const& {
  return sByte;
}

::std::set<int8_t> MyStruct::get_sByte() && {
  return std::move(sByte);
}

const ::std::map<::std::vector<int32_t>, ::std::vector<int32_t>>& MyStruct::get_mListList() const& {
  return mListList;
}

::std::map<::std::vector<int32_t>, ::std::vector<int32_t>> MyStruct::get_mListList() && {
  return std::move(mListList);
}


void swap(MyStruct& a, MyStruct& b) {
  using ::std::swap;
  swap(a.MyIntField_ref().value(), b.MyIntField_ref().value());
  swap(a.MyStringField_ref().value(), b.MyStringField_ref().value());
  swap(a.MyDataField_ref().value(), b.MyDataField_ref().value());
  swap(a.myEnum_ref().value(), b.myEnum_ref().value());
  swap(a.MyBoolField_ref().value(), b.MyBoolField_ref().value());
  swap(a.MyByteField_ref().value(), b.MyByteField_ref().value());
  swap(a.MyShortField_ref().value(), b.MyShortField_ref().value());
  swap(a.MyLongField_ref().value(), b.MyLongField_ref().value());
  swap(a.MyDoubleField_ref().value(), b.MyDoubleField_ref().value());
  swap(a.lDouble_ref().value(), b.lDouble_ref().value());
  swap(a.lShort_ref().value(), b.lShort_ref().value());
  swap(a.lInteger_ref().value(), b.lInteger_ref().value());
  swap(a.lLong_ref().value(), b.lLong_ref().value());
  swap(a.lString_ref().value(), b.lString_ref().value());
  swap(a.lBool_ref().value(), b.lBool_ref().value());
  swap(a.lByte_ref().value(), b.lByte_ref().value());
  swap(a.mShortString_ref().value(), b.mShortString_ref().value());
  swap(a.mIntegerString_ref().value(), b.mIntegerString_ref().value());
  swap(a.mStringMyStruct_ref().value(), b.mStringMyStruct_ref().value());
  swap(a.mStringBool_ref().value(), b.mStringBool_ref().value());
  swap(a.mIntegerInteger_ref().value(), b.mIntegerInteger_ref().value());
  swap(a.mIntegerBool_ref().value(), b.mIntegerBool_ref().value());
  swap(a.sShort_ref().value(), b.sShort_ref().value());
  swap(a.sMyStruct_ref().value(), b.sMyStruct_ref().value());
  swap(a.sLong_ref().value(), b.sLong_ref().value());
  swap(a.sString_ref().value(), b.sString_ref().value());
  swap(a.sByte_ref().value(), b.sByte_ref().value());
  swap(a.mListList_ref().value(), b.mListList_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MyStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyStruct,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyDataItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyStruct,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyDataItem>,
    "inconsistent use of nimble option");

} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyStructTypeDef>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 9;
  static constexpr folly::StringPiece _names[] = {
    "myLongField",
    "myLongTypeDef",
    "myStringField",
    "myStringTypedef",
    "myMapField",
    "myMapTypedef",
    "myListField",
    "myListTypedef",
    "myMapListOfTypeDef",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
  };
  static constexpr TType _types[] = {
    TType::T_I64,
    TType::T_I64,
    TType::T_STRING,
    TType::T_STRING,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_MAP,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStructTypeDef::MyStructTypeDef() :
      myLongField(0),
      myLongTypeDef(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


MyStructTypeDef::~MyStructTypeDef() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStructTypeDef::MyStructTypeDef(apache::thrift::FragileConstructor, int64_t myLongField__arg,  ::cpp2::longTypeDef myLongTypeDef__arg, ::std::string myStringField__arg,  ::cpp2::stringTypedef myStringTypedef__arg, ::std::map<int16_t, ::std::string> myMapField__arg,  ::cpp2::mapTypedef myMapTypedef__arg, ::std::vector<double> myListField__arg,  ::cpp2::listTypedef myListTypedef__arg, ::std::map<int16_t, ::std::vector< ::cpp2::listTypedef>> myMapListOfTypeDef__arg) :
    myLongField(std::move(myLongField__arg)),
    myLongTypeDef(std::move(myLongTypeDef__arg)),
    myStringField(std::move(myStringField__arg)),
    myStringTypedef(std::move(myStringTypedef__arg)),
    myMapField(std::move(myMapField__arg)),
    myMapTypedef(std::move(myMapTypedef__arg)),
    myListField(std::move(myListField__arg)),
    myListTypedef(std::move(myListTypedef__arg)),
    myMapListOfTypeDef(std::move(myMapListOfTypeDef__arg)) {
  __isset.myLongField = true;
  __isset.myLongTypeDef = true;
  __isset.myStringField = true;
  __isset.myStringTypedef = true;
  __isset.myMapField = true;
  __isset.myMapTypedef = true;
  __isset.myListField = true;
  __isset.myListTypedef = true;
  __isset.myMapListOfTypeDef = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MyStructTypeDef::__clear() {
  // clear all fields
  myLongField = 0;
  myLongTypeDef = 0;
  myStringField = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  myStringTypedef = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  myMapField.clear();
  myMapTypedef.clear();
  myListField.clear();
  myListTypedef.clear();
  myMapListOfTypeDef.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MyStructTypeDef::operator==(const MyStructTypeDef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.myLongField == rhs.myLongField)) {
    return false;
  }
  if (!(lhs.myLongTypeDef == rhs.myLongTypeDef)) {
    return false;
  }
  if (!(lhs.myStringField == rhs.myStringField)) {
    return false;
  }
  if (!(lhs.myStringTypedef == rhs.myStringTypedef)) {
    return false;
  }
  if (!(lhs.myMapField == rhs.myMapField)) {
    return false;
  }
  if (!(lhs.myMapTypedef == rhs.myMapTypedef)) {
    return false;
  }
  if (!(lhs.myListField == rhs.myListField)) {
    return false;
  }
  if (!(lhs.myListTypedef == rhs.myListTypedef)) {
    return false;
  }
  if (!(lhs.myMapListOfTypeDef == rhs.myMapListOfTypeDef)) {
    return false;
  }
  return true;
}

bool MyStructTypeDef::operator<(const MyStructTypeDef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.myLongField == rhs.myLongField)) {
    return lhs.myLongField < rhs.myLongField;
  }
  if (!(lhs.myLongTypeDef == rhs.myLongTypeDef)) {
    return lhs.myLongTypeDef < rhs.myLongTypeDef;
  }
  if (!(lhs.myStringField == rhs.myStringField)) {
    return lhs.myStringField < rhs.myStringField;
  }
  if (!(lhs.myStringTypedef == rhs.myStringTypedef)) {
    return lhs.myStringTypedef < rhs.myStringTypedef;
  }
  if (!(lhs.myMapField == rhs.myMapField)) {
    return lhs.myMapField < rhs.myMapField;
  }
  if (!(lhs.myMapTypedef == rhs.myMapTypedef)) {
    return lhs.myMapTypedef < rhs.myMapTypedef;
  }
  if (!(lhs.myListField == rhs.myListField)) {
    return lhs.myListField < rhs.myListField;
  }
  if (!(lhs.myListTypedef == rhs.myListTypedef)) {
    return lhs.myListTypedef < rhs.myListTypedef;
  }
  if (!(lhs.myMapListOfTypeDef == rhs.myMapListOfTypeDef)) {
    return lhs.myMapListOfTypeDef < rhs.myMapListOfTypeDef;
  }
  return false;
}

const ::std::map<int16_t, ::std::string>& MyStructTypeDef::get_myMapField() const& {
  return myMapField;
}

::std::map<int16_t, ::std::string> MyStructTypeDef::get_myMapField() && {
  return std::move(myMapField);
}

const  ::cpp2::mapTypedef& MyStructTypeDef::get_myMapTypedef() const& {
  return myMapTypedef;
}

 ::cpp2::mapTypedef MyStructTypeDef::get_myMapTypedef() && {
  return std::move(myMapTypedef);
}

const ::std::vector<double>& MyStructTypeDef::get_myListField() const& {
  return myListField;
}

::std::vector<double> MyStructTypeDef::get_myListField() && {
  return std::move(myListField);
}

const  ::cpp2::listTypedef& MyStructTypeDef::get_myListTypedef() const& {
  return myListTypedef;
}

 ::cpp2::listTypedef MyStructTypeDef::get_myListTypedef() && {
  return std::move(myListTypedef);
}

const ::std::map<int16_t, ::std::vector< ::cpp2::listTypedef>>& MyStructTypeDef::get_myMapListOfTypeDef() const& {
  return myMapListOfTypeDef;
}

::std::map<int16_t, ::std::vector< ::cpp2::listTypedef>> MyStructTypeDef::get_myMapListOfTypeDef() && {
  return std::move(myMapListOfTypeDef);
}


void swap(MyStructTypeDef& a, MyStructTypeDef& b) {
  using ::std::swap;
  swap(a.myLongField_ref().value(), b.myLongField_ref().value());
  swap(a.myLongTypeDef_ref().value(), b.myLongTypeDef_ref().value());
  swap(a.myStringField_ref().value(), b.myStringField_ref().value());
  swap(a.myStringTypedef_ref().value(), b.myStringTypedef_ref().value());
  swap(a.myMapField_ref().value(), b.myMapField_ref().value());
  swap(a.myMapTypedef_ref().value(), b.myMapTypedef_ref().value());
  swap(a.myListField_ref().value(), b.myListField_ref().value());
  swap(a.myListTypedef_ref().value(), b.myListTypedef_ref().value());
  swap(a.myMapListOfTypeDef_ref().value(), b.myMapListOfTypeDef_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MyStructTypeDef::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStructTypeDef::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStructTypeDef::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStructTypeDef::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStructTypeDef::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStructTypeDef::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStructTypeDef::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStructTypeDef::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyUnionFloatFieldThrowExp>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "myEnum",
    "setFloat",
    "myDataItem",
    "complexNestedStruct",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_LIST,
    TType::T_STRUCT,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::cpp2::MyUnionFloatFieldThrowExp::Type>::size;
folly::Range<::cpp2::MyUnionFloatFieldThrowExp::Type const*> const TEnumTraits<::cpp2::MyUnionFloatFieldThrowExp::Type>::values = folly::range(TEnumDataStorage<::cpp2::MyUnionFloatFieldThrowExp::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::cpp2::MyUnionFloatFieldThrowExp::Type>::names = folly::range(TEnumDataStorage<::cpp2::MyUnionFloatFieldThrowExp::Type>::names);

char const* TEnumTraits<::cpp2::MyUnionFloatFieldThrowExp::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::cpp2::MyUnionFloatFieldThrowExp::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::cpp2::MyUnionFloatFieldThrowExp::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::cpp2::MyUnionFloatFieldThrowExp::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace cpp2 {

void MyUnionFloatFieldThrowExp::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::myEnum:
    {
      destruct(value_.myEnum);
      break;
    }
    case Type::setFloat:
    {
      destruct(value_.setFloat);
      break;
    }
    case Type::myDataItem:
    {
      destruct(value_.myDataItem);
      break;
    }
    case Type::complexNestedStruct:
    {
      destruct(value_.complexNestedStruct);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool MyUnionFloatFieldThrowExp::operator==(const MyUnionFloatFieldThrowExp& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::myEnum:
    {
      return value_.myEnum == rhs.value_.myEnum;
    }
    case Type::setFloat:
    {
      return value_.setFloat == rhs.value_.setFloat;
    }
    case Type::myDataItem:
    {
      return value_.myDataItem == rhs.value_.myDataItem;
    }
    case Type::complexNestedStruct:
    {
      return value_.complexNestedStruct == rhs.value_.complexNestedStruct;
    }
    default:
    {
      return true;
    }
  }
}

bool MyUnionFloatFieldThrowExp::operator<(const MyUnionFloatFieldThrowExp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::myEnum:
      return lhs.value_.myEnum < rhs.value_.myEnum;
    case Type::setFloat:
      return lhs.value_.setFloat < rhs.value_.setFloat;
    case Type::myDataItem:
      return lhs.value_.myDataItem < rhs.value_.myDataItem;
    case Type::complexNestedStruct:
      return lhs.value_.complexNestedStruct < rhs.value_.complexNestedStruct;
    default:
      return false;
  }
}

void swap(MyUnionFloatFieldThrowExp& a, MyUnionFloatFieldThrowExp& b) {
  MyUnionFloatFieldThrowExp temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void MyUnionFloatFieldThrowExp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyUnionFloatFieldThrowExp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyUnionFloatFieldThrowExp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyUnionFloatFieldThrowExp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyUnionFloatFieldThrowExp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyUnionFloatFieldThrowExp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyUnionFloatFieldThrowExp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyUnionFloatFieldThrowExp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyUnionFloatFieldThrowExp,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyDataItem>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyUnionFloatFieldThrowExp,
        ::apache::thrift::type_class::structure,
         ::cpp2::ComplexNestedStruct>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyUnionFloatFieldThrowExp,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyDataItem>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyUnionFloatFieldThrowExp,
        ::apache::thrift::type_class::structure,
         ::cpp2::ComplexNestedStruct>,
    "inconsistent use of nimble option");

} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::emptyXcep>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
emptyXcep::emptyXcep(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void emptyXcep::__clear() {
  // clear all fields
}

bool emptyXcep::operator==(const emptyXcep& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool emptyXcep::operator<(const emptyXcep& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(emptyXcep& a, emptyXcep& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void emptyXcep::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t emptyXcep::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t emptyXcep::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t emptyXcep::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void emptyXcep::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t emptyXcep::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t emptyXcep::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t emptyXcep::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::complexException>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 6;
  static constexpr folly::StringPiece _names[] = {
    "message",
    "listStrings",
    "errorEnum",
    "unionError",
    "structError",
    "lsMap",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_LIST,
    TType::T_I32,
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_MAP,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
complexException::complexException() :
      errorEnum( ::cpp2::MyEnum::MyValue1) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


complexException::~complexException() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
complexException::complexException(apache::thrift::FragileConstructor, ::std::string message__arg, ::std::vector<::std::string> listStrings__arg,  ::cpp2::MyEnum errorEnum__arg,  ::cpp2::MyUnion unionError__arg,  ::cpp2::MyStruct structError__arg, ::std::map<int64_t, ::std::string> lsMap__arg) :
    message(std::move(message__arg)),
    listStrings(std::move(listStrings__arg)),
    errorEnum(std::move(errorEnum__arg)),
    unionError(std::move(unionError__arg)),
    structError(std::move(structError__arg)),
    lsMap(std::move(lsMap__arg)) {
  __isset.message = true;
  __isset.listStrings = true;
  __isset.errorEnum = true;
  __isset.unionError = true;
  __isset.structError = true;
  __isset.lsMap = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void complexException::__clear() {
  // clear all fields
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  listStrings.clear();
  errorEnum =  ::cpp2::MyEnum::MyValue1;
  ::apache::thrift::Cpp2Ops<  ::cpp2::MyUnion>::clear(&unionError);
  ::apache::thrift::Cpp2Ops<  ::cpp2::MyStruct>::clear(&structError);
  lsMap.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool complexException::operator==(const complexException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.listStrings == rhs.listStrings)) {
    return false;
  }
  if (!(lhs.errorEnum == rhs.errorEnum)) {
    return false;
  }
  if (lhs.unionError_ref() != rhs.unionError_ref()) {
    return false;
  }
  if (!(lhs.structError == rhs.structError)) {
    return false;
  }
  if (!(lhs.lsMap == rhs.lsMap)) {
    return false;
  }
  return true;
}

bool complexException::operator<(const complexException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.listStrings == rhs.listStrings)) {
    return lhs.listStrings < rhs.listStrings;
  }
  if (!(lhs.errorEnum == rhs.errorEnum)) {
    return lhs.errorEnum < rhs.errorEnum;
  }
  if (lhs.unionError_ref() != rhs.unionError_ref()) {
    return lhs.unionError_ref() < rhs.unionError_ref();
  }
  if (!(lhs.structError == rhs.structError)) {
    return lhs.structError < rhs.structError;
  }
  if (!(lhs.lsMap == rhs.lsMap)) {
    return lhs.lsMap < rhs.lsMap;
  }
  return false;
}

const ::std::vector<::std::string>& complexException::get_listStrings() const& {
  return listStrings;
}

::std::vector<::std::string> complexException::get_listStrings() && {
  return std::move(listStrings);
}

const  ::cpp2::MyUnion* complexException::get_unionError() const& {
  return unionError_ref().has_value() ? std::addressof(unionError) : nullptr;
}

 ::cpp2::MyUnion* complexException::get_unionError() & {
  return unionError_ref().has_value() ? std::addressof(unionError) : nullptr;
}

const  ::cpp2::MyStruct& complexException::get_structError() const& {
  return structError;
}

 ::cpp2::MyStruct complexException::get_structError() && {
  return std::move(structError);
}

const ::std::map<int64_t, ::std::string>& complexException::get_lsMap() const& {
  return lsMap;
}

::std::map<int64_t, ::std::string> complexException::get_lsMap() && {
  return std::move(lsMap);
}


void swap(complexException& a, complexException& b) {
  using ::std::swap;
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.listStrings_ref().value(), b.listStrings_ref().value());
  swap(a.errorEnum_ref().value(), b.errorEnum_ref().value());
  swap(a.unionError_ref().value_unchecked(), b.unionError_ref().value_unchecked());
  swap(a.structError_ref().value(), b.structError_ref().value());
  swap(a.lsMap_ref().value(), b.lsMap_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void complexException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t complexException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t complexException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t complexException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void complexException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t complexException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t complexException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t complexException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        complexException,
        ::apache::thrift::type_class::variant,
         ::cpp2::MyUnion>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        complexException,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyStruct>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        complexException,
        ::apache::thrift::type_class::variant,
         ::cpp2::MyUnion>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        complexException,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyStruct>,
    "inconsistent use of nimble option");

} // cpp2

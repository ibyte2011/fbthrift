#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.bytes cimport PyBytes_AsStringAndSize
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from libcpp.utility cimport move as cmove
from cpython cimport bool as pbool
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types cimport (
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    constant_shared_ptr,
    default_inst,
    NOTSET as __NOTSET,
    EnumData as __EnumData,
    EnumFlagsData as __EnumFlagsData,
    UnionTypeEnumData as __UnionTypeEnumData,
    createEnumDataForUnionType as __createEnumDataForUnionType,
)
cimport thrift.py3.std_libcpp as std_libcpp
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
import weakref as __weakref
import builtins as _builtins

cimport module.types_reflection as _types_reflection


cdef __EnumData __MyEnumA_enum_data  = __EnumData.create(thrift.py3.types.createEnumData[cMyEnumA](), MyEnumA)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __MyEnumAMeta(thrift.py3.types.EnumMeta):

    def __get_by_name(cls, str name):
        return __MyEnumA_enum_data.get_by_name(name)

    def __get_by_value(cls, int value):
        return __MyEnumA_enum_data.get_by_value(value)

    def __get_all_names(cls):
        return __MyEnumA_enum_data.get_all_names()

    def __len__(cls):
        return __MyEnumA_enum_data.size()


@__cython.final
@__cython.auto_pickle(False)
cdef class MyEnumA(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __MyEnumA_enum_data.get_by_name(name)



__SetMetaClass(<PyTypeObject*> MyEnumA, <PyTypeObject*> __MyEnumAMeta)



@__cython.auto_pickle(False)
cdef class SmallStruct(thrift.py3.types.Struct):

    def __init__(
        SmallStruct self, *,
        pbool small_A=None,
        small_B=None
    ):
        if small_B is not None:
            if not isinstance(small_B, int):
                raise TypeError(f'small_B is not a { int !r}.')
            small_B = <cint32_t> small_B

        self._cpp_obj = __fbthrift_move(SmallStruct._make_instance(
          NULL,
          NULL,
          small_A,
          small_B,
        ))

    def __call__(
        SmallStruct self,
        small_A=__NOTSET,
        small_B=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[2] __isNOTSET  # so make_instance is typed

        __fbthrift_changed = False
        if small_A is ___NOTSET:
            __isNOTSET[0] = True
            small_A = None
        else:
            __isNOTSET[0] = False
            __fbthrift_changed = True

        if small_B is ___NOTSET:
            __isNOTSET[1] = True
            small_B = None
        else:
            __isNOTSET[1] = False
            __fbthrift_changed = True


        if not __fbthrift_changed:
            return self

        if small_A is not None:
            if not isinstance(small_A, bool):
                raise TypeError(f'small_A is not a { bool !r}.')

        if small_B is not None:
            if not isinstance(small_B, int):
                raise TypeError(f'small_B is not a { int !r}.')
            small_B = <cint32_t> small_B

        __fbthrift_inst = <SmallStruct>SmallStruct.__new__(SmallStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move(SmallStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          small_A,
          small_B,
        ))
        return __fbthrift_inst

    @staticmethod
    cdef unique_ptr[cSmallStruct] _make_instance(
        cSmallStruct* base_instance,
        bint* __isNOTSET,
        pbool small_A ,
        object small_B 
    ) except *:
        cdef unique_ptr[cSmallStruct] c_inst
        if base_instance:
            c_inst = make_unique[cSmallStruct](deref(base_instance))
        else:
            c_inst = make_unique[cSmallStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and small_A is None:
                deref(c_inst).small_A_ref().assign(default_inst[cSmallStruct]().small_A_ref().value())
                deref(c_inst).__isset.small_A = False
                pass

            if not __isNOTSET[1] and small_B is None:
                deref(c_inst).small_B_ref().assign(default_inst[cSmallStruct]().small_B_ref().value())
                deref(c_inst).__isset.small_B = False
                pass

        if small_A is not None:
            deref(c_inst).small_A_ref().assign(small_A)
            deref(c_inst).__isset.small_A = True
        if small_B is not None:
            deref(c_inst).small_B_ref().assign(small_B)
            deref(c_inst).__isset.small_B = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return __fbthrift_move_unique(c_inst)

    cdef object __fbthrift_isset(self):
        cpp_obj = deref(self._cpp_obj)
        return thrift.py3.types._IsSet("SmallStruct", {
          "small_A": cpp_obj.small_A_ref().has_value(),
          "small_B": cpp_obj.small_B_ref().has_value(),
        })

    def __iter__(self):
        yield 'small_A', self.small_A
        yield 'small_B', self.small_B

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cSmallStruct] cpp_obj):
        __fbthrift_inst = <SmallStruct>SmallStruct.__new__(SmallStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(cpp_obj)
        return __fbthrift_inst

    @property
    def small_A(self):

        return <pbool> deref(self._cpp_obj).small_A_ref().value()

    @property
    def small_B(self):

        return deref(self._cpp_obj).small_B_ref().value()


    def __hash__(SmallStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.small_A,
            self.small_B,
            ))
        return self.__hash

    def __repr__(SmallStruct self):
        return f'SmallStruct(small_A={repr(self.small_A)}, small_B={repr(self.small_B)})'
    def __copy__(SmallStruct self):
        cdef shared_ptr[cSmallStruct] cpp_obj = make_shared[cSmallStruct](
            deref(self._cpp_obj)
        )
        return SmallStruct.create(__fbthrift_move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, SmallStruct) and
                isinstance(other, SmallStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cSmallStruct* cself = (<SmallStruct>self)._cpp_obj.get()
        cdef cSmallStruct* cother = (<SmallStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__SmallStruct()

    cdef __iobuf.IOBuf _serialize(SmallStruct self, __Protocol proto):
        return __iobuf.from_unique_ptr(
            serializer.cserialize[cSmallStruct](self._cpp_obj.get(), proto).move()
        )

    cdef cuint32_t _deserialize(SmallStruct self, const __iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cSmallStruct]()
        needed = serializer.cdeserialize[cSmallStruct](buf, self._cpp_obj.get(), proto)
        return needed

    def __reduce__(self):
        return (deserialize, (SmallStruct, serialize(self)))


@__cython.auto_pickle(False)
cdef class containerStruct(thrift.py3.types.Struct):

    def __init__(
        containerStruct self, *,
        pbool fieldA=None,
        fieldB=None,
        fieldC=None,
        str fieldD=None,
        str fieldE=None,
        fieldF=None,
        fieldG=None,
        fieldH=None,
        pbool fieldI=None,
        fieldJ=None,
        fieldK=None,
        fieldL=None,
        fieldM=None,
        fieldN=None,
        fieldO=None,
        fieldP=None,
        MyEnumA fieldQ=None,
        fieldR=None,
        SmallStruct fieldS=None,
        SmallStruct fieldT=None,
        SmallStruct fieldU=None,
        SmallStruct fieldX=None
    ):
        self._cpp_obj = __fbthrift_move(containerStruct._make_instance(
          NULL,
          NULL,
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
          fieldI,
          fieldJ,
          fieldK,
          fieldL,
          fieldM,
          fieldN,
          fieldO,
          fieldP,
          fieldQ,
          fieldR,
          fieldS,
          fieldT,
          fieldU,
          fieldX,
        ))

    def __call__(
        containerStruct self,
        fieldA=__NOTSET,
        fieldB=__NOTSET,
        fieldC=__NOTSET,
        fieldD=__NOTSET,
        fieldE=__NOTSET,
        fieldF=__NOTSET,
        fieldG=__NOTSET,
        fieldH=__NOTSET,
        fieldI=__NOTSET,
        fieldJ=__NOTSET,
        fieldK=__NOTSET,
        fieldL=__NOTSET,
        fieldM=__NOTSET,
        fieldN=__NOTSET,
        fieldO=__NOTSET,
        fieldP=__NOTSET,
        fieldQ=__NOTSET,
        fieldR=__NOTSET,
        fieldS=__NOTSET,
        fieldT=__NOTSET,
        fieldU=__NOTSET,
        fieldX=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[22] __isNOTSET  # so make_instance is typed

        __fbthrift_changed = False
        if fieldA is ___NOTSET:
            __isNOTSET[0] = True
            fieldA = None
        else:
            __isNOTSET[0] = False
            __fbthrift_changed = True

        if fieldB is ___NOTSET:
            __isNOTSET[1] = True
            fieldB = None
        else:
            __isNOTSET[1] = False
            __fbthrift_changed = True

        if fieldC is ___NOTSET:
            __isNOTSET[2] = True
            fieldC = None
        else:
            __isNOTSET[2] = False
            __fbthrift_changed = True

        if fieldD is ___NOTSET:
            __isNOTSET[3] = True
            fieldD = None
        else:
            __isNOTSET[3] = False
            __fbthrift_changed = True

        if fieldE is ___NOTSET:
            __isNOTSET[4] = True
            fieldE = None
        else:
            __isNOTSET[4] = False
            __fbthrift_changed = True

        if fieldF is ___NOTSET:
            __isNOTSET[5] = True
            fieldF = None
        else:
            __isNOTSET[5] = False
            __fbthrift_changed = True

        if fieldG is ___NOTSET:
            __isNOTSET[6] = True
            fieldG = None
        else:
            __isNOTSET[6] = False
            __fbthrift_changed = True

        if fieldH is ___NOTSET:
            __isNOTSET[7] = True
            fieldH = None
        else:
            __isNOTSET[7] = False
            __fbthrift_changed = True

        if fieldI is ___NOTSET:
            __isNOTSET[8] = True
            fieldI = None
        else:
            __isNOTSET[8] = False
            __fbthrift_changed = True

        if fieldJ is ___NOTSET:
            __isNOTSET[9] = True
            fieldJ = None
        else:
            __isNOTSET[9] = False
            __fbthrift_changed = True

        if fieldK is ___NOTSET:
            __isNOTSET[10] = True
            fieldK = None
        else:
            __isNOTSET[10] = False
            __fbthrift_changed = True

        if fieldL is ___NOTSET:
            __isNOTSET[11] = True
            fieldL = None
        else:
            __isNOTSET[11] = False
            __fbthrift_changed = True

        if fieldM is ___NOTSET:
            __isNOTSET[12] = True
            fieldM = None
        else:
            __isNOTSET[12] = False
            __fbthrift_changed = True

        if fieldN is ___NOTSET:
            __isNOTSET[13] = True
            fieldN = None
        else:
            __isNOTSET[13] = False
            __fbthrift_changed = True

        if fieldO is ___NOTSET:
            __isNOTSET[14] = True
            fieldO = None
        else:
            __isNOTSET[14] = False
            __fbthrift_changed = True

        if fieldP is ___NOTSET:
            __isNOTSET[15] = True
            fieldP = None
        else:
            __isNOTSET[15] = False
            __fbthrift_changed = True

        if fieldQ is ___NOTSET:
            __isNOTSET[16] = True
            fieldQ = None
        else:
            __isNOTSET[16] = False
            __fbthrift_changed = True

        if fieldR is ___NOTSET:
            __isNOTSET[17] = True
            fieldR = None
        else:
            __isNOTSET[17] = False
            __fbthrift_changed = True

        if fieldS is ___NOTSET:
            __isNOTSET[18] = True
            fieldS = None
        else:
            __isNOTSET[18] = False
            __fbthrift_changed = True

        if fieldT is ___NOTSET:
            __isNOTSET[19] = True
            fieldT = None
        else:
            __isNOTSET[19] = False
            __fbthrift_changed = True

        if fieldU is ___NOTSET:
            __isNOTSET[20] = True
            fieldU = None
        else:
            __isNOTSET[20] = False
            __fbthrift_changed = True

        if fieldX is ___NOTSET:
            __isNOTSET[21] = True
            fieldX = None
        else:
            __isNOTSET[21] = False
            __fbthrift_changed = True


        if not __fbthrift_changed:
            return self

        if fieldA is not None:
            if not isinstance(fieldA, bool):
                raise TypeError(f'fieldA is not a { bool !r}.')

        if fieldD is not None:
            if not isinstance(fieldD, str):
                raise TypeError(f'fieldD is not a { str !r}.')

        if fieldE is not None:
            if not isinstance(fieldE, str):
                raise TypeError(f'fieldE is not a { str !r}.')

        if fieldI is not None:
            if not isinstance(fieldI, bool):
                raise TypeError(f'fieldI is not a { bool !r}.')

        if fieldQ is not None:
            if not isinstance(fieldQ, MyEnumA):
                raise TypeError(f'field fieldQ value: { fieldQ !r} is not of the enum type { MyEnumA }.')

        if fieldS is not None:
            if not isinstance(fieldS, SmallStruct):
                raise TypeError(f'fieldS is not a { SmallStruct !r}.')

        if fieldT is not None:
            if not isinstance(fieldT, SmallStruct):
                raise TypeError(f'fieldT is not a { SmallStruct !r}.')

        if fieldU is not None:
            if not isinstance(fieldU, SmallStruct):
                raise TypeError(f'fieldU is not a { SmallStruct !r}.')

        if fieldX is not None:
            if not isinstance(fieldX, SmallStruct):
                raise TypeError(f'fieldX is not a { SmallStruct !r}.')

        __fbthrift_inst = <containerStruct>containerStruct.__new__(containerStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move(containerStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
          fieldI,
          fieldJ,
          fieldK,
          fieldL,
          fieldM,
          fieldN,
          fieldO,
          fieldP,
          fieldQ,
          fieldR,
          fieldS,
          fieldT,
          fieldU,
          fieldX,
        ))
        return __fbthrift_inst

    @staticmethod
    cdef unique_ptr[ccontainerStruct] _make_instance(
        ccontainerStruct* base_instance,
        bint* __isNOTSET,
        pbool fieldA ,
        object fieldB ,
        object fieldC ,
        str fieldD ,
        str fieldE ,
        object fieldF ,
        object fieldG ,
        object fieldH ,
        pbool fieldI ,
        object fieldJ ,
        object fieldK ,
        object fieldL ,
        object fieldM ,
        object fieldN ,
        object fieldO ,
        object fieldP ,
        MyEnumA fieldQ ,
        object fieldR ,
        SmallStruct fieldS ,
        SmallStruct fieldT ,
        SmallStruct fieldU ,
        SmallStruct fieldX 
    ) except *:
        cdef unique_ptr[ccontainerStruct] c_inst
        if base_instance:
            c_inst = make_unique[ccontainerStruct](deref(base_instance))
        else:
            c_inst = make_unique[ccontainerStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and fieldA is None:
                deref(c_inst).fieldA_ref().assign(default_inst[ccontainerStruct]().fieldA_ref().value())
                deref(c_inst).__isset.fieldA = False
                pass

            if not __isNOTSET[1] and fieldB is None:
                deref(c_inst).fieldB_ref().assign(default_inst[ccontainerStruct]().fieldB_ref().value())
                deref(c_inst).__isset.fieldB = False
                pass

            if not __isNOTSET[2] and fieldC is None:
                deref(c_inst).fieldC_ref().assign(default_inst[ccontainerStruct]().fieldC_ref().value())
                deref(c_inst).__isset.fieldC = False
                pass

            if not __isNOTSET[3] and fieldD is None:
                deref(c_inst).fieldD_ref().assign(default_inst[ccontainerStruct]().fieldD_ref().value())
                deref(c_inst).__isset.fieldD = False
                pass

            if not __isNOTSET[4] and fieldE is None:
                deref(c_inst).fieldE_ref().assign(default_inst[ccontainerStruct]().fieldE_ref().value())
                deref(c_inst).__isset.fieldE = False
                pass

            if not __isNOTSET[5] and fieldF is None:
                deref(c_inst).fieldF_ref().assign(default_inst[ccontainerStruct]().fieldF_ref().value())
                deref(c_inst).__isset.fieldF = False
                pass

            if not __isNOTSET[6] and fieldG is None:
                deref(c_inst).fieldG_ref().assign(default_inst[ccontainerStruct]().fieldG_ref().value())
                deref(c_inst).__isset.fieldG = False
                pass

            if not __isNOTSET[7] and fieldH is None:
                deref(c_inst).fieldH_ref().assign(default_inst[ccontainerStruct]().fieldH_ref().value())
                deref(c_inst).__isset.fieldH = False
                pass

            if not __isNOTSET[8] and fieldI is None:
                deref(c_inst).fieldI_ref().assign(default_inst[ccontainerStruct]().fieldI_ref().value())
                deref(c_inst).__isset.fieldI = False
                pass

            if not __isNOTSET[9] and fieldJ is None:
                deref(c_inst).fieldJ_ref().assign(default_inst[ccontainerStruct]().fieldJ_ref().value())
                deref(c_inst).__isset.fieldJ = False
                pass

            if not __isNOTSET[10] and fieldK is None:
                deref(c_inst).fieldK_ref().assign(default_inst[ccontainerStruct]().fieldK_ref().value())
                deref(c_inst).__isset.fieldK = False
                pass

            if not __isNOTSET[11] and fieldL is None:
                deref(c_inst).fieldL_ref().assign(default_inst[ccontainerStruct]().fieldL_ref().value())
                deref(c_inst).__isset.fieldL = False
                pass

            if not __isNOTSET[12] and fieldM is None:
                deref(c_inst).fieldM_ref().assign(default_inst[ccontainerStruct]().fieldM_ref().value())
                deref(c_inst).__isset.fieldM = False
                pass

            if not __isNOTSET[13] and fieldN is None:
                deref(c_inst).fieldN_ref().assign(default_inst[ccontainerStruct]().fieldN_ref().value())
                deref(c_inst).__isset.fieldN = False
                pass

            if not __isNOTSET[14] and fieldO is None:
                deref(c_inst).fieldO_ref().assign(default_inst[ccontainerStruct]().fieldO_ref().value())
                deref(c_inst).__isset.fieldO = False
                pass

            if not __isNOTSET[15] and fieldP is None:
                deref(c_inst).fieldP_ref().assign(default_inst[ccontainerStruct]().fieldP_ref().value())
                deref(c_inst).__isset.fieldP = False
                pass

            if not __isNOTSET[16] and fieldQ is None:
                deref(c_inst).fieldQ_ref().assign(default_inst[ccontainerStruct]().fieldQ_ref().value())
                deref(c_inst).__isset.fieldQ = False
                pass

            if not __isNOTSET[17] and fieldR is None:
                deref(c_inst).fieldR.reset()
                pass

            if not __isNOTSET[18] and fieldS is None:
                deref(c_inst).fieldS.reset()
                pass

            if not __isNOTSET[19] and fieldT is None:
                deref(c_inst).fieldT.reset()
                pass

            if not __isNOTSET[20] and fieldU is None:
                deref(c_inst).fieldU.reset()
                pass

            if not __isNOTSET[21] and fieldX is None:
                deref(c_inst).fieldX.reset()
                pass

        if fieldA is not None:
            deref(c_inst).fieldA_ref().assign(fieldA)
            deref(c_inst).__isset.fieldA = True
        if fieldB is not None:
            deref(c_inst).fieldB_ref().assign(deref(Map__string_bool(fieldB)._cpp_obj))
            deref(c_inst).__isset.fieldB = True
        if fieldC is not None:
            deref(c_inst).fieldC_ref().assign(deref(Set__i32(fieldC)._cpp_obj))
            deref(c_inst).__isset.fieldC = True
        if fieldD is not None:
            deref(c_inst).fieldD_ref().assign(thrift.py3.types.move(thrift.py3.types.bytes_to_string(fieldD.encode('utf-8'))))
            deref(c_inst).__isset.fieldD = True
        if fieldE is not None:
            deref(c_inst).fieldE_ref().assign(thrift.py3.types.move(thrift.py3.types.bytes_to_string(fieldE.encode('utf-8'))))
            deref(c_inst).__isset.fieldE = True
        if fieldF is not None:
            deref(c_inst).fieldF_ref().assign(deref(List__List__List__i32(fieldF)._cpp_obj))
            deref(c_inst).__isset.fieldF = True
        if fieldG is not None:
            deref(c_inst).fieldG_ref().assign(deref(Map__string_Map__string_Map__string_i32(fieldG)._cpp_obj))
            deref(c_inst).__isset.fieldG = True
        if fieldH is not None:
            deref(c_inst).fieldH_ref().assign(deref(List__Set__i32(fieldH)._cpp_obj))
            deref(c_inst).__isset.fieldH = True
        if fieldI is not None:
            deref(c_inst).fieldI_ref().assign(fieldI)
            deref(c_inst).__isset.fieldI = True
        if fieldJ is not None:
            deref(c_inst).fieldJ_ref().assign(deref(Map__string_List__i32(fieldJ)._cpp_obj))
            deref(c_inst).__isset.fieldJ = True
        if fieldK is not None:
            deref(c_inst).fieldK_ref().assign(deref(List__List__List__List__i32(fieldK)._cpp_obj))
            deref(c_inst).__isset.fieldK = True
        if fieldL is not None:
            deref(c_inst).fieldL_ref().assign(deref(Set__Set__Set__bool(fieldL)._cpp_obj))
            deref(c_inst).__isset.fieldL = True
        if fieldM is not None:
            deref(c_inst).fieldM_ref().assign(deref(Map__Set__List__i32_Map__List__Set__string_string(fieldM)._cpp_obj))
            deref(c_inst).__isset.fieldM = True
        if fieldN is not None:
            deref(c_inst).fieldN_ref().assign(deref(List__Foo__i64(fieldN)._cpp_obj))
            deref(c_inst).__isset.fieldN = True
        if fieldO is not None:
            deref(c_inst).fieldO_ref().assign(deref(List__Bar__double(fieldO)._cpp_obj))
            deref(c_inst).__isset.fieldO = True
        if fieldP is not None:
            deref(c_inst).fieldP_ref().assign(deref(List__Baz__i32(fieldP)._cpp_obj))
            deref(c_inst).__isset.fieldP = True
        if fieldQ is not None:
            deref(c_inst).fieldQ_ref().assign(<cMyEnumA><int>fieldQ)
            deref(c_inst).__isset.fieldQ = True
        if fieldR is not None:
            deref(c_inst).fieldR = make_unique[cmap[string,cbool]](deref(Map__string_bool(fieldR)._cpp_obj))
        if fieldS is not None:
            deref(c_inst).fieldS = make_unique[cSmallStruct](deref((<SmallStruct?>fieldS)._cpp_obj))
        if fieldT is not None:
            deref(c_inst).fieldT = (<SmallStruct?>fieldT)._cpp_obj
        if fieldU is not None:
            deref(c_inst).fieldU = const_pointer_cast((<SmallStruct?>fieldU)._cpp_obj)
        if fieldX is not None:
            deref(c_inst).fieldX = make_unique[cSmallStruct](deref((<SmallStruct?>fieldX)._cpp_obj))
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return __fbthrift_move_unique(c_inst)

    cdef object __fbthrift_isset(self):
        cpp_obj = deref(self._cpp_obj)
        return thrift.py3.types._IsSet("containerStruct", {
          "fieldA": cpp_obj.fieldA_ref().has_value(),
          "fieldB": cpp_obj.fieldB_ref().has_value(),
          "fieldC": cpp_obj.fieldC_ref().has_value(),
          "fieldD": cpp_obj.fieldD_ref().has_value(),
          "fieldE": cpp_obj.fieldE_ref().has_value(),
          "fieldF": cpp_obj.fieldF_ref().has_value(),
          "fieldG": cpp_obj.fieldG_ref().has_value(),
          "fieldH": cpp_obj.fieldH_ref().has_value(),
          "fieldI": cpp_obj.fieldI_ref().has_value(),
          "fieldJ": cpp_obj.fieldJ_ref().has_value(),
          "fieldK": cpp_obj.fieldK_ref().has_value(),
          "fieldL": cpp_obj.fieldL_ref().has_value(),
          "fieldM": cpp_obj.fieldM_ref().has_value(),
          "fieldN": cpp_obj.fieldN_ref().has_value(),
          "fieldO": cpp_obj.fieldO_ref().has_value(),
          "fieldP": cpp_obj.fieldP_ref().has_value(),
          "fieldQ": cpp_obj.fieldQ_ref().has_value(),
        })

    def __iter__(self):
        yield 'fieldA', self.fieldA
        yield 'fieldB', self.fieldB
        yield 'fieldC', self.fieldC
        yield 'fieldD', self.fieldD
        yield 'fieldE', self.fieldE
        yield 'fieldF', self.fieldF
        yield 'fieldG', self.fieldG
        yield 'fieldH', self.fieldH
        yield 'fieldI', self.fieldI
        yield 'fieldJ', self.fieldJ
        yield 'fieldK', self.fieldK
        yield 'fieldL', self.fieldL
        yield 'fieldM', self.fieldM
        yield 'fieldN', self.fieldN
        yield 'fieldO', self.fieldO
        yield 'fieldP', self.fieldP
        yield 'fieldQ', self.fieldQ
        yield 'fieldR', self.fieldR
        yield 'fieldS', self.fieldS
        yield 'fieldT', self.fieldT
        yield 'fieldU', self.fieldU
        yield 'fieldX', self.fieldX

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[ccontainerStruct] cpp_obj):
        __fbthrift_inst = <containerStruct>containerStruct.__new__(containerStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(cpp_obj)
        return __fbthrift_inst

    @property
    def fieldA(self):

        return <pbool> deref(self._cpp_obj).fieldA_ref().value()

    @property
    def fieldB(self):

        if self.__field_fieldB is None:
            self.__field_fieldB = Map__string_bool.create(reference_shared_ptr_fieldB(self._cpp_obj, deref(self._cpp_obj).fieldB_ref().value()))
        return self.__field_fieldB

    @property
    def fieldC(self):

        if self.__field_fieldC is None:
            self.__field_fieldC = Set__i32.create(reference_shared_ptr_fieldC(self._cpp_obj, deref(self._cpp_obj).fieldC_ref().value()))
        return self.__field_fieldC

    @property
    def fieldD(self):

        return (<bytes>deref(self._cpp_obj).fieldD_ref().value()).decode('UTF-8')

    @property
    def fieldE(self):

        return (<bytes>deref(self._cpp_obj).fieldE_ref().value()).decode('UTF-8')

    @property
    def fieldF(self):

        if self.__field_fieldF is None:
            self.__field_fieldF = List__List__List__i32.create(reference_shared_ptr_fieldF(self._cpp_obj, deref(self._cpp_obj).fieldF_ref().value()))
        return self.__field_fieldF

    @property
    def fieldG(self):

        if self.__field_fieldG is None:
            self.__field_fieldG = Map__string_Map__string_Map__string_i32.create(reference_shared_ptr_fieldG(self._cpp_obj, deref(self._cpp_obj).fieldG_ref().value()))
        return self.__field_fieldG

    @property
    def fieldH(self):

        if self.__field_fieldH is None:
            self.__field_fieldH = List__Set__i32.create(reference_shared_ptr_fieldH(self._cpp_obj, deref(self._cpp_obj).fieldH_ref().value()))
        return self.__field_fieldH

    @property
    def fieldI(self):

        return <pbool> deref(self._cpp_obj).fieldI_ref().value()

    @property
    def fieldJ(self):

        if self.__field_fieldJ is None:
            self.__field_fieldJ = Map__string_List__i32.create(reference_shared_ptr_fieldJ(self._cpp_obj, deref(self._cpp_obj).fieldJ_ref().value()))
        return self.__field_fieldJ

    @property
    def fieldK(self):

        if self.__field_fieldK is None:
            self.__field_fieldK = List__List__List__List__i32.create(reference_shared_ptr_fieldK(self._cpp_obj, deref(self._cpp_obj).fieldK_ref().value()))
        return self.__field_fieldK

    @property
    def fieldL(self):

        if self.__field_fieldL is None:
            self.__field_fieldL = Set__Set__Set__bool.create(reference_shared_ptr_fieldL(self._cpp_obj, deref(self._cpp_obj).fieldL_ref().value()))
        return self.__field_fieldL

    @property
    def fieldM(self):

        if self.__field_fieldM is None:
            self.__field_fieldM = Map__Set__List__i32_Map__List__Set__string_string.create(reference_shared_ptr_fieldM(self._cpp_obj, deref(self._cpp_obj).fieldM_ref().value()))
        return self.__field_fieldM

    @property
    def fieldN(self):

        if self.__field_fieldN is None:
            self.__field_fieldN = List__Foo__i64.create(reference_shared_ptr_fieldN(self._cpp_obj, deref(self._cpp_obj).fieldN_ref().value()))
        return self.__field_fieldN

    @property
    def fieldO(self):

        if self.__field_fieldO is None:
            self.__field_fieldO = List__Bar__double.create(reference_shared_ptr_fieldO(self._cpp_obj, deref(self._cpp_obj).fieldO_ref().value()))
        return self.__field_fieldO

    @property
    def fieldP(self):

        if self.__field_fieldP is None:
            self.__field_fieldP = List__Baz__i32.create(reference_shared_ptr_fieldP(self._cpp_obj, deref(self._cpp_obj).fieldP_ref().value()))
        return self.__field_fieldP

    @property
    def fieldQ(self):

        return translate_cpp_enum_to_python(MyEnumA, <int>(deref(self._cpp_obj).fieldQ_ref().value()))

    @property
    def fieldR(self):

        if self.__field_fieldR is None:
            if not deref(self._cpp_obj).fieldR:
                return None
            self.__field_fieldR = Map__string_bool.create(reference_shared_ptr_fieldR(self._cpp_obj, deref(deref(self._cpp_obj).fieldR)))
        return self.__field_fieldR

    @property
    def fieldS(self):

        if self.__field_fieldS is None:
            if not deref(self._cpp_obj).fieldS:
                return None
            self.__field_fieldS = SmallStruct.create(reference_shared_ptr_fieldS(self._cpp_obj, deref(deref(self._cpp_obj).fieldS)))
        return self.__field_fieldS

    @property
    def fieldT(self):

        if self.__field_fieldT is None:
            if not deref(self._cpp_obj).fieldT:
                return None
            self.__field_fieldT = SmallStruct.create(reference_shared_ptr_fieldT(self._cpp_obj, deref(deref(self._cpp_obj).fieldT)))
        return self.__field_fieldT

    @property
    def fieldU(self):

        if self.__field_fieldU is None:
            if not deref(self._cpp_obj).fieldU:
                return None
            self.__field_fieldU = SmallStruct.create(reference_shared_ptr_fieldU(self._cpp_obj, deref(deref(self._cpp_obj).fieldU)))
        return self.__field_fieldU

    @property
    def fieldX(self):

        if self.__field_fieldX is None:
            if not deref(self._cpp_obj).fieldX:
                return None
            self.__field_fieldX = SmallStruct.create(reference_shared_ptr_fieldX(self._cpp_obj, deref(deref(self._cpp_obj).fieldX)))
        return self.__field_fieldX


    def __hash__(containerStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.fieldA,
            self.fieldB,
            self.fieldC,
            self.fieldD,
            self.fieldE,
            self.fieldF,
            self.fieldG,
            self.fieldH,
            self.fieldI,
            self.fieldJ,
            self.fieldK,
            self.fieldL,
            self.fieldM,
            self.fieldN,
            self.fieldO,
            self.fieldP,
            self.fieldQ,
            self.fieldR,
            self.fieldS,
            self.fieldT,
            self.fieldU,
            self.fieldX,
            ))
        return self.__hash

    def __repr__(containerStruct self):
        return f'containerStruct(fieldA={repr(self.fieldA)}, fieldB={repr(self.fieldB)}, fieldC={repr(self.fieldC)}, fieldD={repr(self.fieldD)}, fieldE={repr(self.fieldE)}, fieldF={repr(self.fieldF)}, fieldG={repr(self.fieldG)}, fieldH={repr(self.fieldH)}, fieldI={repr(self.fieldI)}, fieldJ={repr(self.fieldJ)}, fieldK={repr(self.fieldK)}, fieldL={repr(self.fieldL)}, fieldM={repr(self.fieldM)}, fieldN={repr(self.fieldN)}, fieldO={repr(self.fieldO)}, fieldP={repr(self.fieldP)}, fieldQ={repr(self.fieldQ)}, fieldR={repr(self.fieldR)}, fieldS={repr(self.fieldS)}, fieldT={repr(self.fieldT)}, fieldU={repr(self.fieldU)}, fieldX={repr(self.fieldX)})'
    def __copy__(containerStruct self):
        cdef shared_ptr[ccontainerStruct] cpp_obj = make_shared[ccontainerStruct](
            deref(self._cpp_obj)
        )
        return containerStruct.create(__fbthrift_move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, containerStruct) and
                isinstance(other, containerStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef ccontainerStruct* cself = (<containerStruct>self)._cpp_obj.get()
        cdef ccontainerStruct* cother = (<containerStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__containerStruct()

    cdef __iobuf.IOBuf _serialize(containerStruct self, __Protocol proto):
        return __iobuf.from_unique_ptr(
            serializer.cserialize[ccontainerStruct](self._cpp_obj.get(), proto).move()
        )

    cdef cuint32_t _deserialize(containerStruct self, const __iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[ccontainerStruct]()
        needed = serializer.cdeserialize[ccontainerStruct](buf, self._cpp_obj.get(), proto)
        return needed

    def __reduce__(self):
        return (deserialize, (containerStruct, serialize(self)))


@__cython.auto_pickle(False)
cdef class Map__string_bool(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_bool):
            self._cpp_obj = (<Map__string_bool> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_bool._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cbool]] c_items):
        __fbthrift_inst = <Map__string_bool>Map__string_bool.__new__(Map__string_bool)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_bool self):
        cdef shared_ptr[cmap[string,cbool]] cpp_obj = make_shared[cmap[string,cbool]](
            deref(self._cpp_obj)
        )
        return Map__string_bool.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cbool]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cbool]] c_inst = make_shared[cmap[string,cbool]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, bool):
                    raise TypeError(f"{item!r} is not of type bool")

                deref(c_inst)[key.encode('UTF-8')] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cbool].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef cbool citem = deref(iter).second
        return citem

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,cbool].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef cbool citem
        cdef cmap[string,cbool].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef cbool citem
        cdef cmap[string,cbool].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey.data().decode('UTF-8'), citem)
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_bool()


Mapping.register(Map__string_bool)

@__cython.auto_pickle(False)
cdef class Set__i32(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cint32_t]] c_items):
        __fbthrift_inst = <Set__i32>Set__i32.__new__(Set__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Set__i32 self):
        cdef shared_ptr[cset[cint32_t]] cpp_obj = make_shared[cset[cint32_t]](
            deref(self._cpp_obj)
        )
        return Set__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cint32_t]] c_inst = make_shared[cset[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cset[cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[cint32_t]] cself, cother
        cdef cset[cint32_t].iterator loc
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = (<Set__i32> self)._cpp_obj
            cother = (<Set__i32> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(__fbthrift_move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(__fbthrift_move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(__fbthrift_move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(__fbthrift_move_shared(shretval))


    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__i32()


Set.register(Set__i32)

@__cython.auto_pickle(False)
cdef class List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cint32_t]] c_items):
        __fbthrift_inst = <List__i32>List__i32.__new__(List__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__i32 self):
        cdef shared_ptr[vector[cint32_t]] cpp_obj = make_shared[vector[cint32_t]](
            deref(self._cpp_obj)
        )
        return List__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint32_t]] c_inst = make_shared[vector[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cint32_t]] c_inst
        cdef cint32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cint32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[cint32_t].iterator, cint32_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef vector[cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef vector[cint32_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[cint32_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cint32_t].iterator loc = std_libcpp.find[vector[cint32_t].iterator, cint32_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <cint64_t> std_libcpp.count[vector[cint32_t].iterator, cint32_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__i32()


Sequence.register(List__i32)

@__cython.auto_pickle(False)
cdef class List__List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__List__i32):
            self._cpp_obj = (<List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[cint32_t]]] c_items):
        __fbthrift_inst = <List__List__i32>List__List__i32.__new__(List__List__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__List__i32 self):
        cdef shared_ptr[vector[vector[cint32_t]]] cpp_obj = make_shared[vector[vector[cint32_t]]](
            deref(self._cpp_obj)
        )
        return List__List__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[vector[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[cint32_t]]] c_inst = make_shared[vector[vector[cint32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)
                deref(c_inst).push_back(deref((<List__i32>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[cint32_t]]] c_inst
        cdef shared_ptr[vector[cint32_t]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[cint32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__List__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__List__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return List__i32.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__i32):
            return False
        return std_libcpp.find[vector[vector[cint32_t]].iterator, vector[cint32_t]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[vector[cint32_t]] citem
        cdef vector[vector[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__List__i32(self._cpp_obj, deref(loc))
            yield List__i32.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[vector[cint32_t]] citem
        cdef vector[vector[cint32_t]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__List__i32(self._cpp_obj, deref(loc))
            yield List__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__i32):
            raise err
        cdef vector[vector[cint32_t]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[vector[cint32_t]].iterator loc = std_libcpp.find[vector[vector[cint32_t]].iterator, vector[cint32_t]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<List__i32>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return 0
        if not isinstance(item, List__i32):
            return 0
        return <cint64_t> std_libcpp.count[vector[vector[cint32_t]].iterator, vector[cint32_t]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__i32>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__List__i32()


Sequence.register(List__List__i32)

@__cython.auto_pickle(False)
cdef class List__List__List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__List__List__i32):
            self._cpp_obj = (<List__List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__List__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[vector[cint32_t]]]] c_items):
        __fbthrift_inst = <List__List__List__i32>List__List__List__i32.__new__(List__List__List__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__List__List__i32 self):
        cdef shared_ptr[vector[vector[vector[cint32_t]]]] cpp_obj = make_shared[vector[vector[vector[cint32_t]]]](
            deref(self._cpp_obj)
        )
        return List__List__List__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[vector[vector[cint32_t]]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[vector[cint32_t]]]] c_inst = make_shared[vector[vector[vector[cint32_t]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[_typing.Sequence[int]]")
                if not isinstance(item, List__List__i32):
                    item = List__List__i32(item)
                deref(c_inst).push_back(deref((<List__List__i32>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[vector[cint32_t]]]] c_inst
        cdef shared_ptr[vector[vector[cint32_t]]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[vector[cint32_t]]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__List__List__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__List__List__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return List__List__i32.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__List__i32):
                item = List__List__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__List__i32):
            return False
        return std_libcpp.find[vector[vector[vector[cint32_t]]].iterator, vector[vector[cint32_t]]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__List__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[vector[vector[cint32_t]]] citem
        cdef vector[vector[vector[cint32_t]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__List__List__i32(self._cpp_obj, deref(loc))
            yield List__List__i32.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[vector[vector[cint32_t]]] citem
        cdef vector[vector[vector[cint32_t]]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__List__List__i32(self._cpp_obj, deref(loc))
            yield List__List__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__List__i32):
                item = List__List__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__List__i32):
            raise err
        cdef vector[vector[vector[cint32_t]]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[vector[vector[cint32_t]]].iterator loc = std_libcpp.find[vector[vector[vector[cint32_t]]].iterator, vector[vector[cint32_t]]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<List__List__i32>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__List__i32):
                item = List__List__i32(item)
        except Exception:
            return 0
        if not isinstance(item, List__List__i32):
            return 0
        return <cint64_t> std_libcpp.count[vector[vector[vector[cint32_t]]].iterator, vector[vector[cint32_t]]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__List__i32>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__List__List__i32()


Sequence.register(List__List__List__i32)

@__cython.auto_pickle(False)
cdef class Map__string_i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._cpp_obj = (<Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cint32_t]] c_items):
        __fbthrift_inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_i32 self):
        cdef shared_ptr[cmap[string,cint32_t]] cpp_obj = make_shared[cmap[string,cint32_t]](
            deref(self._cpp_obj)
        )
        return Map__string_i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cint32_t]] c_inst = make_shared[cmap[string,cint32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item

                deref(c_inst)[key.encode('UTF-8')] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cint32_t].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef cint32_t citem = deref(iter).second
        return citem

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cmap[string,cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef cint32_t citem
        cdef cmap[string,cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey.data().decode('UTF-8'), citem)
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_i32()


Mapping.register(Map__string_i32)

@__cython.auto_pickle(False)
cdef class Map__string_Map__string_i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_i32):
            self._cpp_obj = (<Map__string_Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,cint32_t]]] c_items):
        __fbthrift_inst = <Map__string_Map__string_i32>Map__string_Map__string_i32.__new__(Map__string_Map__string_i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_Map__string_i32 self):
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] cpp_obj = make_shared[cmap[string,cmap[string,cint32_t]]](
            deref(self._cpp_obj)
        )
        return Map__string_Map__string_i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] c_inst = make_shared[cmap[string,cmap[string,cint32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[str, int]")
                if not isinstance(item, Map__string_i32):
                    item = Map__string_i32(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<Map__string_i32>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cmap[string,cint32_t]].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cmap[string,cint32_t]] citem = reference_shared_ptr_Map__string_Map__string_i32(self._cpp_obj, deref(iter).second)
        return Map__string_i32.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,cmap[string,cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef shared_ptr[cmap[string,cint32_t]] citem
        cdef cmap[string,cmap[string,cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__string_Map__string_i32(self._cpp_obj, deref(loc).second)
            yield Map__string_i32.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef shared_ptr[cmap[string,cint32_t]] citem
        cdef cmap[string,cmap[string,cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__string_Map__string_i32(self._cpp_obj, deref(loc).second)
            yield (ckey.data().decode('UTF-8'), Map__string_i32.create(citem))
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_Map__string_i32()


Mapping.register(Map__string_Map__string_i32)

@__cython.auto_pickle(False)
cdef class Map__string_Map__string_Map__string_i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_Map__string_i32):
            self._cpp_obj = (<Map__string_Map__string_Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_Map__string_Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,cmap[string,cint32_t]]]] c_items):
        __fbthrift_inst = <Map__string_Map__string_Map__string_i32>Map__string_Map__string_Map__string_i32.__new__(Map__string_Map__string_Map__string_i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_Map__string_Map__string_i32 self):
        cdef shared_ptr[cmap[string,cmap[string,cmap[string,cint32_t]]]] cpp_obj = make_shared[cmap[string,cmap[string,cmap[string,cint32_t]]]](
            deref(self._cpp_obj)
        )
        return Map__string_Map__string_Map__string_i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cmap[string,cmap[string,cint32_t]]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cmap[string,cmap[string,cint32_t]]]] c_inst = make_shared[cmap[string,cmap[string,cmap[string,cint32_t]]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[str, _typing.Mapping[str, int]]")
                if not isinstance(item, Map__string_Map__string_i32):
                    item = Map__string_Map__string_i32(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<Map__string_Map__string_i32>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cmap[string,cmap[string,cint32_t]]].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] citem = reference_shared_ptr_Map__string_Map__string_Map__string_i32(self._cpp_obj, deref(iter).second)
        return Map__string_Map__string_i32.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,cmap[string,cmap[string,cint32_t]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] citem
        cdef cmap[string,cmap[string,cmap[string,cint32_t]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__string_Map__string_Map__string_i32(self._cpp_obj, deref(loc).second)
            yield Map__string_Map__string_i32.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] citem
        cdef cmap[string,cmap[string,cmap[string,cint32_t]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__string_Map__string_Map__string_i32(self._cpp_obj, deref(loc).second)
            yield (ckey.data().decode('UTF-8'), Map__string_Map__string_i32.create(citem))
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_Map__string_Map__string_i32()


Mapping.register(Map__string_Map__string_Map__string_i32)

@__cython.auto_pickle(False)
cdef class List__Set__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Set__i32):
            self._cpp_obj = (<List__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cset[cint32_t]]] c_items):
        __fbthrift_inst = <List__Set__i32>List__Set__i32.__new__(List__Set__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__Set__i32 self):
        cdef shared_ptr[vector[cset[cint32_t]]] cpp_obj = make_shared[vector[cset[cint32_t]]](
            deref(self._cpp_obj)
        )
        return List__Set__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cset[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cset[cint32_t]]] c_inst = make_shared[vector[cset[cint32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[int]")
                if not isinstance(item, Set__i32):
                    item = Set__i32(item)
                deref(c_inst).push_back(deref((<Set__i32>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[cint32_t]]] c_inst
        cdef shared_ptr[cset[cint32_t]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[cint32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Set__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return Set__i32.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return False
        if not isinstance(item, Set__i32):
            return False
        return std_libcpp.find[vector[cset[cint32_t]].iterator, cset[cint32_t]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cset[cint32_t]] citem
        cdef vector[cset[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(loc))
            yield Set__i32.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cset[cint32_t]] citem
        cdef vector[cset[cint32_t]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(loc))
            yield Set__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Set__i32):
            raise err
        cdef vector[cset[cint32_t]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cset[cint32_t]].iterator loc = std_libcpp.find[vector[cset[cint32_t]].iterator, cset[cint32_t]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Set__i32>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return 0
        if not isinstance(item, Set__i32):
            return 0
        return <cint64_t> std_libcpp.count[vector[cset[cint32_t]].iterator, cset[cint32_t]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__i32>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Set__i32()


Sequence.register(List__Set__i32)

@__cython.auto_pickle(False)
cdef class Map__string_List__i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_List__i32):
            self._cpp_obj = (<Map__string_List__i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,vector[cint32_t]]] c_items):
        __fbthrift_inst = <Map__string_List__i32>Map__string_List__i32.__new__(Map__string_List__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_List__i32 self):
        cdef shared_ptr[cmap[string,vector[cint32_t]]] cpp_obj = make_shared[cmap[string,vector[cint32_t]]](
            deref(self._cpp_obj)
        )
        return Map__string_List__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,vector[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,vector[cint32_t]]] c_inst = make_shared[cmap[string,vector[cint32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<List__i32>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,vector[cint32_t]].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[vector[cint32_t]] citem = reference_shared_ptr_Map__string_List__i32(self._cpp_obj, deref(iter).second)
        return List__i32.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,vector[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef shared_ptr[vector[cint32_t]] citem
        cdef cmap[string,vector[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__string_List__i32(self._cpp_obj, deref(loc).second)
            yield List__i32.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef shared_ptr[vector[cint32_t]] citem
        cdef cmap[string,vector[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__string_List__i32(self._cpp_obj, deref(loc).second)
            yield (ckey.data().decode('UTF-8'), List__i32.create(citem))
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_List__i32()


Mapping.register(Map__string_List__i32)

@__cython.auto_pickle(False)
cdef class List__List__List__List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__List__List__List__i32):
            self._cpp_obj = (<List__List__List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__List__List__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[vector[vector[cint32_t]]]]] c_items):
        __fbthrift_inst = <List__List__List__List__i32>List__List__List__List__i32.__new__(List__List__List__List__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__List__List__List__i32 self):
        cdef shared_ptr[vector[vector[vector[vector[cint32_t]]]]] cpp_obj = make_shared[vector[vector[vector[vector[cint32_t]]]]](
            deref(self._cpp_obj)
        )
        return List__List__List__List__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[vector[vector[vector[cint32_t]]]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[vector[vector[cint32_t]]]]] c_inst = make_shared[vector[vector[vector[vector[cint32_t]]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]")
                if not isinstance(item, List__List__List__i32):
                    item = List__List__List__i32(item)
                deref(c_inst).push_back(deref((<List__List__List__i32>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[vector[vector[cint32_t]]]]] c_inst
        cdef shared_ptr[vector[vector[vector[cint32_t]]]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[vector[vector[cint32_t]]]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__List__List__List__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__List__List__List__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return List__List__List__i32.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__List__List__i32):
                item = List__List__List__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__List__List__i32):
            return False
        return std_libcpp.find[vector[vector[vector[vector[cint32_t]]]].iterator, vector[vector[vector[cint32_t]]]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__List__List__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[vector[vector[vector[cint32_t]]]] citem
        cdef vector[vector[vector[vector[cint32_t]]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__List__List__List__i32(self._cpp_obj, deref(loc))
            yield List__List__List__i32.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[vector[vector[vector[cint32_t]]]] citem
        cdef vector[vector[vector[vector[cint32_t]]]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__List__List__List__i32(self._cpp_obj, deref(loc))
            yield List__List__List__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__List__List__i32):
                item = List__List__List__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__List__List__i32):
            raise err
        cdef vector[vector[vector[vector[cint32_t]]]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[vector[vector[vector[cint32_t]]]].iterator loc = std_libcpp.find[vector[vector[vector[vector[cint32_t]]]].iterator, vector[vector[vector[cint32_t]]]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<List__List__List__i32>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__List__List__i32):
                item = List__List__List__i32(item)
        except Exception:
            return 0
        if not isinstance(item, List__List__List__i32):
            return 0
        return <cint64_t> std_libcpp.count[vector[vector[vector[vector[cint32_t]]]].iterator, vector[vector[vector[cint32_t]]]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__List__List__i32>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__List__List__List__i32()


Sequence.register(List__List__List__List__i32)

@__cython.auto_pickle(False)
cdef class Set__bool(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__bool):
            self._cpp_obj = (<Set__bool> items)._cpp_obj
        else:
            self._cpp_obj = Set__bool._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cbool]] c_items):
        __fbthrift_inst = <Set__bool>Set__bool.__new__(Set__bool)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Set__bool self):
        cdef shared_ptr[cset[cbool]] cpp_obj = make_shared[cset[cbool]](
            deref(self._cpp_obj)
        )
        return Set__bool.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[cbool]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cbool]] c_inst = make_shared[cset[cbool]]()
        if items is not None:
            for item in items:
                if not isinstance(item, bool):
                    raise TypeError(f"{item!r} is not of type bool")
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, bool):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __iter__(self):
        if not self:
            return
        cdef cbool citem
        cdef cset[cbool].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[cbool]] cself, cother
        cdef cset[cbool].iterator loc
        if (isinstance(self, Set__bool) and
                isinstance(other, Set__bool)):
            cself = (<Set__bool> self)._cpp_obj
            cother = (<Set__bool> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __and__(self, other):
        if not isinstance(self, Set__bool):
            self = Set__bool(self)
        if not isinstance(other, Set__bool):
            other = Set__bool(other)

        cdef shared_ptr[cset[cbool]] shretval = \
            make_shared[cset[cbool]]()

        cdef shared_ptr[cset[cbool]] cself = (<Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cbool]] cother = (<Set__bool> other)._cpp_obj

        cdef cset[cbool].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__bool.create(__fbthrift_move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__bool):
            self = Set__bool(self)
        if not isinstance(other, Set__bool):
            other = Set__bool(other)

        cdef shared_ptr[cset[cbool]] shretval = \
            make_shared[cset[cbool]]()

        cdef shared_ptr[cset[cbool]] cself = (<Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cbool]] cother = (<Set__bool> other)._cpp_obj

        cdef cset[cbool].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__bool.create(__fbthrift_move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__bool):
            self = Set__bool(self)
        if not isinstance(other, Set__bool):
            other = Set__bool(other)

        cdef shared_ptr[cset[cbool]] shretval = \
            make_shared[cset[cbool]]()

        cdef shared_ptr[cset[cbool]] cself = (<Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cbool]] cother = (<Set__bool> other)._cpp_obj

        cdef cset[cbool].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__bool.create(__fbthrift_move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__bool):
            self = Set__bool(self)
        if not isinstance(other, Set__bool):
            other = Set__bool(other)

        cdef shared_ptr[cset[cbool]] shretval = \
            make_shared[cset[cbool]]()

        cdef shared_ptr[cset[cbool]] cself = (<Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cbool]] cother = (<Set__bool> other)._cpp_obj

        cdef cset[cbool].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__bool.create(__fbthrift_move_shared(shretval))


    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__bool()


Set.register(Set__bool)

@__cython.auto_pickle(False)
cdef class Set__Set__bool(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__Set__bool):
            self._cpp_obj = (<Set__Set__bool> items)._cpp_obj
        else:
            self._cpp_obj = Set__Set__bool._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cset[cbool]]] c_items):
        __fbthrift_inst = <Set__Set__bool>Set__Set__bool.__new__(Set__Set__bool)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Set__Set__bool self):
        cdef shared_ptr[cset[cset[cbool]]] cpp_obj = make_shared[cset[cset[cbool]]](
            deref(self._cpp_obj)
        )
        return Set__Set__bool.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[cset[cbool]]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cset[cbool]]] c_inst = make_shared[cset[cset[cbool]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.AbstractSet[bool]")
                if not isinstance(item, Set__bool):
                    item = Set__bool(item)
                deref(c_inst).insert(deref((<Set__bool>item)._cpp_obj))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__bool):
                item = Set__bool(item)
        except Exception:
            return False
        if not isinstance(item, Set__bool):
            return False
        return pbool(deref(self._cpp_obj).count(deref((<Set__bool>item)._cpp_obj)))


    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cset[cbool]] citem
        cdef cset[cset[cbool]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Set__Set__bool(self._cpp_obj, deref(loc))
            yield Set__bool.create(citem)
            inc(loc)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[cset[cbool]]] cself, cother
        cdef cset[cset[cbool]].iterator loc
        if (isinstance(self, Set__Set__bool) and
                isinstance(other, Set__Set__bool)):
            cself = (<Set__Set__bool> self)._cpp_obj
            cother = (<Set__Set__bool> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __and__(self, other):
        if not isinstance(self, Set__Set__bool):
            self = Set__Set__bool(self)
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cbool]]] shretval = \
            make_shared[cset[cset[cbool]]]()

        cdef shared_ptr[cset[cset[cbool]]] cself = (<Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cbool]]] cother = (<Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cbool]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__bool.create(__fbthrift_move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__Set__bool):
            self = Set__Set__bool(self)
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cbool]]] shretval = \
            make_shared[cset[cset[cbool]]]()

        cdef shared_ptr[cset[cset[cbool]]] cself = (<Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cbool]]] cother = (<Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cbool]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__bool.create(__fbthrift_move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__Set__bool):
            self = Set__Set__bool(self)
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cbool]]] shretval = \
            make_shared[cset[cset[cbool]]]()

        cdef shared_ptr[cset[cset[cbool]]] cself = (<Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cbool]]] cother = (<Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cbool]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__bool.create(__fbthrift_move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__Set__bool):
            self = Set__Set__bool(self)
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cbool]]] shretval = \
            make_shared[cset[cset[cbool]]]()

        cdef shared_ptr[cset[cset[cbool]]] cself = (<Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cbool]]] cother = (<Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cbool]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__bool.create(__fbthrift_move_shared(shretval))


    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__Set__bool()


Set.register(Set__Set__bool)

@__cython.auto_pickle(False)
cdef class Set__Set__Set__bool(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__Set__Set__bool):
            self._cpp_obj = (<Set__Set__Set__bool> items)._cpp_obj
        else:
            self._cpp_obj = Set__Set__Set__bool._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cset[cset[cbool]]]] c_items):
        __fbthrift_inst = <Set__Set__Set__bool>Set__Set__Set__bool.__new__(Set__Set__Set__bool)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Set__Set__Set__bool self):
        cdef shared_ptr[cset[cset[cset[cbool]]]] cpp_obj = make_shared[cset[cset[cset[cbool]]]](
            deref(self._cpp_obj)
        )
        return Set__Set__Set__bool.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[cset[cset[cbool]]]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cset[cset[cbool]]]] c_inst = make_shared[cset[cset[cset[cbool]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.AbstractSet[_typing.AbstractSet[bool]]")
                if not isinstance(item, Set__Set__bool):
                    item = Set__Set__bool(item)
                deref(c_inst).insert(deref((<Set__Set__bool>item)._cpp_obj))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__Set__bool):
                item = Set__Set__bool(item)
        except Exception:
            return False
        if not isinstance(item, Set__Set__bool):
            return False
        return pbool(deref(self._cpp_obj).count(deref((<Set__Set__bool>item)._cpp_obj)))


    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cset[cset[cbool]]] citem
        cdef cset[cset[cset[cbool]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Set__Set__Set__bool(self._cpp_obj, deref(loc))
            yield Set__Set__bool.create(citem)
            inc(loc)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[cset[cset[cbool]]]] cself, cother
        cdef cset[cset[cset[cbool]]].iterator loc
        if (isinstance(self, Set__Set__Set__bool) and
                isinstance(other, Set__Set__Set__bool)):
            cself = (<Set__Set__Set__bool> self)._cpp_obj
            cother = (<Set__Set__Set__bool> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __and__(self, other):
        if not isinstance(self, Set__Set__Set__bool):
            self = Set__Set__Set__bool(self)
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cset[cbool]]]] shretval = \
            make_shared[cset[cset[cset[cbool]]]]()

        cdef shared_ptr[cset[cset[cset[cbool]]]] cself = (<Set__Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cset[cbool]]]] cother = (<Set__Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cset[cbool]]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__Set__bool.create(__fbthrift_move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__Set__Set__bool):
            self = Set__Set__Set__bool(self)
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cset[cbool]]]] shretval = \
            make_shared[cset[cset[cset[cbool]]]]()

        cdef shared_ptr[cset[cset[cset[cbool]]]] cself = (<Set__Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cset[cbool]]]] cother = (<Set__Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cset[cbool]]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__Set__bool.create(__fbthrift_move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__Set__Set__bool):
            self = Set__Set__Set__bool(self)
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cset[cbool]]]] shretval = \
            make_shared[cset[cset[cset[cbool]]]]()

        cdef shared_ptr[cset[cset[cset[cbool]]]] cself = (<Set__Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cset[cbool]]]] cother = (<Set__Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cset[cbool]]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__Set__bool.create(__fbthrift_move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__Set__Set__bool):
            self = Set__Set__Set__bool(self)
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cset[cbool]]]] shretval = \
            make_shared[cset[cset[cset[cbool]]]]()

        cdef shared_ptr[cset[cset[cset[cbool]]]] cself = (<Set__Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cset[cbool]]]] cother = (<Set__Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cset[cbool]]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__Set__bool.create(__fbthrift_move_shared(shretval))


    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__Set__Set__bool()


Set.register(Set__Set__Set__bool)

@__cython.auto_pickle(False)
cdef class Set__List__i32(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__List__i32):
            self._cpp_obj = (<Set__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = Set__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[vector[cint32_t]]] c_items):
        __fbthrift_inst = <Set__List__i32>Set__List__i32.__new__(Set__List__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Set__List__i32 self):
        cdef shared_ptr[cset[vector[cint32_t]]] cpp_obj = make_shared[cset[vector[cint32_t]]](
            deref(self._cpp_obj)
        )
        return Set__List__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[vector[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cset[vector[cint32_t]]] c_inst = make_shared[cset[vector[cint32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)
                deref(c_inst).insert(deref((<List__i32>item)._cpp_obj))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__i32):
            return False
        return pbool(deref(self._cpp_obj).count(deref((<List__i32>item)._cpp_obj)))


    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[vector[cint32_t]] citem
        cdef cset[vector[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Set__List__i32(self._cpp_obj, deref(loc))
            yield List__i32.create(citem)
            inc(loc)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[vector[cint32_t]]] cself, cother
        cdef cset[vector[cint32_t]].iterator loc
        if (isinstance(self, Set__List__i32) and
                isinstance(other, Set__List__i32)):
            cself = (<Set__List__i32> self)._cpp_obj
            cother = (<Set__List__i32> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __and__(self, other):
        if not isinstance(self, Set__List__i32):
            self = Set__List__i32(self)
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)

        cdef shared_ptr[cset[vector[cint32_t]]] shretval = \
            make_shared[cset[vector[cint32_t]]]()

        cdef shared_ptr[cset[vector[cint32_t]]] cself = (<Set__List__i32> self)._cpp_obj
        cdef shared_ptr[cset[vector[cint32_t]]] cother = (<Set__List__i32> other)._cpp_obj

        cdef cset[vector[cint32_t]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__List__i32.create(__fbthrift_move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__List__i32):
            self = Set__List__i32(self)
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)

        cdef shared_ptr[cset[vector[cint32_t]]] shretval = \
            make_shared[cset[vector[cint32_t]]]()

        cdef shared_ptr[cset[vector[cint32_t]]] cself = (<Set__List__i32> self)._cpp_obj
        cdef shared_ptr[cset[vector[cint32_t]]] cother = (<Set__List__i32> other)._cpp_obj

        cdef cset[vector[cint32_t]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__List__i32.create(__fbthrift_move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__List__i32):
            self = Set__List__i32(self)
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)

        cdef shared_ptr[cset[vector[cint32_t]]] shretval = \
            make_shared[cset[vector[cint32_t]]]()

        cdef shared_ptr[cset[vector[cint32_t]]] cself = (<Set__List__i32> self)._cpp_obj
        cdef shared_ptr[cset[vector[cint32_t]]] cother = (<Set__List__i32> other)._cpp_obj

        cdef cset[vector[cint32_t]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__List__i32.create(__fbthrift_move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__List__i32):
            self = Set__List__i32(self)
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)

        cdef shared_ptr[cset[vector[cint32_t]]] shretval = \
            make_shared[cset[vector[cint32_t]]]()

        cdef shared_ptr[cset[vector[cint32_t]]] cself = (<Set__List__i32> self)._cpp_obj
        cdef shared_ptr[cset[vector[cint32_t]]] cother = (<Set__List__i32> other)._cpp_obj

        cdef cset[vector[cint32_t]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__List__i32.create(__fbthrift_move_shared(shretval))


    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__List__i32()


Set.register(Set__List__i32)

@__cython.auto_pickle(False)
cdef class Set__string(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._cpp_obj = (<Set__string> items)._cpp_obj
        else:
            self._cpp_obj = Set__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        __fbthrift_inst = <Set__string>Set__string.__new__(Set__string)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Set__string self):
        cdef shared_ptr[cset[string]] cpp_obj = make_shared[cset[string]](
            deref(self._cpp_obj)
        )
        return Set__string.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[string]] _make_instance(object items) except *:
        cdef shared_ptr[cset[string]] c_inst = make_shared[cset[string]]()
        if items is not None:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.AbstractSet[str] field, explicitly convert it first.")
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).insert(item.encode('UTF-8'))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        return pbool(deref(self._cpp_obj).count(item.encode('UTF-8')))


    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cset[string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[string]] cself, cother
        cdef cset[string].iterator loc
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = (<Set__string> self)._cpp_obj
            cother = (<Set__string> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(__fbthrift_move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(__fbthrift_move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(__fbthrift_move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(__fbthrift_move_shared(shretval))


    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__string()


Set.register(Set__string)

@__cython.auto_pickle(False)
cdef class List__Set__string(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Set__string):
            self._cpp_obj = (<List__Set__string> items)._cpp_obj
        else:
            self._cpp_obj = List__Set__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cset[string]]] c_items):
        __fbthrift_inst = <List__Set__string>List__Set__string.__new__(List__Set__string)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__Set__string self):
        cdef shared_ptr[vector[cset[string]]] cpp_obj = make_shared[vector[cset[string]]](
            deref(self._cpp_obj)
        )
        return List__Set__string.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cset[string]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cset[string]]] c_inst = make_shared[vector[cset[string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[str]")
                if not isinstance(item, Set__string):
                    item = Set__string(item)
                deref(c_inst).push_back(deref((<Set__string>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[string]]] c_inst
        cdef shared_ptr[cset[string]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[string]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Set__string.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Set__string(self._cpp_obj, deref(self._cpp_obj)[index])
            return Set__string.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            return False
        if not isinstance(item, Set__string):
            return False
        return std_libcpp.find[vector[cset[string]].iterator, cset[string]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__string>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cset[string]] citem
        cdef vector[cset[string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Set__string(self._cpp_obj, deref(loc))
            yield Set__string.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cset[string]] citem
        cdef vector[cset[string]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Set__string(self._cpp_obj, deref(loc))
            yield Set__string.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            raise err from None
        if not isinstance(item, Set__string):
            raise err
        cdef vector[cset[string]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cset[string]].iterator loc = std_libcpp.find[vector[cset[string]].iterator, cset[string]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Set__string>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            return 0
        if not isinstance(item, Set__string):
            return 0
        return <cint64_t> std_libcpp.count[vector[cset[string]].iterator, cset[string]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__string>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Set__string()


Sequence.register(List__Set__string)

@__cython.auto_pickle(False)
cdef class Map__List__Set__string_string(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__List__Set__string_string):
            self._cpp_obj = (<Map__List__Set__string_string> items)._cpp_obj
        else:
            self._cpp_obj = Map__List__Set__string_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[vector[cset[string]],string]] c_items):
        __fbthrift_inst = <Map__List__Set__string_string>Map__List__Set__string_string.__new__(Map__List__Set__string_string)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__List__Set__string_string self):
        cdef shared_ptr[cmap[vector[cset[string]],string]] cpp_obj = make_shared[cmap[vector[cset[string]],string]](
            deref(self._cpp_obj)
        )
        return Map__List__Set__string_string.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[vector[cset[string]],string]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[vector[cset[string]],string]] c_inst = make_shared[cmap[vector[cset[string]],string]]()
        if items is not None:
            for key, item in items.items():
                if key is None:
                    raise TypeError("None is not of type _typing.Sequence[_typing.AbstractSet[str]]")
                if not isinstance(key, List__Set__string):
                    key = List__Set__string(key)
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst)[deref((<List__Set__string>key)._cpp_obj)] = item.encode('UTF-8')
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        try:
            if not isinstance(key, List__Set__string):
                key = List__Set__string(key)
        except Exception:
            raise err from None
        if not isinstance(key, List__Set__string):
            raise err from None
        cdef cmap[vector[cset[string]],string].iterator iter = deref(
            self._cpp_obj).find(deref((<List__Set__string>key)._cpp_obj))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[vector[cset[string]]] citem
        cdef cmap[vector[cset[string]],string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__List__Set__string_string_key(self._cpp_obj, deref(loc).first)
            yield List__Set__string.create(citem)
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        try:
            if not isinstance(key, List__Set__string):
                key = List__Set__string(key)
        except Exception:
            return False
        if not isinstance(key, List__Set__string):
            return False
        cdef vector[cset[string]] ckey = deref((<List__Set__string>key)._cpp_obj)
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, List__Set__string):
                key = List__Set__string(key)
        except Exception:
            return default
        if not isinstance(key, List__Set__string):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef string citem
        cdef cmap[vector[cset[string]],string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def items(self):
        if not self:
            return
        cdef shared_ptr[vector[cset[string]]] ckey
        cdef string citem
        cdef cmap[vector[cset[string]],string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = reference_shared_ptr_Map__List__Set__string_string_key(self._cpp_obj, deref(loc).first)
            citem = deref(loc).second
            yield (List__Set__string.create(ckey), bytes(citem).decode('UTF-8'))
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__List__Set__string_string()


Mapping.register(Map__List__Set__string_string)

@__cython.auto_pickle(False)
cdef class Map__Set__List__i32_Map__List__Set__string_string(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__Set__List__i32_Map__List__Set__string_string):
            self._cpp_obj = (<Map__Set__List__i32_Map__List__Set__string_string> items)._cpp_obj
        else:
            self._cpp_obj = Map__Set__List__i32_Map__List__Set__string_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]] c_items):
        __fbthrift_inst = <Map__Set__List__i32_Map__List__Set__string_string>Map__Set__List__i32_Map__List__Set__string_string.__new__(Map__Set__List__i32_Map__List__Set__string_string)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__Set__List__i32_Map__List__Set__string_string self):
        cdef shared_ptr[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]] cpp_obj = make_shared[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]](
            deref(self._cpp_obj)
        )
        return Map__Set__List__i32_Map__List__Set__string_string.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]] c_inst = make_shared[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]]()
        if items is not None:
            for key, item in items.items():
                if key is None:
                    raise TypeError("None is not of type _typing.AbstractSet[_typing.Sequence[int]]")
                if not isinstance(key, Set__List__i32):
                    key = Set__List__i32(key)
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]")
                if not isinstance(item, Map__List__Set__string_string):
                    item = Map__List__Set__string_string(item)

                deref(c_inst)[deref((<Set__List__i32>key)._cpp_obj)] = deref((<Map__List__Set__string_string>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        try:
            if not isinstance(key, Set__List__i32):
                key = Set__List__i32(key)
        except Exception:
            raise err from None
        if not isinstance(key, Set__List__i32):
            raise err from None
        cdef cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]].iterator iter = deref(
            self._cpp_obj).find(deref((<Set__List__i32>key)._cpp_obj))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cmap[vector[cset[string]],string]] citem = reference_shared_ptr_Map__Set__List__i32_Map__List__Set__string_string(self._cpp_obj, deref(iter).second)
        return Map__List__Set__string_string.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cset[vector[cint32_t]]] citem
        cdef cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__Set__List__i32_Map__List__Set__string_string_key(self._cpp_obj, deref(loc).first)
            yield Set__List__i32.create(citem)
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        try:
            if not isinstance(key, Set__List__i32):
                key = Set__List__i32(key)
        except Exception:
            return False
        if not isinstance(key, Set__List__i32):
            return False
        cdef cset[vector[cint32_t]] ckey = deref((<Set__List__i32>key)._cpp_obj)
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, Set__List__i32):
                key = Set__List__i32(key)
        except Exception:
            return default
        if not isinstance(key, Set__List__i32):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef shared_ptr[cmap[vector[cset[string]],string]] citem
        cdef cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__Set__List__i32_Map__List__Set__string_string(self._cpp_obj, deref(loc).second)
            yield Map__List__Set__string_string.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef shared_ptr[cset[vector[cint32_t]]] ckey
        cdef shared_ptr[cmap[vector[cset[string]],string]] citem
        cdef cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = reference_shared_ptr_Map__Set__List__i32_Map__List__Set__string_string_key(self._cpp_obj, deref(loc).first)
            citem = reference_shared_ptr_Map__Set__List__i32_Map__List__Set__string_string(self._cpp_obj, deref(loc).second)
            yield (Set__List__i32.create(ckey), Map__List__Set__string_string.create(citem))
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__Set__List__i32_Map__List__Set__string_string()


Mapping.register(Map__Set__List__i32_Map__List__Set__string_string)

@__cython.auto_pickle(False)
cdef class List__Foo__i64(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Foo__i64):
            self._cpp_obj = (<List__Foo__i64> items)._cpp_obj
        else:
            self._cpp_obj = List__Foo__i64._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[Foo]] c_items):
        __fbthrift_inst = <List__Foo__i64>List__Foo__i64.__new__(List__Foo__i64)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__Foo__i64 self):
        cdef shared_ptr[vector[Foo]] cpp_obj = make_shared[vector[Foo]](
            deref(self._cpp_obj)
        )
        return List__Foo__i64.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[Foo]] _make_instance(object items) except *:
        cdef shared_ptr[vector[Foo]] c_inst = make_shared[vector[Foo]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint64_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[Foo]] c_inst
        cdef Foo citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[Foo]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Foo__i64.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[Foo].iterator, Foo](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef Foo citem
        cdef vector[Foo].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef Foo citem
        cdef vector[Foo].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[Foo].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[Foo].iterator loc = std_libcpp.find[vector[Foo].iterator, Foo](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <cint64_t> std_libcpp.count[vector[Foo].iterator, Foo](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Foo__i64()


Sequence.register(List__Foo__i64)

@__cython.auto_pickle(False)
cdef class List__Bar__double(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Bar__double):
            self._cpp_obj = (<List__Bar__double> items)._cpp_obj
        else:
            self._cpp_obj = List__Bar__double._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[Bar]] c_items):
        __fbthrift_inst = <List__Bar__double>List__Bar__double.__new__(List__Bar__double)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__Bar__double self):
        cdef shared_ptr[vector[Bar]] cpp_obj = make_shared[vector[Bar]](
            deref(self._cpp_obj)
        )
        return List__Bar__double.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[Bar]] _make_instance(object items) except *:
        cdef shared_ptr[vector[Bar]] c_inst = make_shared[vector[Bar]]()
        if items is not None:
            for item in items:
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")
                deref(c_inst).push_back(item)
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[Bar]] c_inst
        cdef Bar citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[Bar]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Bar__double.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, float):
            return False
        return std_libcpp.find[vector[Bar].iterator, Bar](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef Bar citem
        cdef vector[Bar].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef Bar citem
        cdef vector[Bar].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, float):
            raise err
        cdef vector[Bar].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[Bar].iterator loc = std_libcpp.find[vector[Bar].iterator, Bar](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, float):
            return 0
        return <cint64_t> std_libcpp.count[vector[Bar].iterator, Bar](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Bar__double()


Sequence.register(List__Bar__double)

@__cython.auto_pickle(False)
cdef class List__Baz__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Baz__i32):
            self._cpp_obj = (<List__Baz__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__Baz__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[Baz]] c_items):
        __fbthrift_inst = <List__Baz__i32>List__Baz__i32.__new__(List__Baz__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__Baz__i32 self):
        cdef shared_ptr[vector[Baz]] cpp_obj = make_shared[vector[Baz]](
            deref(self._cpp_obj)
        )
        return List__Baz__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[Baz]] _make_instance(object items) except *:
        cdef shared_ptr[vector[Baz]] c_inst = make_shared[vector[Baz]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[Baz]] c_inst
        cdef Baz citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[Baz]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Baz__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[Baz].iterator, Baz](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef Baz citem
        cdef vector[Baz].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef Baz citem
        cdef vector[Baz].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[Baz].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[Baz].iterator loc = std_libcpp.find[vector[Baz].iterator, Baz](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <cint64_t> std_libcpp.count[vector[Baz].iterator, Baz](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Baz__i32()


Sequence.register(List__Baz__i32)

IndirectionA = int
IndirectionC = int
IndirectionB = float

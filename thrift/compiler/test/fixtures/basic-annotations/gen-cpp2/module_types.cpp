/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/basic-annotations/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/basic-annotations/gen-cpp2/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/basic-annotations/gen-cpp2/module_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::cpp2::MyEnum>::size;
folly::Range<::cpp2::MyEnum const*> const TEnumTraits<::cpp2::MyEnum>::values = folly::range(TEnumDataStorage<::cpp2::MyEnum>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::cpp2::MyEnum>::names = folly::range(TEnumDataStorage<::cpp2::MyEnum>::names);

char const* TEnumTraits<::cpp2::MyEnum>::findName(type value) {
  using factory = ::cpp2::_MyEnum_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::cpp2::MyEnum>::findValue(char const* name, type* out) {
  using factory = ::cpp2::_MyEnum_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _MyEnum_EnumMapFactory::ValuesToNamesMapType _MyEnum_VALUES_TO_NAMES = _MyEnum_EnumMapFactory::makeValuesToNamesMap();
const _MyEnum_EnumMapFactory::NamesToValuesMapType _MyEnum_NAMES_TO_VALUES = _MyEnum_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyStructNestedAnnotation>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "name",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStructNestedAnnotation::MyStructNestedAnnotation(apache::thrift::FragileConstructor, ::std::string name__arg) :
    name(std::move(name__arg)) {
  __isset.name = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MyStructNestedAnnotation::__clear() {
  // clear all fields
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MyStructNestedAnnotation::operator==(const MyStructNestedAnnotation& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.name == rhs.name)) {
    return false;
  }
  return true;
}

bool MyStructNestedAnnotation::operator<(const MyStructNestedAnnotation& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.name == rhs.name)) {
    return lhs.name < rhs.name;
  }
  return false;
}


void swap(MyStructNestedAnnotation& a, MyStructNestedAnnotation& b) {
  using ::std::swap;
  swap(a.name_ref().value(), b.name_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MyStructNestedAnnotation::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStructNestedAnnotation::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStructNestedAnnotation::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStructNestedAnnotation::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStructNestedAnnotation::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStructNestedAnnotation::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStructNestedAnnotation::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStructNestedAnnotation::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyStructAnnotation>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "count",
    "name",
    "extra",
    "nest",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
  };
  static constexpr TType _types[] = {
    TType::T_I64,
    TType::T_STRING,
    TType::T_STRING,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStructAnnotation::MyStructAnnotation(apache::thrift::FragileConstructor, int64_t count__arg, ::std::string name__arg, ::std::string extra__arg,  ::cpp2::MyStructNestedAnnotation nest__arg) :
    count(std::move(count__arg)),
    name(std::move(name__arg)),
    extra(std::move(extra__arg)),
    nest(std::move(nest__arg)) {
  __isset.count = true;
  __isset.name = true;
  __isset.extra = true;
  __isset.nest = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MyStructAnnotation::__clear() {
  // clear all fields
  count = 0;
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  extra = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  ::apache::thrift::Cpp2Ops<  ::cpp2::MyStructNestedAnnotation>::clear(&nest);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MyStructAnnotation::operator==(const MyStructAnnotation& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.count == rhs.count)) {
    return false;
  }
  if (!(lhs.name == rhs.name)) {
    return false;
  }
  if (lhs.extra_ref() != rhs.extra_ref()) {
    return false;
  }
  if (!(lhs.nest == rhs.nest)) {
    return false;
  }
  return true;
}

bool MyStructAnnotation::operator<(const MyStructAnnotation& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.count == rhs.count)) {
    return lhs.count < rhs.count;
  }
  if (!(lhs.name == rhs.name)) {
    return lhs.name < rhs.name;
  }
  if (lhs.extra_ref() != rhs.extra_ref()) {
    return lhs.extra_ref() < rhs.extra_ref();
  }
  if (!(lhs.nest == rhs.nest)) {
    return lhs.nest < rhs.nest;
  }
  return false;
}

const  ::cpp2::MyStructNestedAnnotation& MyStructAnnotation::get_nest() const& {
  return nest;
}

 ::cpp2::MyStructNestedAnnotation MyStructAnnotation::get_nest() && {
  return std::move(nest);
}


void swap(MyStructAnnotation& a, MyStructAnnotation& b) {
  using ::std::swap;
  swap(a.count_ref().value(), b.count_ref().value());
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.extra_ref().value_unchecked(), b.extra_ref().value_unchecked());
  swap(a.nest_ref().value(), b.nest_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MyStructAnnotation::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStructAnnotation::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStructAnnotation::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStructAnnotation::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStructAnnotation::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStructAnnotation::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStructAnnotation::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStructAnnotation::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyStructAnnotation,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyStructNestedAnnotation>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyStructAnnotation,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyStructNestedAnnotation>,
    "inconsistent use of nimble option");

} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyStruct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 6;
  static constexpr folly::StringPiece _names[] = {
    "major",
    "package",
    "annotation_with_quote",
    "class_",
    "annotation_with_trailing_comma",
    "empty_annotations",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
  };
  static constexpr TType _types[] = {
    TType::T_I64,
    TType::T_STRING,
    TType::T_STRING,
    TType::T_STRING,
    TType::T_STRING,
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStruct::MyStruct() :
      majorVer(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


MyStruct::~MyStruct() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStruct::MyStruct(apache::thrift::FragileConstructor, int64_t majorVer__arg, ::std::string package__arg, ::std::string annotation_with_quote__arg, ::std::string class___arg, ::std::string annotation_with_trailing_comma__arg, ::std::string empty_annotations__arg) :
    majorVer(std::move(majorVer__arg)),
    package(std::move(package__arg)),
    annotation_with_quote(std::move(annotation_with_quote__arg)),
    class_(std::move(class___arg)),
    annotation_with_trailing_comma(std::move(annotation_with_trailing_comma__arg)),
    empty_annotations(std::move(empty_annotations__arg)) {
  __isset.majorVer = true;
  __isset.package = true;
  __isset.annotation_with_quote = true;
  __isset.class_ = true;
  __isset.annotation_with_trailing_comma = true;
  __isset.empty_annotations = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MyStruct::__clear() {
  // clear all fields
  majorVer = 0;
  package = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  annotation_with_quote = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  class_ = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  annotation_with_trailing_comma = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  empty_annotations = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MyStruct::operator==(const MyStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.majorVer == rhs.majorVer)) {
    return false;
  }
  if (!(lhs.package == rhs.package)) {
    return false;
  }
  if (!(lhs.annotation_with_quote == rhs.annotation_with_quote)) {
    return false;
  }
  if (!(lhs.class_ == rhs.class_)) {
    return false;
  }
  if (!(lhs.annotation_with_trailing_comma == rhs.annotation_with_trailing_comma)) {
    return false;
  }
  if (!(lhs.empty_annotations == rhs.empty_annotations)) {
    return false;
  }
  return true;
}

bool MyStruct::operator<(const MyStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.majorVer == rhs.majorVer)) {
    return lhs.majorVer < rhs.majorVer;
  }
  if (!(lhs.package == rhs.package)) {
    return lhs.package < rhs.package;
  }
  if (!(lhs.annotation_with_quote == rhs.annotation_with_quote)) {
    return lhs.annotation_with_quote < rhs.annotation_with_quote;
  }
  if (!(lhs.class_ == rhs.class_)) {
    return lhs.class_ < rhs.class_;
  }
  if (!(lhs.annotation_with_trailing_comma == rhs.annotation_with_trailing_comma)) {
    return lhs.annotation_with_trailing_comma < rhs.annotation_with_trailing_comma;
  }
  if (!(lhs.empty_annotations == rhs.empty_annotations)) {
    return lhs.empty_annotations < rhs.empty_annotations;
  }
  return false;
}


void swap(MyStruct& a, MyStruct& b) {
  using ::std::swap;
  swap(a.majorVer_ref().value(), b.majorVer_ref().value());
  swap(a.package_ref().value(), b.package_ref().value());
  swap(a.annotation_with_quote_ref().value(), b.annotation_with_quote_ref().value());
  swap(a.class__ref().value(), b.class__ref().value());
  swap(a.annotation_with_trailing_comma_ref().value(), b.annotation_with_trailing_comma_ref().value());
  swap(a.empty_annotations_ref().value(), b.empty_annotations_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MyStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::SecretStruct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "id",
    "password",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_I64,
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SecretStruct::SecretStruct(apache::thrift::FragileConstructor, int64_t id__arg, ::std::string password__arg) :
    id(std::move(id__arg)),
    password(std::move(password__arg)) {
  __isset.id = true;
  __isset.password = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void SecretStruct::__clear() {
  // clear all fields
  id = 0;
  password = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool SecretStruct::operator==(const SecretStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.id == rhs.id)) {
    return false;
  }
  if (!(lhs.password == rhs.password)) {
    return false;
  }
  return true;
}

bool SecretStruct::operator<(const SecretStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.id == rhs.id)) {
    return lhs.id < rhs.id;
  }
  if (!(lhs.password == rhs.password)) {
    return lhs.password < rhs.password;
  }
  return false;
}


void swap(SecretStruct& a, SecretStruct& b) {
  using ::std::swap;
  swap(a.id_ref().value(), b.id_ref().value());
  swap(a.password_ref().value(), b.password_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void SecretStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SecretStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SecretStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SecretStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SecretStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SecretStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SecretStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SecretStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

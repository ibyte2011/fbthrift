/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/refs/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/refs/gen-cpp2/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/refs/gen-cpp2/module_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::cpp2::TypedEnum>::size;
folly::Range<::cpp2::TypedEnum const*> const TEnumTraits<::cpp2::TypedEnum>::values = folly::range(TEnumDataStorage<::cpp2::TypedEnum>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::cpp2::TypedEnum>::names = folly::range(TEnumDataStorage<::cpp2::TypedEnum>::names);

char const* TEnumTraits<::cpp2::TypedEnum>::findName(type value) {
  using factory = ::cpp2::_TypedEnum_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::cpp2::TypedEnum>::findValue(char const* name, type* out) {
  using factory = ::cpp2::_TypedEnum_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _TypedEnum_EnumMapFactory::ValuesToNamesMapType _TypedEnum_VALUES_TO_NAMES = _TypedEnum_EnumMapFactory::makeValuesToNamesMap();
const _TypedEnum_EnumMapFactory::NamesToValuesMapType _TypedEnum_NAMES_TO_VALUES = _TypedEnum_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyUnion>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "anInteger",
    "aString",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::cpp2::MyUnion::Type>::size;
folly::Range<::cpp2::MyUnion::Type const*> const TEnumTraits<::cpp2::MyUnion::Type>::values = folly::range(TEnumDataStorage<::cpp2::MyUnion::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::cpp2::MyUnion::Type>::names = folly::range(TEnumDataStorage<::cpp2::MyUnion::Type>::names);

char const* TEnumTraits<::cpp2::MyUnion::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::cpp2::MyUnion::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::cpp2::MyUnion::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::cpp2::MyUnion::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace cpp2 {

void MyUnion::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::anInteger:
    {
      destruct(value_.anInteger);
      break;
    }
    case Type::aString:
    {
      destruct(value_.aString);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool MyUnion::operator==(const MyUnion& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::anInteger:
    {
      return value_.anInteger == rhs.value_.anInteger;
    }
    case Type::aString:
    {
      return value_.aString == rhs.value_.aString;
    }
    default:
    {
      return true;
    }
  }
}

bool MyUnion::operator<(const MyUnion& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::anInteger:
      return lhs.value_.anInteger < rhs.value_.anInteger;
    case Type::aString:
      return lhs.value_.aString < rhs.value_.aString;
    default:
      return false;
  }
}

void swap(MyUnion& a, MyUnion& b) {
  MyUnion temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void MyUnion::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyUnion::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyUnion::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyUnion::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyUnion::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyUnion::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyUnion::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyUnion::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyField>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "opt_value",
    "value",
    "req_value",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_I64,
    TType::T_I64,
    TType::T_I64,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyField::MyField(apache::thrift::FragileConstructor, int64_t opt_value__arg, int64_t value__arg, int64_t req_value__arg) :
    opt_value(std::move(opt_value__arg)),
    value(std::move(value__arg)),
    req_value(std::move(req_value__arg)) {
  __isset.opt_value = true;
  __isset.value = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MyField::__clear() {
  // clear all fields
  opt_value = 0;
  value = 0;
  req_value = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MyField::operator==(const MyField& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.opt_value_ref() != rhs.opt_value_ref()) {
    return false;
  }
  if (!(lhs.value == rhs.value)) {
    return false;
  }
  if (!(lhs.req_value == rhs.req_value)) {
    return false;
  }
  return true;
}

bool MyField::operator<(const MyField& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.opt_value_ref() != rhs.opt_value_ref()) {
    return lhs.opt_value_ref() < rhs.opt_value_ref();
  }
  if (!(lhs.value == rhs.value)) {
    return lhs.value < rhs.value;
  }
  if (!(lhs.req_value == rhs.req_value)) {
    return lhs.req_value < rhs.req_value;
  }
  return false;
}


void swap(MyField& a, MyField& b) {
  using ::std::swap;
  swap(a.opt_value_ref().value_unchecked(), b.opt_value_ref().value_unchecked());
  swap(a.value_ref().value(), b.value_ref().value());
  swap(a.req_value_ref().value(), b.req_value_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MyField::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyField::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyField::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyField::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyField::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyField::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyField::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyField::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyStruct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "opt_ref",
    "ref",
    "req_ref",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

MyStruct::MyStruct(const MyStruct& srcObj) {
  if (srcObj.opt_ref) opt_ref.reset(new  ::cpp2::MyField(*srcObj.opt_ref));
  if (srcObj.ref) ref.reset(new  ::cpp2::MyField(*srcObj.ref));
  if (srcObj.req_ref) req_ref.reset(new  ::cpp2::MyField(*srcObj.req_ref));
}

MyStruct& MyStruct::operator=(const MyStruct& src) {
  MyStruct tmp(src);
  swap(*this, tmp);
  return *this;
}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStruct::MyStruct(apache::thrift::FragileConstructor, std::unique_ptr< ::cpp2::MyField> opt_ref__arg, std::unique_ptr< ::cpp2::MyField> ref__arg, std::unique_ptr< ::cpp2::MyField> req_ref__arg) :
    opt_ref(std::move(opt_ref__arg)),
    ref(std::move(ref__arg)),
    req_ref(std::move(req_ref__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MyStruct::__clear() {
  // clear all fields
  opt_ref.reset();
  if (ref) ::apache::thrift::Cpp2Ops<  ::cpp2::MyField>::clear(ref.get());
  if (req_ref) ::apache::thrift::Cpp2Ops<  ::cpp2::MyField>::clear(req_ref.get());
}

bool MyStruct::operator==(const MyStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.opt_ref != !!rhs.opt_ref) {
    return false;
  }
  if (!!lhs.opt_ref) {
    if (lhs.opt_ref != rhs.opt_ref && !(*lhs.opt_ref == *rhs.opt_ref)) {
      return false;
    }
  }
  if (!!lhs.ref != !!rhs.ref) {
    return false;
  }
  if (!!lhs.ref) {
    if (lhs.ref != rhs.ref && !(*lhs.ref == *rhs.ref)) {
      return false;
    }
  }
  if (!!lhs.req_ref != !!rhs.req_ref) {
    return false;
  }
  if (!!lhs.req_ref) {
    if (lhs.req_ref != rhs.req_ref && !(*lhs.req_ref == *rhs.req_ref)) {
      return false;
    }
  }
  return true;
}

bool MyStruct::operator<(const MyStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.opt_ref != !!rhs.opt_ref) {
    return !!lhs.opt_ref < !!rhs.opt_ref;
  }
  if (!!lhs.opt_ref) {
    if (lhs.opt_ref != rhs.opt_ref && !(*lhs.opt_ref == *rhs.opt_ref)) {
      return *lhs.opt_ref < *rhs.opt_ref;
    }
  }
  if (!!lhs.ref != !!rhs.ref) {
    return !!lhs.ref < !!rhs.ref;
  }
  if (!!lhs.ref) {
    if (lhs.ref != rhs.ref && !(*lhs.ref == *rhs.ref)) {
      return *lhs.ref < *rhs.ref;
    }
  }
  if (!!lhs.req_ref != !!rhs.req_ref) {
    return !!lhs.req_ref < !!rhs.req_ref;
  }
  if (!!lhs.req_ref) {
    if (lhs.req_ref != rhs.req_ref && !(*lhs.req_ref == *rhs.req_ref)) {
      return *lhs.req_ref < *rhs.req_ref;
    }
  }
  return false;
}


void swap(MyStruct& a, MyStruct& b) {
  using ::std::swap;
  swap(a.opt_ref, b.opt_ref);
  swap(a.ref, b.ref);
  swap(a.req_ref, b.req_ref);
}

template void MyStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyStruct,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyStruct,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyStruct,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyStruct,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyStruct,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyStruct,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of nimble option");

} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithUnion>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "u",
    "aDouble",
    "f",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
    TType::T_DOUBLE,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithUnion::StructWithUnion(const StructWithUnion& srcObj) {
  if (srcObj.u) u.reset(new  ::cpp2::MyUnion(*srcObj.u));
  aDouble = srcObj.aDouble;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset.aDouble = srcObj.__isset.aDouble;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  f = srcObj.f;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset.f = srcObj.__isset.f;
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

StructWithUnion& StructWithUnion::operator=(const StructWithUnion& src) {
  StructWithUnion tmp(src);
  swap(*this, tmp);
  return *this;
}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StructWithUnion::StructWithUnion(apache::thrift::FragileConstructor, std::unique_ptr< ::cpp2::MyUnion> u__arg, double aDouble__arg,  ::cpp2::MyField f__arg) :
    u(std::move(u__arg)),
    aDouble(std::move(aDouble__arg)),
    f(std::move(f__arg)) {
  __isset.aDouble = true;
  __isset.f = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StructWithUnion::__clear() {
  // clear all fields
  if (u) ::apache::thrift::Cpp2Ops<  ::cpp2::MyUnion>::clear(u.get());
  aDouble = 0;
  ::apache::thrift::Cpp2Ops<  ::cpp2::MyField>::clear(&f);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool StructWithUnion::operator==(const StructWithUnion& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.u != !!rhs.u) {
    return false;
  }
  if (!!lhs.u) {
    if (lhs.u != rhs.u && !(*lhs.u == *rhs.u)) {
      return false;
    }
  }
  if (!(lhs.aDouble == rhs.aDouble)) {
    return false;
  }
  if (!(lhs.f == rhs.f)) {
    return false;
  }
  return true;
}

bool StructWithUnion::operator<(const StructWithUnion& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.u != !!rhs.u) {
    return !!lhs.u < !!rhs.u;
  }
  if (!!lhs.u) {
    if (lhs.u != rhs.u && !(*lhs.u == *rhs.u)) {
      return *lhs.u < *rhs.u;
    }
  }
  if (!(lhs.aDouble == rhs.aDouble)) {
    return lhs.aDouble < rhs.aDouble;
  }
  if (!(lhs.f == rhs.f)) {
    return lhs.f < rhs.f;
  }
  return false;
}

const  ::cpp2::MyField& StructWithUnion::get_f() const& {
  return f;
}

 ::cpp2::MyField StructWithUnion::get_f() && {
  return std::move(f);
}


void swap(StructWithUnion& a, StructWithUnion& b) {
  using ::std::swap;
  swap(a.u, b.u);
  swap(a.aDouble_ref().value(), b.aDouble_ref().value());
  swap(a.f_ref().value(), b.f_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void StructWithUnion::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithUnion::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithUnion::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithUnion::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithUnion::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithUnion::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithUnion::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithUnion::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithUnion,
        ::apache::thrift::type_class::variant,
         ::cpp2::MyUnion>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithUnion,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithUnion,
        ::apache::thrift::type_class::variant,
         ::cpp2::MyUnion>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithUnion,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of nimble option");

} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::RecursiveStruct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "mes",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_LIST,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RecursiveStruct::RecursiveStruct(apache::thrift::FragileConstructor, ::std::vector< ::cpp2::RecursiveStruct> mes__arg) :
    mes(std::move(mes__arg)) {
  __isset.mes = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RecursiveStruct::__clear() {
  // clear all fields
  mes.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RecursiveStruct::operator==(const RecursiveStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.mes_ref() != rhs.mes_ref()) {
    return false;
  }
  return true;
}

bool RecursiveStruct::operator<(const RecursiveStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.mes_ref() != rhs.mes_ref()) {
    return lhs.mes_ref() < rhs.mes_ref();
  }
  return false;
}

const ::std::vector< ::cpp2::RecursiveStruct>* RecursiveStruct::get_mes() const& {
  return mes_ref().has_value() ? std::addressof(mes) : nullptr;
}

::std::vector< ::cpp2::RecursiveStruct>* RecursiveStruct::get_mes() & {
  return mes_ref().has_value() ? std::addressof(mes) : nullptr;
}


void swap(RecursiveStruct& a, RecursiveStruct& b) {
  using ::std::swap;
  swap(a.mes_ref().value_unchecked(), b.mes_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RecursiveStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RecursiveStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RecursiveStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RecursiveStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RecursiveStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RecursiveStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RecursiveStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RecursiveStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithContainers>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 6;
  static constexpr folly::StringPiece _names[] = {
    "list_ref",
    "set_ref",
    "map_ref",
    "list_ref_unique",
    "set_ref_shared",
    "list_ref_shared_const",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
  };
  static constexpr TType _types[] = {
    TType::T_LIST,
    TType::T_SET,
    TType::T_MAP,
    TType::T_LIST,
    TType::T_SET,
    TType::T_LIST,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithContainers::StructWithContainers(const StructWithContainers& srcObj) {
  if (srcObj.list_ref) list_ref.reset(new ::std::vector<int32_t>(*srcObj.list_ref));
  if (srcObj.set_ref) set_ref.reset(new ::std::set<int32_t>(*srcObj.set_ref));
  if (srcObj.map_ref) map_ref.reset(new ::std::map<int32_t, int32_t>(*srcObj.map_ref));
  if (srcObj.list_ref_unique) list_ref_unique.reset(new ::std::vector<int32_t>(*srcObj.list_ref_unique));
  set_ref_shared = srcObj.set_ref_shared;
  list_ref_shared_const = srcObj.list_ref_shared_const;
}

StructWithContainers& StructWithContainers::operator=(const StructWithContainers& src) {
  StructWithContainers tmp(src);
  swap(*this, tmp);
  return *this;
}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StructWithContainers::StructWithContainers() :
      list_ref(std::make_unique<::std::vector<int32_t>>()),
      set_ref(std::make_unique<::std::set<int32_t>>()),
      map_ref(std::make_unique<::std::map<int32_t, int32_t>>()),
      list_ref_unique(std::make_unique<::std::vector<int32_t>>()),
      set_ref_shared(std::make_shared<::std::set<int32_t>>()),
      list_ref_shared_const(std::make_shared<::std::vector<int32_t>>()) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


StructWithContainers::~StructWithContainers() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StructWithContainers::StructWithContainers(apache::thrift::FragileConstructor, std::unique_ptr<::std::vector<int32_t>> list_ref__arg, std::unique_ptr<::std::set<int32_t>> set_ref__arg, std::unique_ptr<::std::map<int32_t, int32_t>> map_ref__arg, std::unique_ptr<::std::vector<int32_t>> list_ref_unique__arg, std::shared_ptr<::std::set<int32_t>> set_ref_shared__arg, std::shared_ptr<const ::std::vector<int32_t>> list_ref_shared_const__arg) :
    list_ref(std::move(list_ref__arg)),
    set_ref(std::move(set_ref__arg)),
    map_ref(std::move(map_ref__arg)),
    list_ref_unique(std::move(list_ref_unique__arg)),
    set_ref_shared(std::move(set_ref_shared__arg)),
    list_ref_shared_const(std::move(list_ref_shared_const__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StructWithContainers::__clear() {
  // clear all fields
  list_ref.reset(new typename decltype(list_ref)::element_type());
  set_ref.reset(new typename decltype(set_ref)::element_type());
  map_ref.reset(new typename decltype(map_ref)::element_type());
  list_ref_unique.reset(new typename decltype(list_ref_unique)::element_type());
  set_ref_shared.reset(new typename decltype(set_ref_shared)::element_type());
  list_ref_shared_const.reset(new typename decltype(list_ref_shared_const)::element_type());
}

bool StructWithContainers::operator==(const StructWithContainers& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.list_ref != !!rhs.list_ref) {
    return false;
  }
  if (!!lhs.list_ref) {
    if (lhs.list_ref != rhs.list_ref && !(*lhs.list_ref == *rhs.list_ref)) {
      return false;
    }
  }
  if (!!lhs.set_ref != !!rhs.set_ref) {
    return false;
  }
  if (!!lhs.set_ref) {
    if (lhs.set_ref != rhs.set_ref && !(*lhs.set_ref == *rhs.set_ref)) {
      return false;
    }
  }
  if (!!lhs.map_ref != !!rhs.map_ref) {
    return false;
  }
  if (!!lhs.map_ref) {
    if (lhs.map_ref != rhs.map_ref && !(*lhs.map_ref == *rhs.map_ref)) {
      return false;
    }
  }
  if (!!lhs.list_ref_unique != !!rhs.list_ref_unique) {
    return false;
  }
  if (!!lhs.list_ref_unique) {
    if (lhs.list_ref_unique != rhs.list_ref_unique && !(*lhs.list_ref_unique == *rhs.list_ref_unique)) {
      return false;
    }
  }
  if (!!lhs.set_ref_shared != !!rhs.set_ref_shared) {
    return false;
  }
  if (!!lhs.set_ref_shared) {
    if (lhs.set_ref_shared != rhs.set_ref_shared && !(*lhs.set_ref_shared == *rhs.set_ref_shared)) {
      return false;
    }
  }
  if (!!lhs.list_ref_shared_const != !!rhs.list_ref_shared_const) {
    return false;
  }
  if (!!lhs.list_ref_shared_const) {
    if (lhs.list_ref_shared_const != rhs.list_ref_shared_const && !(*lhs.list_ref_shared_const == *rhs.list_ref_shared_const)) {
      return false;
    }
  }
  return true;
}

bool StructWithContainers::operator<(const StructWithContainers& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.list_ref != !!rhs.list_ref) {
    return !!lhs.list_ref < !!rhs.list_ref;
  }
  if (!!lhs.list_ref) {
    if (lhs.list_ref != rhs.list_ref && !(*lhs.list_ref == *rhs.list_ref)) {
      return *lhs.list_ref < *rhs.list_ref;
    }
  }
  if (!!lhs.set_ref != !!rhs.set_ref) {
    return !!lhs.set_ref < !!rhs.set_ref;
  }
  if (!!lhs.set_ref) {
    if (lhs.set_ref != rhs.set_ref && !(*lhs.set_ref == *rhs.set_ref)) {
      return *lhs.set_ref < *rhs.set_ref;
    }
  }
  if (!!lhs.map_ref != !!rhs.map_ref) {
    return !!lhs.map_ref < !!rhs.map_ref;
  }
  if (!!lhs.map_ref) {
    if (lhs.map_ref != rhs.map_ref && !(*lhs.map_ref == *rhs.map_ref)) {
      return *lhs.map_ref < *rhs.map_ref;
    }
  }
  if (!!lhs.list_ref_unique != !!rhs.list_ref_unique) {
    return !!lhs.list_ref_unique < !!rhs.list_ref_unique;
  }
  if (!!lhs.list_ref_unique) {
    if (lhs.list_ref_unique != rhs.list_ref_unique && !(*lhs.list_ref_unique == *rhs.list_ref_unique)) {
      return *lhs.list_ref_unique < *rhs.list_ref_unique;
    }
  }
  if (!!lhs.set_ref_shared != !!rhs.set_ref_shared) {
    return !!lhs.set_ref_shared < !!rhs.set_ref_shared;
  }
  if (!!lhs.set_ref_shared) {
    if (lhs.set_ref_shared != rhs.set_ref_shared && !(*lhs.set_ref_shared == *rhs.set_ref_shared)) {
      return *lhs.set_ref_shared < *rhs.set_ref_shared;
    }
  }
  if (!!lhs.list_ref_shared_const != !!rhs.list_ref_shared_const) {
    return !!lhs.list_ref_shared_const < !!rhs.list_ref_shared_const;
  }
  if (!!lhs.list_ref_shared_const) {
    if (lhs.list_ref_shared_const != rhs.list_ref_shared_const && !(*lhs.list_ref_shared_const == *rhs.list_ref_shared_const)) {
      return *lhs.list_ref_shared_const < *rhs.list_ref_shared_const;
    }
  }
  return false;
}


void swap(StructWithContainers& a, StructWithContainers& b) {
  using ::std::swap;
  swap(a.list_ref, b.list_ref);
  swap(a.set_ref, b.set_ref);
  swap(a.map_ref, b.map_ref);
  swap(a.list_ref_unique, b.list_ref_unique);
  swap(a.set_ref_shared, b.set_ref_shared);
  swap(a.list_ref_shared_const, b.list_ref_shared_const);
}

template void StructWithContainers::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithContainers::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithContainers::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithContainers::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithContainers::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithContainers::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithContainers::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithContainers::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithSharedConst>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "opt_shared_const",
    "shared_const",
    "req_shared_const",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StructWithSharedConst::StructWithSharedConst(apache::thrift::FragileConstructor, std::shared_ptr<const  ::cpp2::MyField> opt_shared_const__arg, std::shared_ptr<const  ::cpp2::MyField> shared_const__arg, std::shared_ptr<const  ::cpp2::MyField> req_shared_const__arg) :
    opt_shared_const(std::move(opt_shared_const__arg)),
    shared_const(std::move(shared_const__arg)),
    req_shared_const(std::move(req_shared_const__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StructWithSharedConst::__clear() {
  // clear all fields
  opt_shared_const.reset();
  if (shared_const) shared_const.reset(new typename decltype(shared_const)::element_type());
  if (req_shared_const) req_shared_const.reset(new typename decltype(req_shared_const)::element_type());
}

bool StructWithSharedConst::operator==(const StructWithSharedConst& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.opt_shared_const != !!rhs.opt_shared_const) {
    return false;
  }
  if (!!lhs.opt_shared_const) {
    if (lhs.opt_shared_const != rhs.opt_shared_const && !(*lhs.opt_shared_const == *rhs.opt_shared_const)) {
      return false;
    }
  }
  if (!!lhs.shared_const != !!rhs.shared_const) {
    return false;
  }
  if (!!lhs.shared_const) {
    if (lhs.shared_const != rhs.shared_const && !(*lhs.shared_const == *rhs.shared_const)) {
      return false;
    }
  }
  if (!!lhs.req_shared_const != !!rhs.req_shared_const) {
    return false;
  }
  if (!!lhs.req_shared_const) {
    if (lhs.req_shared_const != rhs.req_shared_const && !(*lhs.req_shared_const == *rhs.req_shared_const)) {
      return false;
    }
  }
  return true;
}

bool StructWithSharedConst::operator<(const StructWithSharedConst& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.opt_shared_const != !!rhs.opt_shared_const) {
    return !!lhs.opt_shared_const < !!rhs.opt_shared_const;
  }
  if (!!lhs.opt_shared_const) {
    if (lhs.opt_shared_const != rhs.opt_shared_const && !(*lhs.opt_shared_const == *rhs.opt_shared_const)) {
      return *lhs.opt_shared_const < *rhs.opt_shared_const;
    }
  }
  if (!!lhs.shared_const != !!rhs.shared_const) {
    return !!lhs.shared_const < !!rhs.shared_const;
  }
  if (!!lhs.shared_const) {
    if (lhs.shared_const != rhs.shared_const && !(*lhs.shared_const == *rhs.shared_const)) {
      return *lhs.shared_const < *rhs.shared_const;
    }
  }
  if (!!lhs.req_shared_const != !!rhs.req_shared_const) {
    return !!lhs.req_shared_const < !!rhs.req_shared_const;
  }
  if (!!lhs.req_shared_const) {
    if (lhs.req_shared_const != rhs.req_shared_const && !(*lhs.req_shared_const == *rhs.req_shared_const)) {
      return *lhs.req_shared_const < *rhs.req_shared_const;
    }
  }
  return false;
}


void swap(StructWithSharedConst& a, StructWithSharedConst& b) {
  using ::std::swap;
  swap(a.opt_shared_const, b.opt_shared_const);
  swap(a.shared_const, b.shared_const);
  swap(a.req_shared_const, b.req_shared_const);
}

template void StructWithSharedConst::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithSharedConst::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithSharedConst::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithSharedConst::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithSharedConst::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithSharedConst::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithSharedConst::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithSharedConst::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithSharedConst,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithSharedConst,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithSharedConst,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithSharedConst,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithSharedConst,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithSharedConst,
        ::apache::thrift::type_class::structure,
         ::cpp2::MyField>,
    "inconsistent use of nimble option");

} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::Empty>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Empty::Empty(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Empty::__clear() {
  // clear all fields
}

bool Empty::operator==(const Empty& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool Empty::operator<(const Empty& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(Empty& a, Empty& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void Empty::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Empty::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Empty::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Empty::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Empty::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Empty::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Empty::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Empty::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithRef>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "def_field",
    "opt_field",
    "req_field",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithRef::StructWithRef(const StructWithRef& srcObj) {
  if (srcObj.def_field) def_field.reset(new  ::cpp2::Empty(*srcObj.def_field));
  if (srcObj.opt_field) opt_field.reset(new  ::cpp2::Empty(*srcObj.opt_field));
  if (srcObj.req_field) req_field.reset(new  ::cpp2::Empty(*srcObj.req_field));
}

StructWithRef& StructWithRef::operator=(const StructWithRef& src) {
  StructWithRef tmp(src);
  swap(*this, tmp);
  return *this;
}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StructWithRef::StructWithRef(apache::thrift::FragileConstructor, std::unique_ptr< ::cpp2::Empty> def_field__arg, std::unique_ptr< ::cpp2::Empty> opt_field__arg, std::unique_ptr< ::cpp2::Empty> req_field__arg) :
    def_field(std::move(def_field__arg)),
    opt_field(std::move(opt_field__arg)),
    req_field(std::move(req_field__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StructWithRef::__clear() {
  // clear all fields
}

bool StructWithRef::operator==(const StructWithRef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.def_field != !!rhs.def_field) {
    return false;
  }
  if (!!lhs.def_field) {
    if (lhs.def_field != rhs.def_field && !(*lhs.def_field == *rhs.def_field)) {
      return false;
    }
  }
  if (!!lhs.opt_field != !!rhs.opt_field) {
    return false;
  }
  if (!!lhs.opt_field) {
    if (lhs.opt_field != rhs.opt_field && !(*lhs.opt_field == *rhs.opt_field)) {
      return false;
    }
  }
  if (!!lhs.req_field != !!rhs.req_field) {
    return false;
  }
  if (!!lhs.req_field) {
    if (lhs.req_field != rhs.req_field && !(*lhs.req_field == *rhs.req_field)) {
      return false;
    }
  }
  return true;
}

bool StructWithRef::operator<(const StructWithRef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.def_field != !!rhs.def_field) {
    return !!lhs.def_field < !!rhs.def_field;
  }
  if (!!lhs.def_field) {
    if (lhs.def_field != rhs.def_field && !(*lhs.def_field == *rhs.def_field)) {
      return *lhs.def_field < *rhs.def_field;
    }
  }
  if (!!lhs.opt_field != !!rhs.opt_field) {
    return !!lhs.opt_field < !!rhs.opt_field;
  }
  if (!!lhs.opt_field) {
    if (lhs.opt_field != rhs.opt_field && !(*lhs.opt_field == *rhs.opt_field)) {
      return *lhs.opt_field < *rhs.opt_field;
    }
  }
  if (!!lhs.req_field != !!rhs.req_field) {
    return !!lhs.req_field < !!rhs.req_field;
  }
  if (!!lhs.req_field) {
    if (lhs.req_field != rhs.req_field && !(*lhs.req_field == *rhs.req_field)) {
      return *lhs.req_field < *rhs.req_field;
    }
  }
  return false;
}


void swap(StructWithRef& a, StructWithRef& b) {
  using ::std::swap;
  swap(a.def_field, b.def_field);
  swap(a.opt_field, b.opt_field);
  swap(a.req_field, b.req_field);
}

template void StructWithRef::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithRef::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithRef::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithRef::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithRef::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithRef::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithRef::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithRef::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRef,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRef,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRef,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRef,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRef,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRef,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");

} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithRefTypeUnique>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "def_field",
    "opt_field",
    "req_field",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithRefTypeUnique::StructWithRefTypeUnique(const StructWithRefTypeUnique& srcObj) {
  if (srcObj.def_field) def_field.reset(new  ::cpp2::Empty(*srcObj.def_field));
  if (srcObj.opt_field) opt_field.reset(new  ::cpp2::Empty(*srcObj.opt_field));
  if (srcObj.req_field) req_field.reset(new  ::cpp2::Empty(*srcObj.req_field));
}

StructWithRefTypeUnique& StructWithRefTypeUnique::operator=(const StructWithRefTypeUnique& src) {
  StructWithRefTypeUnique tmp(src);
  swap(*this, tmp);
  return *this;
}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StructWithRefTypeUnique::StructWithRefTypeUnique(apache::thrift::FragileConstructor, std::unique_ptr< ::cpp2::Empty> def_field__arg, std::unique_ptr< ::cpp2::Empty> opt_field__arg, std::unique_ptr< ::cpp2::Empty> req_field__arg) :
    def_field(std::move(def_field__arg)),
    opt_field(std::move(opt_field__arg)),
    req_field(std::move(req_field__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StructWithRefTypeUnique::__clear() {
  // clear all fields
}

bool StructWithRefTypeUnique::operator==(const StructWithRefTypeUnique& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.def_field != !!rhs.def_field) {
    return false;
  }
  if (!!lhs.def_field) {
    if (lhs.def_field != rhs.def_field && !(*lhs.def_field == *rhs.def_field)) {
      return false;
    }
  }
  if (!!lhs.opt_field != !!rhs.opt_field) {
    return false;
  }
  if (!!lhs.opt_field) {
    if (lhs.opt_field != rhs.opt_field && !(*lhs.opt_field == *rhs.opt_field)) {
      return false;
    }
  }
  if (!!lhs.req_field != !!rhs.req_field) {
    return false;
  }
  if (!!lhs.req_field) {
    if (lhs.req_field != rhs.req_field && !(*lhs.req_field == *rhs.req_field)) {
      return false;
    }
  }
  return true;
}

bool StructWithRefTypeUnique::operator<(const StructWithRefTypeUnique& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.def_field != !!rhs.def_field) {
    return !!lhs.def_field < !!rhs.def_field;
  }
  if (!!lhs.def_field) {
    if (lhs.def_field != rhs.def_field && !(*lhs.def_field == *rhs.def_field)) {
      return *lhs.def_field < *rhs.def_field;
    }
  }
  if (!!lhs.opt_field != !!rhs.opt_field) {
    return !!lhs.opt_field < !!rhs.opt_field;
  }
  if (!!lhs.opt_field) {
    if (lhs.opt_field != rhs.opt_field && !(*lhs.opt_field == *rhs.opt_field)) {
      return *lhs.opt_field < *rhs.opt_field;
    }
  }
  if (!!lhs.req_field != !!rhs.req_field) {
    return !!lhs.req_field < !!rhs.req_field;
  }
  if (!!lhs.req_field) {
    if (lhs.req_field != rhs.req_field && !(*lhs.req_field == *rhs.req_field)) {
      return *lhs.req_field < *rhs.req_field;
    }
  }
  return false;
}


void swap(StructWithRefTypeUnique& a, StructWithRefTypeUnique& b) {
  using ::std::swap;
  swap(a.def_field, b.def_field);
  swap(a.opt_field, b.opt_field);
  swap(a.req_field, b.req_field);
}

template void StructWithRefTypeUnique::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithRefTypeUnique::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithRefTypeUnique::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithRefTypeUnique::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithRefTypeUnique::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithRefTypeUnique::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithRefTypeUnique::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithRefTypeUnique::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeUnique,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeUnique,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeUnique,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeUnique,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeUnique,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeUnique,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");

} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithRefTypeShared>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "def_field",
    "opt_field",
    "req_field",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StructWithRefTypeShared::StructWithRefTypeShared(apache::thrift::FragileConstructor, std::shared_ptr< ::cpp2::Empty> def_field__arg, std::shared_ptr< ::cpp2::Empty> opt_field__arg, std::shared_ptr< ::cpp2::Empty> req_field__arg) :
    def_field(std::move(def_field__arg)),
    opt_field(std::move(opt_field__arg)),
    req_field(std::move(req_field__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StructWithRefTypeShared::__clear() {
  // clear all fields
}

bool StructWithRefTypeShared::operator==(const StructWithRefTypeShared& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.def_field != !!rhs.def_field) {
    return false;
  }
  if (!!lhs.def_field) {
    if (lhs.def_field != rhs.def_field && !(*lhs.def_field == *rhs.def_field)) {
      return false;
    }
  }
  if (!!lhs.opt_field != !!rhs.opt_field) {
    return false;
  }
  if (!!lhs.opt_field) {
    if (lhs.opt_field != rhs.opt_field && !(*lhs.opt_field == *rhs.opt_field)) {
      return false;
    }
  }
  if (!!lhs.req_field != !!rhs.req_field) {
    return false;
  }
  if (!!lhs.req_field) {
    if (lhs.req_field != rhs.req_field && !(*lhs.req_field == *rhs.req_field)) {
      return false;
    }
  }
  return true;
}

bool StructWithRefTypeShared::operator<(const StructWithRefTypeShared& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.def_field != !!rhs.def_field) {
    return !!lhs.def_field < !!rhs.def_field;
  }
  if (!!lhs.def_field) {
    if (lhs.def_field != rhs.def_field && !(*lhs.def_field == *rhs.def_field)) {
      return *lhs.def_field < *rhs.def_field;
    }
  }
  if (!!lhs.opt_field != !!rhs.opt_field) {
    return !!lhs.opt_field < !!rhs.opt_field;
  }
  if (!!lhs.opt_field) {
    if (lhs.opt_field != rhs.opt_field && !(*lhs.opt_field == *rhs.opt_field)) {
      return *lhs.opt_field < *rhs.opt_field;
    }
  }
  if (!!lhs.req_field != !!rhs.req_field) {
    return !!lhs.req_field < !!rhs.req_field;
  }
  if (!!lhs.req_field) {
    if (lhs.req_field != rhs.req_field && !(*lhs.req_field == *rhs.req_field)) {
      return *lhs.req_field < *rhs.req_field;
    }
  }
  return false;
}


void swap(StructWithRefTypeShared& a, StructWithRefTypeShared& b) {
  using ::std::swap;
  swap(a.def_field, b.def_field);
  swap(a.opt_field, b.opt_field);
  swap(a.req_field, b.req_field);
}

template void StructWithRefTypeShared::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithRefTypeShared::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithRefTypeShared::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithRefTypeShared::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithRefTypeShared::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithRefTypeShared::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithRefTypeShared::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithRefTypeShared::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeShared,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeShared,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeShared,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeShared,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeShared,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeShared,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");

} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithRefTypeSharedConst>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "def_field",
    "opt_field",
    "req_field",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StructWithRefTypeSharedConst::StructWithRefTypeSharedConst(apache::thrift::FragileConstructor, std::shared_ptr<const  ::cpp2::Empty> def_field__arg, std::shared_ptr<const  ::cpp2::Empty> opt_field__arg, std::shared_ptr<const  ::cpp2::Empty> req_field__arg) :
    def_field(std::move(def_field__arg)),
    opt_field(std::move(opt_field__arg)),
    req_field(std::move(req_field__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StructWithRefTypeSharedConst::__clear() {
  // clear all fields
}

bool StructWithRefTypeSharedConst::operator==(const StructWithRefTypeSharedConst& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.def_field != !!rhs.def_field) {
    return false;
  }
  if (!!lhs.def_field) {
    if (lhs.def_field != rhs.def_field && !(*lhs.def_field == *rhs.def_field)) {
      return false;
    }
  }
  if (!!lhs.opt_field != !!rhs.opt_field) {
    return false;
  }
  if (!!lhs.opt_field) {
    if (lhs.opt_field != rhs.opt_field && !(*lhs.opt_field == *rhs.opt_field)) {
      return false;
    }
  }
  if (!!lhs.req_field != !!rhs.req_field) {
    return false;
  }
  if (!!lhs.req_field) {
    if (lhs.req_field != rhs.req_field && !(*lhs.req_field == *rhs.req_field)) {
      return false;
    }
  }
  return true;
}

bool StructWithRefTypeSharedConst::operator<(const StructWithRefTypeSharedConst& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.def_field != !!rhs.def_field) {
    return !!lhs.def_field < !!rhs.def_field;
  }
  if (!!lhs.def_field) {
    if (lhs.def_field != rhs.def_field && !(*lhs.def_field == *rhs.def_field)) {
      return *lhs.def_field < *rhs.def_field;
    }
  }
  if (!!lhs.opt_field != !!rhs.opt_field) {
    return !!lhs.opt_field < !!rhs.opt_field;
  }
  if (!!lhs.opt_field) {
    if (lhs.opt_field != rhs.opt_field && !(*lhs.opt_field == *rhs.opt_field)) {
      return *lhs.opt_field < *rhs.opt_field;
    }
  }
  if (!!lhs.req_field != !!rhs.req_field) {
    return !!lhs.req_field < !!rhs.req_field;
  }
  if (!!lhs.req_field) {
    if (lhs.req_field != rhs.req_field && !(*lhs.req_field == *rhs.req_field)) {
      return *lhs.req_field < *rhs.req_field;
    }
  }
  return false;
}


void swap(StructWithRefTypeSharedConst& a, StructWithRefTypeSharedConst& b) {
  using ::std::swap;
  swap(a.def_field, b.def_field);
  swap(a.opt_field, b.opt_field);
  swap(a.req_field, b.req_field);
}

template void StructWithRefTypeSharedConst::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithRefTypeSharedConst::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithRefTypeSharedConst::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithRefTypeSharedConst::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithRefTypeSharedConst::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithRefTypeSharedConst::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithRefTypeSharedConst::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithRefTypeSharedConst::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeSharedConst,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeSharedConst,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeSharedConst,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeSharedConst,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeSharedConst,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeSharedConst,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");

} // cpp2
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithRefAndAnnotCppNoexceptMoveCtor>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "def_field",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithRefAndAnnotCppNoexceptMoveCtor::StructWithRefAndAnnotCppNoexceptMoveCtor(const StructWithRefAndAnnotCppNoexceptMoveCtor& srcObj) {
  if (srcObj.def_field) def_field.reset(new  ::cpp2::Empty(*srcObj.def_field));
}

StructWithRefAndAnnotCppNoexceptMoveCtor& StructWithRefAndAnnotCppNoexceptMoveCtor::operator=(const StructWithRefAndAnnotCppNoexceptMoveCtor& src) {
  StructWithRefAndAnnotCppNoexceptMoveCtor tmp(src);
  swap(*this, tmp);
  return *this;
}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StructWithRefAndAnnotCppNoexceptMoveCtor::StructWithRefAndAnnotCppNoexceptMoveCtor(apache::thrift::FragileConstructor, std::unique_ptr< ::cpp2::Empty> def_field__arg) :
    def_field(std::move(def_field__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StructWithRefAndAnnotCppNoexceptMoveCtor::__clear() {
  // clear all fields
}

bool StructWithRefAndAnnotCppNoexceptMoveCtor::operator==(const StructWithRefAndAnnotCppNoexceptMoveCtor& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.def_field != !!rhs.def_field) {
    return false;
  }
  if (!!lhs.def_field) {
    if (lhs.def_field != rhs.def_field && !(*lhs.def_field == *rhs.def_field)) {
      return false;
    }
  }
  return true;
}

bool StructWithRefAndAnnotCppNoexceptMoveCtor::operator<(const StructWithRefAndAnnotCppNoexceptMoveCtor& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!!lhs.def_field != !!rhs.def_field) {
    return !!lhs.def_field < !!rhs.def_field;
  }
  if (!!lhs.def_field) {
    if (lhs.def_field != rhs.def_field && !(*lhs.def_field == *rhs.def_field)) {
      return *lhs.def_field < *rhs.def_field;
    }
  }
  return false;
}


void swap(StructWithRefAndAnnotCppNoexceptMoveCtor& a, StructWithRefAndAnnotCppNoexceptMoveCtor& b) {
  using ::std::swap;
  swap(a.def_field, b.def_field);
}

template void StructWithRefAndAnnotCppNoexceptMoveCtor::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithRefAndAnnotCppNoexceptMoveCtor::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithRefAndAnnotCppNoexceptMoveCtor::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithRefAndAnnotCppNoexceptMoveCtor::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithRefAndAnnotCppNoexceptMoveCtor::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithRefAndAnnotCppNoexceptMoveCtor::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithRefAndAnnotCppNoexceptMoveCtor::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithRefAndAnnotCppNoexceptMoveCtor::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefAndAnnotCppNoexceptMoveCtor,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefAndAnnotCppNoexceptMoveCtor,
        ::apache::thrift::type_class::structure,
         ::cpp2::Empty>,
    "inconsistent use of nimble option");

} // cpp2

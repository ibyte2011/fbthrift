// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::consts::*;
pub use self::errors::*;
pub use self::types::*;

pub mod consts {
    pub const kOne: crate::types::MyEnum = crate::types::MyEnum::ONE;
}

pub mod types {
    #![allow(clippy::redundant_closure)]


    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct MyStruct {
        pub myEnum: crate::types::MyEnum,
        pub myBigEnum: crate::types::MyBigEnum,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct EmptyEnum(pub ::std::primitive::i32);

    impl EmptyEnum {

        pub fn variants() -> &'static [&'static str] {
            &[
            ]
        }
    }

    impl ::std::default::Default for EmptyEnum {
        fn default() -> Self {
            EmptyEnum(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a EmptyEnum> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a EmptyEnum) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<EmptyEnum> for ::std::primitive::i32 {
        #[inline]
        fn from(x: EmptyEnum) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for EmptyEnum {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for EmptyEnum {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "{}", self.0)
        }
    }

    impl ::std::fmt::Debug for EmptyEnum {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "EmptyEnum::{}", self)
        }
    }

    impl ::std::str::FromStr for EmptyEnum {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                _ => ::anyhow::bail!("Unable to parse {} as EmptyEnum", string),
            }
        }
    }

    impl ::fbthrift::GetTType for EmptyEnum {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for EmptyEnum
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for EmptyEnum
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(EmptyEnum::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct MyEnum(pub ::std::primitive::i32);

    impl MyEnum {
        pub const ONE: Self = MyEnum(1i32);
        pub const TWO: Self = MyEnum(2i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "ONE",
                "TWO",
            ]
        }
    }

    impl ::std::default::Default for MyEnum {
        fn default() -> Self {
            MyEnum(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a MyEnum> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a MyEnum) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<MyEnum> for ::std::primitive::i32 {
        #[inline]
        fn from(x: MyEnum) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for MyEnum {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for MyEnum {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                MyEnum::ONE => "ONE",
                MyEnum::TWO => "TWO",
                MyEnum(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for MyEnum {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "MyEnum::{}", self)
        }
    }

    impl ::std::str::FromStr for MyEnum {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "ONE" => ::std::result::Result::Ok(MyEnum::ONE),
                "TWO" => ::std::result::Result::Ok(MyEnum::TWO),
                _ => ::anyhow::bail!("Unable to parse {} as MyEnum", string),
            }
        }
    }

    impl ::fbthrift::GetTType for MyEnum {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for MyEnum
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for MyEnum
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(MyEnum::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct MyBigEnum(pub ::std::primitive::i32);

    impl MyBigEnum {
        pub const UNKNOWN: Self = MyBigEnum(0i32);
        pub const ONE: Self = MyBigEnum(1i32);
        pub const TWO: Self = MyBigEnum(2i32);
        pub const THREE: Self = MyBigEnum(3i32);
        pub const FOUR: Self = MyBigEnum(4i32);
        pub const FIVE: Self = MyBigEnum(5i32);
        pub const SIX: Self = MyBigEnum(6i32);
        pub const SEVEN: Self = MyBigEnum(7i32);
        pub const EIGHT: Self = MyBigEnum(8i32);
        pub const NINE: Self = MyBigEnum(9i32);
        pub const TEN: Self = MyBigEnum(10i32);
        pub const ELEVEN: Self = MyBigEnum(11i32);
        pub const TWELVE: Self = MyBigEnum(12i32);
        pub const THIRTEEN: Self = MyBigEnum(13i32);
        pub const FOURTEEN: Self = MyBigEnum(14i32);
        pub const FIFTEEN: Self = MyBigEnum(15i32);
        pub const SIXTEEN: Self = MyBigEnum(16i32);
        pub const SEVENTEEN: Self = MyBigEnum(17i32);
        pub const EIGHTEEN: Self = MyBigEnum(18i32);
        pub const NINETEEN: Self = MyBigEnum(19i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "UNKNOWN",
                "ONE",
                "TWO",
                "THREE",
                "FOUR",
                "FIVE",
                "SIX",
                "SEVEN",
                "EIGHT",
                "NINE",
                "TEN",
                "ELEVEN",
                "TWELVE",
                "THIRTEEN",
                "FOURTEEN",
                "FIFTEEN",
                "SIXTEEN",
                "SEVENTEEN",
                "EIGHTEEN",
                "NINETEEN",
            ]
        }
    }

    impl ::std::default::Default for MyBigEnum {
        fn default() -> Self {
            MyBigEnum(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a MyBigEnum> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a MyBigEnum) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<MyBigEnum> for ::std::primitive::i32 {
        #[inline]
        fn from(x: MyBigEnum) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for MyBigEnum {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for MyBigEnum {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                MyBigEnum::UNKNOWN => "UNKNOWN",
                MyBigEnum::ONE => "ONE",
                MyBigEnum::TWO => "TWO",
                MyBigEnum::THREE => "THREE",
                MyBigEnum::FOUR => "FOUR",
                MyBigEnum::FIVE => "FIVE",
                MyBigEnum::SIX => "SIX",
                MyBigEnum::SEVEN => "SEVEN",
                MyBigEnum::EIGHT => "EIGHT",
                MyBigEnum::NINE => "NINE",
                MyBigEnum::TEN => "TEN",
                MyBigEnum::ELEVEN => "ELEVEN",
                MyBigEnum::TWELVE => "TWELVE",
                MyBigEnum::THIRTEEN => "THIRTEEN",
                MyBigEnum::FOURTEEN => "FOURTEEN",
                MyBigEnum::FIFTEEN => "FIFTEEN",
                MyBigEnum::SIXTEEN => "SIXTEEN",
                MyBigEnum::SEVENTEEN => "SEVENTEEN",
                MyBigEnum::EIGHTEEN => "EIGHTEEN",
                MyBigEnum::NINETEEN => "NINETEEN",
                MyBigEnum(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for MyBigEnum {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "MyBigEnum::{}", self)
        }
    }

    impl ::std::str::FromStr for MyBigEnum {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "UNKNOWN" => ::std::result::Result::Ok(MyBigEnum::UNKNOWN),
                "ONE" => ::std::result::Result::Ok(MyBigEnum::ONE),
                "TWO" => ::std::result::Result::Ok(MyBigEnum::TWO),
                "THREE" => ::std::result::Result::Ok(MyBigEnum::THREE),
                "FOUR" => ::std::result::Result::Ok(MyBigEnum::FOUR),
                "FIVE" => ::std::result::Result::Ok(MyBigEnum::FIVE),
                "SIX" => ::std::result::Result::Ok(MyBigEnum::SIX),
                "SEVEN" => ::std::result::Result::Ok(MyBigEnum::SEVEN),
                "EIGHT" => ::std::result::Result::Ok(MyBigEnum::EIGHT),
                "NINE" => ::std::result::Result::Ok(MyBigEnum::NINE),
                "TEN" => ::std::result::Result::Ok(MyBigEnum::TEN),
                "ELEVEN" => ::std::result::Result::Ok(MyBigEnum::ELEVEN),
                "TWELVE" => ::std::result::Result::Ok(MyBigEnum::TWELVE),
                "THIRTEEN" => ::std::result::Result::Ok(MyBigEnum::THIRTEEN),
                "FOURTEEN" => ::std::result::Result::Ok(MyBigEnum::FOURTEEN),
                "FIFTEEN" => ::std::result::Result::Ok(MyBigEnum::FIFTEEN),
                "SIXTEEN" => ::std::result::Result::Ok(MyBigEnum::SIXTEEN),
                "SEVENTEEN" => ::std::result::Result::Ok(MyBigEnum::SEVENTEEN),
                "EIGHTEEN" => ::std::result::Result::Ok(MyBigEnum::EIGHTEEN),
                "NINETEEN" => ::std::result::Result::Ok(MyBigEnum::NINETEEN),
                _ => ::anyhow::bail!("Unable to parse {} as MyBigEnum", string),
            }
        }
    }

    impl ::fbthrift::GetTType for MyBigEnum {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for MyBigEnum
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for MyBigEnum
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(MyBigEnum::from(p.read_i32()?))
        }
    }

    impl ::std::default::Default for self::MyStruct {
        fn default() -> Self {
            Self {
                myEnum: ::std::default::Default::default(),
                myBigEnum: crate::types::MyBigEnum::ONE,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MyStruct {}
    unsafe impl ::std::marker::Sync for self::MyStruct {}

    impl ::fbthrift::GetTType for self::MyStruct {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MyStruct
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MyStruct");
            p.write_field_begin("myEnum", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.myEnum, p);
            p.write_field_end();
            p.write_field_begin("myBigEnum", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.myBigEnum, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MyStruct
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_myEnum = ::std::option::Option::None;
            let mut field_myBigEnum = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_myEnum = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_myBigEnum = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                myEnum: field_myEnum.unwrap_or_default(),
                myBigEnum: field_myBigEnum.unwrap_or_else(|| crate::types::MyBigEnum::ONE),
            })
        }
    }

}

pub mod errors {
}

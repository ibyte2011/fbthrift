#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.bytes cimport PyBytes_AsStringAndSize
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from libcpp.utility cimport move as cmove
from cpython cimport bool as pbool
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types cimport (
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    constant_shared_ptr,
    default_inst,
    NOTSET as __NOTSET,
    EnumData as __EnumData,
    EnumFlagsData as __EnumFlagsData,
    UnionTypeEnumData as __UnionTypeEnumData,
    createEnumDataForUnionType as __createEnumDataForUnionType,
)
cimport thrift.py3.std_libcpp as std_libcpp
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
import weakref as __weakref
import builtins as _builtins

cimport module.types_reflection as _types_reflection


cdef __EnumData __AnEnum_enum_data  = __EnumData.create(thrift.py3.types.createEnumData[cAnEnum](), AnEnum)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __AnEnumMeta(thrift.py3.types.EnumMeta):

    def __get_by_name(cls, str name):
        return __AnEnum_enum_data.get_by_name(name)

    def __get_by_value(cls, int value):
        return __AnEnum_enum_data.get_by_value(value)

    def __get_all_names(cls):
        return __AnEnum_enum_data.get_all_names()

    def __len__(cls):
        return __AnEnum_enum_data.size()


@__cython.final
@__cython.auto_pickle(False)
cdef class AnEnum(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __AnEnum_enum_data.get_by_name(name)



__SetMetaClass(<PyTypeObject*> AnEnum, <PyTypeObject*> __AnEnumMeta)


cdef __EnumFlagsData __Flags_enum_data  = __EnumFlagsData.create(thrift.py3.types.createEnumFlagsData[cFlags](), Flags)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __FlagsMeta(thrift.py3.types.EnumMeta):

    def __get_by_name(cls, str name):
        return __Flags_enum_data.get_by_name(name)

    def __get_by_value(cls, int value):
        return __Flags_enum_data.get_by_value(value)

    def __get_all_names(cls):
        return __Flags_enum_data.get_all_names()

    def __len__(cls):
        return __Flags_enum_data.size()


@__cython.final
@__cython.auto_pickle(False)
cdef class Flags(thrift.py3.types.Flag):
    cdef get_by_name(self, str name):
        return __Flags_enum_data.get_by_name(name)


    def __invert__(self):
        return __Flags_enum_data.get_invert(self.value)


__SetMetaClass(<PyTypeObject*> Flags, <PyTypeObject*> __FlagsMeta)



cdef __UnionTypeEnumData __BinaryUnion_union_type_enum_data  = __UnionTypeEnumData.create(
    __createEnumDataForUnionType[cBinaryUnion](),
    __BinaryUnionType,
)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __BinaryUnion_Union_TypeMeta(thrift.py3.types.EnumMeta):

    def __get_by_name(cls, str name):
        return __BinaryUnion_union_type_enum_data.get_by_name(name)

    def __get_by_value(cls, int value):
        return __BinaryUnion_union_type_enum_data.get_by_value(value)

    def __get_all_names(cls):
        return __BinaryUnion_union_type_enum_data.get_all_names()

    def __len__(cls):
        return __BinaryUnion_union_type_enum_data.size()


@__cython.final
@__cython.auto_pickle(False)
cdef class __BinaryUnionType(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __BinaryUnion_union_type_enum_data.get_by_name(name)


__SetMetaClass(<PyTypeObject*> __BinaryUnionType, <PyTypeObject*> __BinaryUnion_Union_TypeMeta)


@__cython.auto_pickle(False)
cdef class SimpleException(thrift.py3.exceptions.GeneratedError):

    def __init__(
        SimpleException self,
        err_code=None
    ):
        if err_code is not None:
            if not isinstance(err_code, int):
                raise TypeError(f'err_code is not a { int !r}.')
            err_code = <cint16_t> err_code

        self._cpp_obj = __fbthrift_move(SimpleException._make_instance(
          NULL,
          NULL,
          err_code,
        ))
        _builtins.Exception.__init__(self, self.err_code)


    @staticmethod
    cdef unique_ptr[cSimpleException] _make_instance(
        cSimpleException* base_instance,
        bint* __isNOTSET,
        object err_code 
    ) except *:
        cdef unique_ptr[cSimpleException] c_inst
        if base_instance:
            c_inst = make_unique[cSimpleException](deref(base_instance))
        else:
            c_inst = make_unique[cSimpleException]()

        if err_code is not None:
            deref(c_inst).err_code_ref().assign(err_code)
            deref(c_inst).__isset.err_code = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return __fbthrift_move_unique(c_inst)

    cdef object __fbthrift_isset(self):
        cpp_obj = deref(self._cpp_obj)
        return thrift.py3.types._IsSet("SimpleException", {
          "err_code": cpp_obj.err_code_ref().has_value(),
        })

    def __iter__(self):
        yield 'err_code', self.err_code

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cSimpleException] cpp_obj):
        __fbthrift_inst = <SimpleException>SimpleException.__new__(SimpleException, (<bytes>deref(cpp_obj).what()).decode('utf-8'))
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(cpp_obj)
        _builtins.Exception.__init__(__fbthrift_inst, __fbthrift_inst.err_code)
        return __fbthrift_inst

    @property
    def err_code(self):

        return deref(self._cpp_obj).err_code_ref().value()


    def __hash__(SimpleException self):
        return super().__hash__()

    def __repr__(SimpleException self):
        return f'SimpleException(err_code={repr(self.err_code)})'
    def __copy__(SimpleException self):
        cdef shared_ptr[cSimpleException] cpp_obj = make_shared[cSimpleException](
            deref(self._cpp_obj)
        )
        return SimpleException.create(__fbthrift_move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, SimpleException) and
                isinstance(other, SimpleException)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cSimpleException* cself = (<SimpleException>self)._cpp_obj.get()
        cdef cSimpleException* cother = (<SimpleException>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__SimpleException()



@__cython.auto_pickle(False)
cdef class OptionalRefStruct(thrift.py3.types.Struct):

    def __init__(
        OptionalRefStruct self, *,
        __iobuf.IOBuf optional_blob=None
    ):
        self._cpp_obj = __fbthrift_move(OptionalRefStruct._make_instance(
          NULL,
          NULL,
          optional_blob,
        ))

    def __call__(
        OptionalRefStruct self,
        optional_blob=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[1] __isNOTSET  # so make_instance is typed

        __fbthrift_changed = False
        if optional_blob is ___NOTSET:
            __isNOTSET[0] = True
            optional_blob = None
        else:
            __isNOTSET[0] = False
            __fbthrift_changed = True


        if not __fbthrift_changed:
            return self

        if optional_blob is not None:
            if not isinstance(optional_blob, __iobuf.IOBuf):
                raise TypeError(f'optional_blob is not a { __iobuf.IOBuf !r}.')

        __fbthrift_inst = <OptionalRefStruct>OptionalRefStruct.__new__(OptionalRefStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move(OptionalRefStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          optional_blob,
        ))
        return __fbthrift_inst

    @staticmethod
    cdef unique_ptr[cOptionalRefStruct] _make_instance(
        cOptionalRefStruct* base_instance,
        bint* __isNOTSET,
        __iobuf.IOBuf optional_blob 
    ) except *:
        cdef unique_ptr[cOptionalRefStruct] c_inst
        if base_instance:
            c_inst = make_unique[cOptionalRefStruct](deref(base_instance))
        else:
            c_inst = make_unique[cOptionalRefStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and optional_blob is None:
                deref(c_inst).__isset.optional_blob = False
                deref(c_inst).optional_blob.reset()
                pass

        if optional_blob is not None:
            deref(c_inst).optional_blob = (<__iobuf.IOBuf?>optional_blob).c_clone()
            deref(c_inst).__isset.optional_blob = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return __fbthrift_move_unique(c_inst)

    cdef object __fbthrift_isset(self):
        cpp_obj = deref(self._cpp_obj)
        return thrift.py3.types._IsSet("OptionalRefStruct", {
        })

    def __iter__(self):
        yield 'optional_blob', self.optional_blob

    def __bool__(self):
        return (deref(self._cpp_obj).__isset.optional_blob and <bint>(deref(self._cpp_obj).optional_blob))

    @staticmethod
    cdef create(shared_ptr[cOptionalRefStruct] cpp_obj):
        __fbthrift_inst = <OptionalRefStruct>OptionalRefStruct.__new__(OptionalRefStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(cpp_obj)
        return __fbthrift_inst

    @property
    def optional_blob(self):
        if not deref(self._cpp_obj).__isset.optional_blob:
            return None

        if self.__field_optional_blob is None:
            if not deref(self._cpp_obj).optional_blob:
                return None
            self.__field_optional_blob = __iobuf.IOBuf.create(deref(self._cpp_obj).optional_blob.get(), self)
        return self.__field_optional_blob


    def __hash__(OptionalRefStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.optional_blob,
            ))
        return self.__hash

    def __repr__(OptionalRefStruct self):
        return f'OptionalRefStruct(optional_blob={repr(self.optional_blob)})'
    def __copy__(OptionalRefStruct self):
        cdef shared_ptr[cOptionalRefStruct] cpp_obj = make_shared[cOptionalRefStruct](
            deref(self._cpp_obj)
        )
        return OptionalRefStruct.create(__fbthrift_move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, OptionalRefStruct) and
                isinstance(other, OptionalRefStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cOptionalRefStruct* cself = (<OptionalRefStruct>self)._cpp_obj.get()
        cdef cOptionalRefStruct* cother = (<OptionalRefStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__OptionalRefStruct()

    cdef __iobuf.IOBuf _serialize(OptionalRefStruct self, __Protocol proto):
        return __iobuf.from_unique_ptr(
            serializer.cserialize[cOptionalRefStruct](self._cpp_obj.get(), proto).move()
        )

    cdef cuint32_t _deserialize(OptionalRefStruct self, const __iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cOptionalRefStruct]()
        needed = serializer.cdeserialize[cOptionalRefStruct](buf, self._cpp_obj.get(), proto)
        return needed

    def __reduce__(self):
        return (deserialize, (OptionalRefStruct, serialize(self)))


@__cython.auto_pickle(False)
cdef class SimpleStruct(thrift.py3.types.Struct):

    def __init__(
        SimpleStruct self, *,
        pbool is_on=None,
        tiny_int=None,
        small_int=None,
        nice_sized_int=None,
        big_int=None,
        real=None,
        smaller_real=None
    ):
        if tiny_int is not None:
            if not isinstance(tiny_int, int):
                raise TypeError(f'tiny_int is not a { int !r}.')
            tiny_int = <cint8_t> tiny_int

        if small_int is not None:
            if not isinstance(small_int, int):
                raise TypeError(f'small_int is not a { int !r}.')
            small_int = <cint16_t> small_int

        if nice_sized_int is not None:
            if not isinstance(nice_sized_int, int):
                raise TypeError(f'nice_sized_int is not a { int !r}.')
            nice_sized_int = <cint32_t> nice_sized_int

        if big_int is not None:
            if not isinstance(big_int, int):
                raise TypeError(f'big_int is not a { int !r}.')
            big_int = <cint64_t> big_int

        if real is not None:
            if not isinstance(real, (float, int)):
                raise TypeError(f'real is not a { float !r}.')

        if smaller_real is not None:
            if not isinstance(smaller_real, (float, int)):
                raise TypeError(f'smaller_real is not a { float !r}.')

        self._cpp_obj = __fbthrift_move(SimpleStruct._make_instance(
          NULL,
          NULL,
          is_on,
          tiny_int,
          small_int,
          nice_sized_int,
          big_int,
          real,
          smaller_real,
        ))

    def __call__(
        SimpleStruct self,
        is_on=__NOTSET,
        tiny_int=__NOTSET,
        small_int=__NOTSET,
        nice_sized_int=__NOTSET,
        big_int=__NOTSET,
        real=__NOTSET,
        smaller_real=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[7] __isNOTSET  # so make_instance is typed

        __fbthrift_changed = False
        if is_on is ___NOTSET:
            __isNOTSET[0] = True
            is_on = None
        else:
            __isNOTSET[0] = False
            __fbthrift_changed = True

        if tiny_int is ___NOTSET:
            __isNOTSET[1] = True
            tiny_int = None
        else:
            __isNOTSET[1] = False
            __fbthrift_changed = True

        if small_int is ___NOTSET:
            __isNOTSET[2] = True
            small_int = None
        else:
            __isNOTSET[2] = False
            __fbthrift_changed = True

        if nice_sized_int is ___NOTSET:
            __isNOTSET[3] = True
            nice_sized_int = None
        else:
            __isNOTSET[3] = False
            __fbthrift_changed = True

        if big_int is ___NOTSET:
            __isNOTSET[4] = True
            big_int = None
        else:
            __isNOTSET[4] = False
            __fbthrift_changed = True

        if real is ___NOTSET:
            __isNOTSET[5] = True
            real = None
        else:
            __isNOTSET[5] = False
            __fbthrift_changed = True

        if smaller_real is ___NOTSET:
            __isNOTSET[6] = True
            smaller_real = None
        else:
            __isNOTSET[6] = False
            __fbthrift_changed = True


        if not __fbthrift_changed:
            return self

        if is_on is not None:
            if not isinstance(is_on, bool):
                raise TypeError(f'is_on is not a { bool !r}.')

        if tiny_int is not None:
            if not isinstance(tiny_int, int):
                raise TypeError(f'tiny_int is not a { int !r}.')
            tiny_int = <cint8_t> tiny_int

        if small_int is not None:
            if not isinstance(small_int, int):
                raise TypeError(f'small_int is not a { int !r}.')
            small_int = <cint16_t> small_int

        if nice_sized_int is not None:
            if not isinstance(nice_sized_int, int):
                raise TypeError(f'nice_sized_int is not a { int !r}.')
            nice_sized_int = <cint32_t> nice_sized_int

        if big_int is not None:
            if not isinstance(big_int, int):
                raise TypeError(f'big_int is not a { int !r}.')
            big_int = <cint64_t> big_int

        if real is not None:
            if not isinstance(real, (float, int)):
                raise TypeError(f'real is not a { float !r}.')

        if smaller_real is not None:
            if not isinstance(smaller_real, (float, int)):
                raise TypeError(f'smaller_real is not a { float !r}.')

        __fbthrift_inst = <SimpleStruct>SimpleStruct.__new__(SimpleStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move(SimpleStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          is_on,
          tiny_int,
          small_int,
          nice_sized_int,
          big_int,
          real,
          smaller_real,
        ))
        return __fbthrift_inst

    @staticmethod
    cdef unique_ptr[cSimpleStruct] _make_instance(
        cSimpleStruct* base_instance,
        bint* __isNOTSET,
        pbool is_on ,
        object tiny_int ,
        object small_int ,
        object nice_sized_int ,
        object big_int ,
        object real ,
        object smaller_real 
    ) except *:
        cdef unique_ptr[cSimpleStruct] c_inst
        if base_instance:
            c_inst = make_unique[cSimpleStruct](deref(base_instance))
        else:
            c_inst = make_unique[cSimpleStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and is_on is None:
                deref(c_inst).is_on_ref().assign(default_inst[cSimpleStruct]().is_on_ref().value())
                deref(c_inst).__isset.is_on = False
                pass

            if not __isNOTSET[1] and tiny_int is None:
                deref(c_inst).tiny_int_ref().assign(default_inst[cSimpleStruct]().tiny_int_ref().value())
                deref(c_inst).__isset.tiny_int = False
                pass

            if not __isNOTSET[2] and small_int is None:
                deref(c_inst).small_int_ref().assign(default_inst[cSimpleStruct]().small_int_ref().value())
                deref(c_inst).__isset.small_int = False
                pass

            if not __isNOTSET[3] and nice_sized_int is None:
                deref(c_inst).nice_sized_int_ref().assign(default_inst[cSimpleStruct]().nice_sized_int_ref().value())
                deref(c_inst).__isset.nice_sized_int = False
                pass

            if not __isNOTSET[4] and big_int is None:
                deref(c_inst).big_int_ref().assign(default_inst[cSimpleStruct]().big_int_ref().value())
                deref(c_inst).__isset.big_int = False
                pass

            if not __isNOTSET[5] and real is None:
                deref(c_inst).real_ref().assign(default_inst[cSimpleStruct]().real_ref().value())
                deref(c_inst).__isset.real = False
                pass

            if not __isNOTSET[6] and smaller_real is None:
                deref(c_inst).smaller_real_ref().assign(default_inst[cSimpleStruct]().smaller_real_ref().value())
                deref(c_inst).__isset.smaller_real = False
                pass

        if is_on is not None:
            deref(c_inst).is_on_ref().assign(is_on)
            deref(c_inst).__isset.is_on = True
        if tiny_int is not None:
            deref(c_inst).tiny_int_ref().assign(tiny_int)
            deref(c_inst).__isset.tiny_int = True
        if small_int is not None:
            deref(c_inst).small_int_ref().assign(small_int)
            deref(c_inst).__isset.small_int = True
        if nice_sized_int is not None:
            deref(c_inst).nice_sized_int_ref().assign(nice_sized_int)
            deref(c_inst).__isset.nice_sized_int = True
        if big_int is not None:
            deref(c_inst).big_int_ref().assign(big_int)
            deref(c_inst).__isset.big_int = True
        if real is not None:
            deref(c_inst).real_ref().assign(real)
            deref(c_inst).__isset.real = True
        if smaller_real is not None:
            deref(c_inst).smaller_real_ref().assign(smaller_real)
            deref(c_inst).__isset.smaller_real = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return __fbthrift_move_unique(c_inst)

    cdef object __fbthrift_isset(self):
        cpp_obj = deref(self._cpp_obj)
        return thrift.py3.types._IsSet("SimpleStruct", {
          "is_on": cpp_obj.is_on_ref().has_value(),
          "tiny_int": cpp_obj.tiny_int_ref().has_value(),
          "small_int": cpp_obj.small_int_ref().has_value(),
          "nice_sized_int": cpp_obj.nice_sized_int_ref().has_value(),
          "big_int": cpp_obj.big_int_ref().has_value(),
          "real": cpp_obj.real_ref().has_value(),
          "smaller_real": cpp_obj.smaller_real_ref().has_value(),
        })

    def __iter__(self):
        yield 'is_on', self.is_on
        yield 'tiny_int', self.tiny_int
        yield 'small_int', self.small_int
        yield 'nice_sized_int', self.nice_sized_int
        yield 'big_int', self.big_int
        yield 'real', self.real
        yield 'smaller_real', self.smaller_real

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cSimpleStruct] cpp_obj):
        __fbthrift_inst = <SimpleStruct>SimpleStruct.__new__(SimpleStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(cpp_obj)
        return __fbthrift_inst

    @property
    def is_on(self):

        return <pbool> deref(self._cpp_obj).is_on_ref().value()

    @property
    def tiny_int(self):

        return deref(self._cpp_obj).tiny_int_ref().value()

    @property
    def small_int(self):

        return deref(self._cpp_obj).small_int_ref().value()

    @property
    def nice_sized_int(self):

        return deref(self._cpp_obj).nice_sized_int_ref().value()

    @property
    def big_int(self):

        return deref(self._cpp_obj).big_int_ref().value()

    @property
    def real(self):

        return deref(self._cpp_obj).real_ref().value()

    @property
    def smaller_real(self):

        return deref(self._cpp_obj).smaller_real_ref().value()


    def __hash__(SimpleStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.is_on,
            self.tiny_int,
            self.small_int,
            self.nice_sized_int,
            self.big_int,
            self.real,
            self.smaller_real,
            ))
        return self.__hash

    def __repr__(SimpleStruct self):
        return f'SimpleStruct(is_on={repr(self.is_on)}, tiny_int={repr(self.tiny_int)}, small_int={repr(self.small_int)}, nice_sized_int={repr(self.nice_sized_int)}, big_int={repr(self.big_int)}, real={repr(self.real)}, smaller_real={repr(self.smaller_real)})'
    def __copy__(SimpleStruct self):
        cdef shared_ptr[cSimpleStruct] cpp_obj = make_shared[cSimpleStruct](
            deref(self._cpp_obj)
        )
        return SimpleStruct.create(__fbthrift_move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, SimpleStruct) and
                isinstance(other, SimpleStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cSimpleStruct* cself = (<SimpleStruct>self)._cpp_obj.get()
        cdef cSimpleStruct* cother = (<SimpleStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__SimpleStruct()

    cdef __iobuf.IOBuf _serialize(SimpleStruct self, __Protocol proto):
        return __iobuf.from_unique_ptr(
            serializer.cserialize[cSimpleStruct](self._cpp_obj.get(), proto).move()
        )

    cdef cuint32_t _deserialize(SimpleStruct self, const __iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cSimpleStruct]()
        needed = serializer.cdeserialize[cSimpleStruct](buf, self._cpp_obj.get(), proto)
        return needed

    def __reduce__(self):
        return (deserialize, (SimpleStruct, serialize(self)))


@__cython.auto_pickle(False)
cdef class ComplexStruct(thrift.py3.types.Struct):

    def __init__(
        ComplexStruct self, *,
        SimpleStruct structOne=None,
        SimpleStruct structTwo=None,
        an_integer=None,
        str name=None,
        AnEnum an_enum=None,
        bytes some_bytes=None,
        str sender=None,
        str cdef_=None,
        bytes bytes_with_cpp_type=None
    ):
        if an_integer is not None:
            if not isinstance(an_integer, int):
                raise TypeError(f'an_integer is not a { int !r}.')
            an_integer = <cint32_t> an_integer

        self._cpp_obj = __fbthrift_move(ComplexStruct._make_instance(
          NULL,
          NULL,
          structOne,
          structTwo,
          an_integer,
          name,
          an_enum,
          some_bytes,
          sender,
          cdef_,
          bytes_with_cpp_type,
        ))

    def __call__(
        ComplexStruct self,
        structOne=__NOTSET,
        structTwo=__NOTSET,
        an_integer=__NOTSET,
        name=__NOTSET,
        an_enum=__NOTSET,
        some_bytes=__NOTSET,
        sender=__NOTSET,
        cdef_=__NOTSET,
        bytes_with_cpp_type=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[9] __isNOTSET  # so make_instance is typed

        __fbthrift_changed = False
        if structOne is ___NOTSET:
            __isNOTSET[0] = True
            structOne = None
        else:
            __isNOTSET[0] = False
            __fbthrift_changed = True

        if structTwo is ___NOTSET:
            __isNOTSET[1] = True
            structTwo = None
        else:
            __isNOTSET[1] = False
            __fbthrift_changed = True

        if an_integer is ___NOTSET:
            __isNOTSET[2] = True
            an_integer = None
        else:
            __isNOTSET[2] = False
            __fbthrift_changed = True

        if name is ___NOTSET:
            __isNOTSET[3] = True
            name = None
        else:
            __isNOTSET[3] = False
            __fbthrift_changed = True

        if an_enum is ___NOTSET:
            __isNOTSET[4] = True
            an_enum = None
        else:
            __isNOTSET[4] = False
            __fbthrift_changed = True

        if some_bytes is ___NOTSET:
            __isNOTSET[5] = True
            some_bytes = None
        else:
            __isNOTSET[5] = False
            __fbthrift_changed = True

        if sender is ___NOTSET:
            __isNOTSET[6] = True
            sender = None
        else:
            __isNOTSET[6] = False
            __fbthrift_changed = True

        if cdef_ is ___NOTSET:
            __isNOTSET[7] = True
            cdef_ = None
        else:
            __isNOTSET[7] = False
            __fbthrift_changed = True

        if bytes_with_cpp_type is ___NOTSET:
            __isNOTSET[8] = True
            bytes_with_cpp_type = None
        else:
            __isNOTSET[8] = False
            __fbthrift_changed = True


        if not __fbthrift_changed:
            return self

        if structOne is not None:
            if not isinstance(structOne, SimpleStruct):
                raise TypeError(f'structOne is not a { SimpleStruct !r}.')

        if structTwo is not None:
            if not isinstance(structTwo, SimpleStruct):
                raise TypeError(f'structTwo is not a { SimpleStruct !r}.')

        if an_integer is not None:
            if not isinstance(an_integer, int):
                raise TypeError(f'an_integer is not a { int !r}.')
            an_integer = <cint32_t> an_integer

        if name is not None:
            if not isinstance(name, str):
                raise TypeError(f'name is not a { str !r}.')

        if an_enum is not None:
            if not isinstance(an_enum, AnEnum):
                raise TypeError(f'field an_enum value: { an_enum !r} is not of the enum type { AnEnum }.')

        if some_bytes is not None:
            if not isinstance(some_bytes, bytes):
                raise TypeError(f'some_bytes is not a { bytes !r}.')

        if sender is not None:
            if not isinstance(sender, str):
                raise TypeError(f'sender is not a { str !r}.')

        if cdef_ is not None:
            if not isinstance(cdef_, str):
                raise TypeError(f'cdef_ is not a { str !r}.')

        if bytes_with_cpp_type is not None:
            if not isinstance(bytes_with_cpp_type, bytes):
                raise TypeError(f'bytes_with_cpp_type is not a { bytes !r}.')

        __fbthrift_inst = <ComplexStruct>ComplexStruct.__new__(ComplexStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move(ComplexStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          structOne,
          structTwo,
          an_integer,
          name,
          an_enum,
          some_bytes,
          sender,
          cdef_,
          bytes_with_cpp_type,
        ))
        return __fbthrift_inst

    @staticmethod
    cdef unique_ptr[cComplexStruct] _make_instance(
        cComplexStruct* base_instance,
        bint* __isNOTSET,
        SimpleStruct structOne ,
        SimpleStruct structTwo ,
        object an_integer ,
        str name ,
        AnEnum an_enum ,
        bytes some_bytes ,
        str sender ,
        str cdef_ ,
        bytes bytes_with_cpp_type 
    ) except *:
        cdef unique_ptr[cComplexStruct] c_inst
        if base_instance:
            c_inst = make_unique[cComplexStruct](deref(base_instance))
        else:
            c_inst = make_unique[cComplexStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and structOne is None:
                deref(c_inst).structOne_ref().assign(default_inst[cComplexStruct]().structOne_ref().value())
                deref(c_inst).__isset.structOne = False
                pass

            if not __isNOTSET[1] and structTwo is None:
                deref(c_inst).structTwo_ref().assign(default_inst[cComplexStruct]().structTwo_ref().value())
                deref(c_inst).__isset.structTwo = False
                pass

            if not __isNOTSET[2] and an_integer is None:
                deref(c_inst).an_integer_ref().assign(default_inst[cComplexStruct]().an_integer_ref().value())
                deref(c_inst).__isset.an_integer = False
                pass

            if not __isNOTSET[3] and name is None:
                deref(c_inst).name_ref().assign(default_inst[cComplexStruct]().name_ref().value())
                deref(c_inst).__isset.name = False
                pass

            if not __isNOTSET[4] and an_enum is None:
                deref(c_inst).an_enum_ref().assign(default_inst[cComplexStruct]().an_enum_ref().value())
                deref(c_inst).__isset.an_enum = False
                pass

            if not __isNOTSET[5] and some_bytes is None:
                deref(c_inst).some_bytes_ref().assign(default_inst[cComplexStruct]().some_bytes_ref().value())
                deref(c_inst).__isset.some_bytes = False
                pass

            if not __isNOTSET[6] and sender is None:
                deref(c_inst).sender_ref().assign(default_inst[cComplexStruct]().sender_ref().value())
                deref(c_inst).__isset.sender = False
                pass

            if not __isNOTSET[7] and cdef_ is None:
                deref(c_inst).cdef__ref().assign(default_inst[cComplexStruct]().cdef__ref().value())
                deref(c_inst).__isset.cdef_ = False
                pass

            if not __isNOTSET[8] and bytes_with_cpp_type is None:
                deref(c_inst).bytes_with_cpp_type_ref().assign(default_inst[cComplexStruct]().bytes_with_cpp_type_ref().value())
                deref(c_inst).__isset.bytes_with_cpp_type = False
                pass

        if structOne is not None:
            deref(c_inst).structOne_ref().assign(deref((<SimpleStruct?> structOne)._cpp_obj))
            deref(c_inst).__isset.structOne = True
        if structTwo is not None:
            deref(c_inst).structTwo_ref().assign(deref((<SimpleStruct?> structTwo)._cpp_obj))
            deref(c_inst).__isset.structTwo = True
        if an_integer is not None:
            deref(c_inst).an_integer_ref().assign(an_integer)
            deref(c_inst).__isset.an_integer = True
        if name is not None:
            deref(c_inst).name_ref().assign(thrift.py3.types.move(thrift.py3.types.bytes_to_string(name.encode('utf-8'))))
            deref(c_inst).__isset.name = True
        if an_enum is not None:
            deref(c_inst).an_enum_ref().assign(<cAnEnum><int>an_enum)
            deref(c_inst).__isset.an_enum = True
        if some_bytes is not None:
            deref(c_inst).some_bytes_ref().assign(thrift.py3.types.move(thrift.py3.types.bytes_to_string(some_bytes)))
            deref(c_inst).__isset.some_bytes = True
        if sender is not None:
            deref(c_inst).sender_ref().assign(thrift.py3.types.move(thrift.py3.types.bytes_to_string(sender.encode('utf-8'))))
            deref(c_inst).__isset.sender = True
        if cdef_ is not None:
            deref(c_inst).cdef__ref().assign(thrift.py3.types.move(thrift.py3.types.bytes_to_string(cdef_.encode('utf-8'))))
            deref(c_inst).__isset.cdef_ = True
        if bytes_with_cpp_type is not None:
            deref(c_inst).bytes_with_cpp_type_ref().assign(foo_Bar(move(<string>bytes_with_cpp_type)))
            deref(c_inst).__isset.bytes_with_cpp_type = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return __fbthrift_move_unique(c_inst)

    cdef object __fbthrift_isset(self):
        cpp_obj = deref(self._cpp_obj)
        return thrift.py3.types._IsSet("ComplexStruct", {
          "structOne": cpp_obj.structOne_ref().has_value(),
          "structTwo": cpp_obj.structTwo_ref().has_value(),
          "an_integer": cpp_obj.an_integer_ref().has_value(),
          "name": cpp_obj.name_ref().has_value(),
          "an_enum": cpp_obj.an_enum_ref().has_value(),
          "some_bytes": cpp_obj.some_bytes_ref().has_value(),
          "sender": cpp_obj.sender_ref().has_value(),
          "cdef_": cpp_obj.cdef__ref().has_value(),
          "bytes_with_cpp_type": cpp_obj.bytes_with_cpp_type_ref().has_value(),
        })

    def __iter__(self):
        yield 'structOne', self.structOne
        yield 'structTwo', self.structTwo
        yield 'an_integer', self.an_integer
        yield 'name', self.name
        yield 'an_enum', self.an_enum
        yield 'some_bytes', self.some_bytes
        yield 'sender', self.sender
        yield 'cdef_', self.cdef_
        yield 'bytes_with_cpp_type', self.bytes_with_cpp_type

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cComplexStruct] cpp_obj):
        __fbthrift_inst = <ComplexStruct>ComplexStruct.__new__(ComplexStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(cpp_obj)
        return __fbthrift_inst

    @property
    def structOne(self):

        if self.__field_structOne is None:
            self.__field_structOne = SimpleStruct.create(reference_shared_ptr_structOne(self._cpp_obj, deref(self._cpp_obj).structOne_ref().value()))
        return self.__field_structOne

    @property
    def structTwo(self):

        if self.__field_structTwo is None:
            self.__field_structTwo = SimpleStruct.create(reference_shared_ptr_structTwo(self._cpp_obj, deref(self._cpp_obj).structTwo_ref().value()))
        return self.__field_structTwo

    @property
    def an_integer(self):

        return deref(self._cpp_obj).an_integer_ref().value()

    @property
    def name(self):

        return (<bytes>deref(self._cpp_obj).name_ref().value()).decode('UTF-8')

    @property
    def an_enum(self):

        return translate_cpp_enum_to_python(AnEnum, <int>(deref(self._cpp_obj).an_enum_ref().value()))

    @property
    def some_bytes(self):

        return deref(self._cpp_obj).some_bytes_ref().value()

    @property
    def sender(self):

        return (<bytes>deref(self._cpp_obj).sender_ref().value()).decode('UTF-8')

    @property
    def cdef_(self):

        return (<bytes>deref(self._cpp_obj).cdef__ref().value()).decode('UTF-8')

    @property
    def bytes_with_cpp_type(self):

        return (<const char*>deref(self._cpp_obj).bytes_with_cpp_type_ref().value().data())[:deref(self._cpp_obj).bytes_with_cpp_type_ref().value().size()]


    def __hash__(ComplexStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.structOne,
            self.structTwo,
            self.an_integer,
            self.name,
            self.an_enum,
            self.some_bytes,
            self.sender,
            self.cdef_,
            self.bytes_with_cpp_type,
            ))
        return self.__hash

    def __repr__(ComplexStruct self):
        return f'ComplexStruct(structOne={repr(self.structOne)}, structTwo={repr(self.structTwo)}, an_integer={repr(self.an_integer)}, name={repr(self.name)}, an_enum={repr(self.an_enum)}, some_bytes={repr(self.some_bytes)}, sender={repr(self.sender)}, cdef_={repr(self.cdef_)}, bytes_with_cpp_type={repr(self.bytes_with_cpp_type)})'
    def __copy__(ComplexStruct self):
        cdef shared_ptr[cComplexStruct] cpp_obj = make_shared[cComplexStruct](
            deref(self._cpp_obj)
        )
        return ComplexStruct.create(__fbthrift_move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, ComplexStruct) and
                isinstance(other, ComplexStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cComplexStruct* cself = (<ComplexStruct>self)._cpp_obj.get()
        cdef cComplexStruct* cother = (<ComplexStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__ComplexStruct()

    cdef __iobuf.IOBuf _serialize(ComplexStruct self, __Protocol proto):
        return __iobuf.from_unique_ptr(
            serializer.cserialize[cComplexStruct](self._cpp_obj.get(), proto).move()
        )

    cdef cuint32_t _deserialize(ComplexStruct self, const __iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cComplexStruct]()
        needed = serializer.cdeserialize[cComplexStruct](buf, self._cpp_obj.get(), proto)
        return needed

    def __reduce__(self):
        return (deserialize, (ComplexStruct, serialize(self)))




@__cython.auto_pickle(False)
cdef class BinaryUnion(thrift.py3.types.Union):
    Type = __BinaryUnionType

    def __init__(
        self, *,
        __iobuf.IOBuf iobuf_val=None
    ):
        self._cpp_obj = __fbthrift_move(BinaryUnion._make_instance(
          NULL,
          iobuf_val,
        ))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return BinaryUnion()
        if isinstance(value, __iobuf.IOBuf):
            return BinaryUnion(iobuf_val=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cBinaryUnion] _make_instance(
        cBinaryUnion* base_instance,
        __iobuf.IOBuf iobuf_val
    ) except *:
        cdef unique_ptr[cBinaryUnion] c_inst = make_unique[cBinaryUnion]()
        cdef bint any_set = False
        if iobuf_val is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_iobuf_val(deref((<__iobuf.IOBuf?>iobuf_val).c_clone().release())) 
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return __fbthrift_move_unique(c_inst)

    def __bool__(self):
        return self.type is not __BinaryUnionType.EMPTY

    @staticmethod
    cdef create(shared_ptr[cBinaryUnion] cpp_obj):
        __fbthrift_inst = <BinaryUnion>BinaryUnion.__new__(BinaryUnion)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(cpp_obj)
        __fbthrift_inst._load_cache()
        return __fbthrift_inst

    @property
    def iobuf_val(self):
        if self.type.value != 1:
            raise TypeError(f'Union contains a value of type {self.type.name}, not iobuf_val')
        return self.value


    def __hash__(BinaryUnion self):
        if not self.__hash:
            self.__hash = hash((
                self.type,
                self.value,
            ))
        return self.__hash

    cdef __BinaryUnion_eq(BinaryUnion self, BinaryUnion other):
        return self.type == other.type and self.value == other.value

    def __repr__(BinaryUnion self):
        return f'BinaryUnion(type={self.type.name}, value={self.value!r})'

    cdef _load_cache(BinaryUnion self):
        self.type = BinaryUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value =  __iobuf.from_unique_ptr(deref(self._cpp_obj).get_iobuf_val().clone())

    def get_type(BinaryUnion self):
        return self.type

    def __copy__(BinaryUnion self):
        cdef shared_ptr[cBinaryUnion] cpp_obj = make_shared[cBinaryUnion](
            deref(self._cpp_obj)
        )
        return BinaryUnion.create(__fbthrift_move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, BinaryUnion) and
                isinstance(other, BinaryUnion)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        if cop == Py_EQ:
            return self.__BinaryUnion_eq(other)
        elif cop == Py_NE:
            return not self.__BinaryUnion_eq(other)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__BinaryUnion()

    cdef __iobuf.IOBuf _serialize(BinaryUnion self, __Protocol proto):
        return __iobuf.from_unique_ptr(
            serializer.cserialize[cBinaryUnion](self._cpp_obj.get(), proto).move()
        )

    cdef cuint32_t _deserialize(BinaryUnion self, const __iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cBinaryUnion]()
        needed = serializer.cdeserialize[cBinaryUnion](buf, self._cpp_obj.get(), proto)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (BinaryUnion, serialize(self)))


@__cython.auto_pickle(False)
cdef class BinaryUnionStruct(thrift.py3.types.Struct):

    def __init__(
        BinaryUnionStruct self, *,
        BinaryUnion u=None
    ):
        self._cpp_obj = __fbthrift_move(BinaryUnionStruct._make_instance(
          NULL,
          NULL,
          u,
        ))

    def __call__(
        BinaryUnionStruct self,
        u=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[1] __isNOTSET  # so make_instance is typed

        __fbthrift_changed = False
        if u is ___NOTSET:
            __isNOTSET[0] = True
            u = None
        else:
            __isNOTSET[0] = False
            __fbthrift_changed = True


        if not __fbthrift_changed:
            return self

        if u is not None:
            if not isinstance(u, BinaryUnion):
                raise TypeError(f'u is not a { BinaryUnion !r}.')

        __fbthrift_inst = <BinaryUnionStruct>BinaryUnionStruct.__new__(BinaryUnionStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move(BinaryUnionStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          u,
        ))
        return __fbthrift_inst

    @staticmethod
    cdef unique_ptr[cBinaryUnionStruct] _make_instance(
        cBinaryUnionStruct* base_instance,
        bint* __isNOTSET,
        BinaryUnion u 
    ) except *:
        cdef unique_ptr[cBinaryUnionStruct] c_inst
        if base_instance:
            c_inst = make_unique[cBinaryUnionStruct](deref(base_instance))
        else:
            c_inst = make_unique[cBinaryUnionStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and u is None:
                deref(c_inst).u_ref().assign(default_inst[cBinaryUnionStruct]().u_ref().value())
                deref(c_inst).__isset.u = False
                pass

        if u is not None:
            deref(c_inst).u_ref().assign(deref((<BinaryUnion?> u)._cpp_obj))
            deref(c_inst).__isset.u = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return __fbthrift_move_unique(c_inst)

    cdef object __fbthrift_isset(self):
        cpp_obj = deref(self._cpp_obj)
        return thrift.py3.types._IsSet("BinaryUnionStruct", {
          "u": cpp_obj.u_ref().has_value(),
        })

    def __iter__(self):
        yield 'u', self.u

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cBinaryUnionStruct] cpp_obj):
        __fbthrift_inst = <BinaryUnionStruct>BinaryUnionStruct.__new__(BinaryUnionStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(cpp_obj)
        return __fbthrift_inst

    @property
    def u(self):

        if self.__field_u is None:
            self.__field_u = BinaryUnion.create(reference_shared_ptr_u(self._cpp_obj, deref(self._cpp_obj).u_ref().value()))
        return self.__field_u


    def __hash__(BinaryUnionStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.u,
            ))
        return self.__hash

    cdef __BinaryUnionStruct_eq(BinaryUnionStruct self, BinaryUnionStruct other):
        if self.u != other.u:
            return False
        return True

    def __repr__(BinaryUnionStruct self):
        return f'BinaryUnionStruct(u={repr(self.u)})'
    def __copy__(BinaryUnionStruct self):
        cdef shared_ptr[cBinaryUnionStruct] cpp_obj = make_shared[cBinaryUnionStruct](
            deref(self._cpp_obj)
        )
        return BinaryUnionStruct.create(__fbthrift_move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, BinaryUnionStruct) and
                isinstance(other, BinaryUnionStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        if cop == Py_EQ:
            return self.__BinaryUnionStruct_eq(other)
        elif cop == Py_NE:
            return not self.__BinaryUnionStruct_eq(other)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__BinaryUnionStruct()

    cdef __iobuf.IOBuf _serialize(BinaryUnionStruct self, __Protocol proto):
        return __iobuf.from_unique_ptr(
            serializer.cserialize[cBinaryUnionStruct](self._cpp_obj.get(), proto).move()
        )

    cdef cuint32_t _deserialize(BinaryUnionStruct self, const __iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cBinaryUnionStruct]()
        needed = serializer.cdeserialize[cBinaryUnionStruct](buf, self._cpp_obj.get(), proto)
        return needed

    def __reduce__(self):
        return (deserialize, (BinaryUnionStruct, serialize(self)))


@__cython.auto_pickle(False)
cdef class List__i16(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__i16):
            self._cpp_obj = (<List__i16> items)._cpp_obj
        else:
            self._cpp_obj = List__i16._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cint16_t]] c_items):
        __fbthrift_inst = <List__i16>List__i16.__new__(List__i16)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__i16 self):
        cdef shared_ptr[vector[cint16_t]] cpp_obj = make_shared[vector[cint16_t]](
            deref(self._cpp_obj)
        )
        return List__i16.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cint16_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint16_t]] c_inst = make_shared[vector[cint16_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint16_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cint16_t]] c_inst
        cdef cint16_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cint16_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__i16.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[cint16_t].iterator, cint16_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef cint16_t citem
        cdef vector[cint16_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef cint16_t citem
        cdef vector[cint16_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[cint16_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cint16_t].iterator loc = std_libcpp.find[vector[cint16_t].iterator, cint16_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <cint64_t> std_libcpp.count[vector[cint16_t].iterator, cint16_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__i16()


Sequence.register(List__i16)

@__cython.auto_pickle(False)
cdef class List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cint32_t]] c_items):
        __fbthrift_inst = <List__i32>List__i32.__new__(List__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__i32 self):
        cdef shared_ptr[vector[cint32_t]] cpp_obj = make_shared[vector[cint32_t]](
            deref(self._cpp_obj)
        )
        return List__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint32_t]] c_inst = make_shared[vector[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cint32_t]] c_inst
        cdef cint32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cint32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[cint32_t].iterator, cint32_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef vector[cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef vector[cint32_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[cint32_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cint32_t].iterator loc = std_libcpp.find[vector[cint32_t].iterator, cint32_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <cint64_t> std_libcpp.count[vector[cint32_t].iterator, cint32_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__i32()


Sequence.register(List__i32)

@__cython.auto_pickle(False)
cdef class List__i64(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__i64):
            self._cpp_obj = (<List__i64> items)._cpp_obj
        else:
            self._cpp_obj = List__i64._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cint64_t]] c_items):
        __fbthrift_inst = <List__i64>List__i64.__new__(List__i64)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__i64 self):
        cdef shared_ptr[vector[cint64_t]] cpp_obj = make_shared[vector[cint64_t]](
            deref(self._cpp_obj)
        )
        return List__i64.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cint64_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint64_t]] c_inst = make_shared[vector[cint64_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint64_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cint64_t]] c_inst
        cdef cint64_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cint64_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__i64.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[cint64_t].iterator, cint64_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef cint64_t citem
        cdef vector[cint64_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef cint64_t citem
        cdef vector[cint64_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[cint64_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cint64_t].iterator loc = std_libcpp.find[vector[cint64_t].iterator, cint64_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <cint64_t> std_libcpp.count[vector[cint64_t].iterator, cint64_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__i64()


Sequence.register(List__i64)

@__cython.auto_pickle(False)
cdef class List__string(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._cpp_obj = (<List__string> items)._cpp_obj
        else:
            self._cpp_obj = List__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[string]] c_items):
        __fbthrift_inst = <List__string>List__string.__new__(List__string)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__string self):
        cdef shared_ptr[vector[string]] cpp_obj = make_shared[vector[string]](
            deref(self._cpp_obj)
        )
        return List__string.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[string]] _make_instance(object items) except *:
        cdef shared_ptr[vector[string]] c_inst = make_shared[vector[string]]()
        if items is not None:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.Sequence[str] field, explicitly convert it first.")
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).push_back(item.encode('UTF-8'))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[string]] c_inst
        cdef string citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[string]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__string.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return bytes(citem).decode('UTF-8')

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        return std_libcpp.find[vector[string].iterator, string](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item.encode('UTF-8')) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef vector[string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef string citem
        cdef vector[string].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, str):
            raise err
        cdef vector[string].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[string].iterator loc = std_libcpp.find[vector[string].iterator, string](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item.encode('UTF-8')        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, str):
            return 0
        return <cint64_t> std_libcpp.count[vector[string].iterator, string](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item.encode('UTF-8'))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__string()


Sequence.register(List__string)

@__cython.auto_pickle(False)
cdef class List__SimpleStruct(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__SimpleStruct):
            self._cpp_obj = (<List__SimpleStruct> items)._cpp_obj
        else:
            self._cpp_obj = List__SimpleStruct._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cSimpleStruct]] c_items):
        __fbthrift_inst = <List__SimpleStruct>List__SimpleStruct.__new__(List__SimpleStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__SimpleStruct self):
        cdef shared_ptr[vector[cSimpleStruct]] cpp_obj = make_shared[vector[cSimpleStruct]](
            deref(self._cpp_obj)
        )
        return List__SimpleStruct.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cSimpleStruct]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cSimpleStruct]] c_inst = make_shared[vector[cSimpleStruct]]()
        if items is not None:
            for item in items:
                if not isinstance(item, SimpleStruct):
                    raise TypeError(f"{item!r} is not of type 'SimpleStruct'")
                deref(c_inst).push_back(deref((<SimpleStruct>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cSimpleStruct]] c_inst
        cdef shared_ptr[cSimpleStruct] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cSimpleStruct]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__SimpleStruct.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__SimpleStruct(self._cpp_obj, deref(self._cpp_obj)[index])
            return SimpleStruct.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, SimpleStruct):
            return False
        return std_libcpp.find[vector[cSimpleStruct].iterator, cSimpleStruct](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<SimpleStruct>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cSimpleStruct] citem
        cdef vector[cSimpleStruct].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__SimpleStruct(self._cpp_obj, deref(loc))
            yield SimpleStruct.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cSimpleStruct] citem
        cdef vector[cSimpleStruct].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__SimpleStruct(self._cpp_obj, deref(loc))
            yield SimpleStruct.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, SimpleStruct):
            raise err
        cdef vector[cSimpleStruct].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cSimpleStruct].iterator loc = std_libcpp.find[vector[cSimpleStruct].iterator, cSimpleStruct](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<SimpleStruct>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, SimpleStruct):
            return 0
        return <cint64_t> std_libcpp.count[vector[cSimpleStruct].iterator, cSimpleStruct](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<SimpleStruct>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__SimpleStruct()


Sequence.register(List__SimpleStruct)

@__cython.auto_pickle(False)
cdef class Set__i32(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cint32_t]] c_items):
        __fbthrift_inst = <Set__i32>Set__i32.__new__(Set__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Set__i32 self):
        cdef shared_ptr[cset[cint32_t]] cpp_obj = make_shared[cset[cint32_t]](
            deref(self._cpp_obj)
        )
        return Set__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cint32_t]] c_inst = make_shared[cset[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cset[cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[cint32_t]] cself, cother
        cdef cset[cint32_t].iterator loc
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = (<Set__i32> self)._cpp_obj
            cother = (<Set__i32> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(__fbthrift_move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(__fbthrift_move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(__fbthrift_move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[cint32_t]] shretval = \
            make_shared[cset[cint32_t]]()

        cdef shared_ptr[cset[cint32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[cint32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[cint32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(__fbthrift_move_shared(shretval))


    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__i32()


Set.register(Set__i32)

@__cython.auto_pickle(False)
cdef class Set__string(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._cpp_obj = (<Set__string> items)._cpp_obj
        else:
            self._cpp_obj = Set__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        __fbthrift_inst = <Set__string>Set__string.__new__(Set__string)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Set__string self):
        cdef shared_ptr[cset[string]] cpp_obj = make_shared[cset[string]](
            deref(self._cpp_obj)
        )
        return Set__string.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[string]] _make_instance(object items) except *:
        cdef shared_ptr[cset[string]] c_inst = make_shared[cset[string]]()
        if items is not None:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.AbstractSet[str] field, explicitly convert it first.")
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).insert(item.encode('UTF-8'))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        return pbool(deref(self._cpp_obj).count(item.encode('UTF-8')))


    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cset[string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[string]] cself, cother
        cdef cset[string].iterator loc
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = (<Set__string> self)._cpp_obj
            cother = (<Set__string> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(__fbthrift_move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(__fbthrift_move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(__fbthrift_move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(__fbthrift_move_shared(shretval))


    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__string()


Set.register(Set__string)

@__cython.auto_pickle(False)
cdef class Map__string_string(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_string):
            self._cpp_obj = (<Map__string_string> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,string]] c_items):
        __fbthrift_inst = <Map__string_string>Map__string_string.__new__(Map__string_string)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_string self):
        cdef shared_ptr[cmap[string,string]] cpp_obj = make_shared[cmap[string,string]](
            deref(self._cpp_obj)
        )
        return Map__string_string.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,string]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,string]] c_inst = make_shared[cmap[string,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst)[key.encode('UTF-8')] = item.encode('UTF-8')
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,string].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef string citem
        cdef cmap[string,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey.data().decode('UTF-8'), bytes(citem).decode('UTF-8'))
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_string()


Mapping.register(Map__string_string)

@__cython.auto_pickle(False)
cdef class Map__string_SimpleStruct(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_SimpleStruct):
            self._cpp_obj = (<Map__string_SimpleStruct> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_SimpleStruct._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cSimpleStruct]] c_items):
        __fbthrift_inst = <Map__string_SimpleStruct>Map__string_SimpleStruct.__new__(Map__string_SimpleStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_SimpleStruct self):
        cdef shared_ptr[cmap[string,cSimpleStruct]] cpp_obj = make_shared[cmap[string,cSimpleStruct]](
            deref(self._cpp_obj)
        )
        return Map__string_SimpleStruct.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cSimpleStruct]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cSimpleStruct]] c_inst = make_shared[cmap[string,cSimpleStruct]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, SimpleStruct):
                    raise TypeError(f"{item!r} is not of type 'SimpleStruct'")

                deref(c_inst)[key.encode('UTF-8')] = deref((<SimpleStruct>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cSimpleStruct].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cSimpleStruct] citem = reference_shared_ptr_Map__string_SimpleStruct(self._cpp_obj, deref(iter).second)
        return SimpleStruct.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,cSimpleStruct].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef shared_ptr[cSimpleStruct] citem
        cdef cmap[string,cSimpleStruct].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__string_SimpleStruct(self._cpp_obj, deref(loc).second)
            yield SimpleStruct.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef shared_ptr[cSimpleStruct] citem
        cdef cmap[string,cSimpleStruct].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__string_SimpleStruct(self._cpp_obj, deref(loc).second)
            yield (ckey.data().decode('UTF-8'), SimpleStruct.create(citem))
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_SimpleStruct()


Mapping.register(Map__string_SimpleStruct)

@__cython.auto_pickle(False)
cdef class Map__string_i16(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_i16):
            self._cpp_obj = (<Map__string_i16> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_i16._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cint16_t]] c_items):
        __fbthrift_inst = <Map__string_i16>Map__string_i16.__new__(Map__string_i16)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_i16 self):
        cdef shared_ptr[cmap[string,cint16_t]] cpp_obj = make_shared[cmap[string,cint16_t]](
            deref(self._cpp_obj)
        )
        return Map__string_i16.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cint16_t]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cint16_t]] c_inst = make_shared[cmap[string,cint16_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint16_t> item

                deref(c_inst)[key.encode('UTF-8')] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cint16_t].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef cint16_t citem = deref(iter).second
        return citem

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,cint16_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef cint16_t citem
        cdef cmap[string,cint16_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef cint16_t citem
        cdef cmap[string,cint16_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey.data().decode('UTF-8'), citem)
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_i16()


Mapping.register(Map__string_i16)

@__cython.auto_pickle(False)
cdef class List__List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__List__i32):
            self._cpp_obj = (<List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[cint32_t]]] c_items):
        __fbthrift_inst = <List__List__i32>List__List__i32.__new__(List__List__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__List__i32 self):
        cdef shared_ptr[vector[vector[cint32_t]]] cpp_obj = make_shared[vector[vector[cint32_t]]](
            deref(self._cpp_obj)
        )
        return List__List__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[vector[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[cint32_t]]] c_inst = make_shared[vector[vector[cint32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)
                deref(c_inst).push_back(deref((<List__i32>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[cint32_t]]] c_inst
        cdef shared_ptr[vector[cint32_t]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[cint32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__List__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__List__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return List__i32.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__i32):
            return False
        return std_libcpp.find[vector[vector[cint32_t]].iterator, vector[cint32_t]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[vector[cint32_t]] citem
        cdef vector[vector[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__List__i32(self._cpp_obj, deref(loc))
            yield List__i32.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[vector[cint32_t]] citem
        cdef vector[vector[cint32_t]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__List__i32(self._cpp_obj, deref(loc))
            yield List__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__i32):
            raise err
        cdef vector[vector[cint32_t]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[vector[cint32_t]].iterator loc = std_libcpp.find[vector[vector[cint32_t]].iterator, vector[cint32_t]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<List__i32>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return 0
        if not isinstance(item, List__i32):
            return 0
        return <cint64_t> std_libcpp.count[vector[vector[cint32_t]].iterator, vector[cint32_t]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__i32>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__List__i32()


Sequence.register(List__List__i32)

@__cython.auto_pickle(False)
cdef class Map__string_i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._cpp_obj = (<Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cint32_t]] c_items):
        __fbthrift_inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_i32 self):
        cdef shared_ptr[cmap[string,cint32_t]] cpp_obj = make_shared[cmap[string,cint32_t]](
            deref(self._cpp_obj)
        )
        return Map__string_i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cint32_t]] c_inst = make_shared[cmap[string,cint32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item

                deref(c_inst)[key.encode('UTF-8')] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cint32_t].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef cint32_t citem = deref(iter).second
        return citem

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cmap[string,cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef cint32_t citem
        cdef cmap[string,cint32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey.data().decode('UTF-8'), citem)
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_i32()


Mapping.register(Map__string_i32)

@__cython.auto_pickle(False)
cdef class Map__string_Map__string_i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_i32):
            self._cpp_obj = (<Map__string_Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,cint32_t]]] c_items):
        __fbthrift_inst = <Map__string_Map__string_i32>Map__string_Map__string_i32.__new__(Map__string_Map__string_i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_Map__string_i32 self):
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] cpp_obj = make_shared[cmap[string,cmap[string,cint32_t]]](
            deref(self._cpp_obj)
        )
        return Map__string_Map__string_i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] c_inst = make_shared[cmap[string,cmap[string,cint32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[str, int]")
                if not isinstance(item, Map__string_i32):
                    item = Map__string_i32(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<Map__string_i32>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cmap[string,cint32_t]].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cmap[string,cint32_t]] citem = reference_shared_ptr_Map__string_Map__string_i32(self._cpp_obj, deref(iter).second)
        return Map__string_i32.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,cmap[string,cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef shared_ptr[cmap[string,cint32_t]] citem
        cdef cmap[string,cmap[string,cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__string_Map__string_i32(self._cpp_obj, deref(loc).second)
            yield Map__string_i32.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef shared_ptr[cmap[string,cint32_t]] citem
        cdef cmap[string,cmap[string,cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__string_Map__string_i32(self._cpp_obj, deref(loc).second)
            yield (ckey.data().decode('UTF-8'), Map__string_i32.create(citem))
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_Map__string_i32()


Mapping.register(Map__string_Map__string_i32)

@__cython.auto_pickle(False)
cdef class List__Set__string(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Set__string):
            self._cpp_obj = (<List__Set__string> items)._cpp_obj
        else:
            self._cpp_obj = List__Set__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cset[string]]] c_items):
        __fbthrift_inst = <List__Set__string>List__Set__string.__new__(List__Set__string)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__Set__string self):
        cdef shared_ptr[vector[cset[string]]] cpp_obj = make_shared[vector[cset[string]]](
            deref(self._cpp_obj)
        )
        return List__Set__string.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cset[string]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cset[string]]] c_inst = make_shared[vector[cset[string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[str]")
                if not isinstance(item, Set__string):
                    item = Set__string(item)
                deref(c_inst).push_back(deref((<Set__string>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[string]]] c_inst
        cdef shared_ptr[cset[string]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[string]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Set__string.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Set__string(self._cpp_obj, deref(self._cpp_obj)[index])
            return Set__string.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            return False
        if not isinstance(item, Set__string):
            return False
        return std_libcpp.find[vector[cset[string]].iterator, cset[string]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__string>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cset[string]] citem
        cdef vector[cset[string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Set__string(self._cpp_obj, deref(loc))
            yield Set__string.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cset[string]] citem
        cdef vector[cset[string]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Set__string(self._cpp_obj, deref(loc))
            yield Set__string.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            raise err from None
        if not isinstance(item, Set__string):
            raise err
        cdef vector[cset[string]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cset[string]].iterator loc = std_libcpp.find[vector[cset[string]].iterator, cset[string]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Set__string>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            return 0
        if not isinstance(item, Set__string):
            return 0
        return <cint64_t> std_libcpp.count[vector[cset[string]].iterator, cset[string]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__string>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Set__string()


Sequence.register(List__Set__string)

@__cython.auto_pickle(False)
cdef class Map__string_List__SimpleStruct(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_List__SimpleStruct):
            self._cpp_obj = (<Map__string_List__SimpleStruct> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_List__SimpleStruct._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,vector[cSimpleStruct]]] c_items):
        __fbthrift_inst = <Map__string_List__SimpleStruct>Map__string_List__SimpleStruct.__new__(Map__string_List__SimpleStruct)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_List__SimpleStruct self):
        cdef shared_ptr[cmap[string,vector[cSimpleStruct]]] cpp_obj = make_shared[cmap[string,vector[cSimpleStruct]]](
            deref(self._cpp_obj)
        )
        return Map__string_List__SimpleStruct.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,vector[cSimpleStruct]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,vector[cSimpleStruct]]] c_inst = make_shared[cmap[string,vector[cSimpleStruct]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence['SimpleStruct']")
                if not isinstance(item, List__SimpleStruct):
                    item = List__SimpleStruct(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<List__SimpleStruct>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,vector[cSimpleStruct]].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[vector[cSimpleStruct]] citem = reference_shared_ptr_Map__string_List__SimpleStruct(self._cpp_obj, deref(iter).second)
        return List__SimpleStruct.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cmap[string,vector[cSimpleStruct]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef shared_ptr[vector[cSimpleStruct]] citem
        cdef cmap[string,vector[cSimpleStruct]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__string_List__SimpleStruct(self._cpp_obj, deref(loc).second)
            yield List__SimpleStruct.create(citem)
            inc(loc)

    def items(self):
        if not self:
            return
        cdef string ckey
        cdef shared_ptr[vector[cSimpleStruct]] citem
        cdef cmap[string,vector[cSimpleStruct]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__string_List__SimpleStruct(self._cpp_obj, deref(loc).second)
            yield (ckey.data().decode('UTF-8'), List__SimpleStruct.create(citem))
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_List__SimpleStruct()


Mapping.register(Map__string_List__SimpleStruct)

@__cython.auto_pickle(False)
cdef class List__List__string(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__List__string):
            self._cpp_obj = (<List__List__string> items)._cpp_obj
        else:
            self._cpp_obj = List__List__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[string]]] c_items):
        __fbthrift_inst = <List__List__string>List__List__string.__new__(List__List__string)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__List__string self):
        cdef shared_ptr[vector[vector[string]]] cpp_obj = make_shared[vector[vector[string]]](
            deref(self._cpp_obj)
        )
        return List__List__string.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[vector[string]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[string]]] c_inst = make_shared[vector[vector[string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[str]")
                if not isinstance(item, List__string):
                    item = List__string(item)
                deref(c_inst).push_back(deref((<List__string>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[string]]] c_inst
        cdef shared_ptr[vector[string]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[string]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__List__string.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__List__string(self._cpp_obj, deref(self._cpp_obj)[index])
            return List__string.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__string):
                item = List__string(item)
        except Exception:
            return False
        if not isinstance(item, List__string):
            return False
        return std_libcpp.find[vector[vector[string]].iterator, vector[string]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__string>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[vector[string]] citem
        cdef vector[vector[string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__List__string(self._cpp_obj, deref(loc))
            yield List__string.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[vector[string]] citem
        cdef vector[vector[string]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__List__string(self._cpp_obj, deref(loc))
            yield List__string.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__string):
                item = List__string(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__string):
            raise err
        cdef vector[vector[string]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[vector[string]].iterator loc = std_libcpp.find[vector[vector[string]].iterator, vector[string]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<List__string>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__string):
                item = List__string(item)
        except Exception:
            return 0
        if not isinstance(item, List__string):
            return 0
        return <cint64_t> std_libcpp.count[vector[vector[string]].iterator, vector[string]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__string>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__List__string()


Sequence.register(List__List__string)

@__cython.auto_pickle(False)
cdef class List__Set__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Set__i32):
            self._cpp_obj = (<List__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cset[cint32_t]]] c_items):
        __fbthrift_inst = <List__Set__i32>List__Set__i32.__new__(List__Set__i32)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__Set__i32 self):
        cdef shared_ptr[vector[cset[cint32_t]]] cpp_obj = make_shared[vector[cset[cint32_t]]](
            deref(self._cpp_obj)
        )
        return List__Set__i32.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cset[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cset[cint32_t]]] c_inst = make_shared[vector[cset[cint32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[int]")
                if not isinstance(item, Set__i32):
                    item = Set__i32(item)
                deref(c_inst).push_back(deref((<Set__i32>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[cint32_t]]] c_inst
        cdef shared_ptr[cset[cint32_t]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[cint32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Set__i32.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return Set__i32.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return False
        if not isinstance(item, Set__i32):
            return False
        return std_libcpp.find[vector[cset[cint32_t]].iterator, cset[cint32_t]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cset[cint32_t]] citem
        cdef vector[cset[cint32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(loc))
            yield Set__i32.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cset[cint32_t]] citem
        cdef vector[cset[cint32_t]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(loc))
            yield Set__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Set__i32):
            raise err
        cdef vector[cset[cint32_t]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cset[cint32_t]].iterator loc = std_libcpp.find[vector[cset[cint32_t]].iterator, cset[cint32_t]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Set__i32>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return 0
        if not isinstance(item, Set__i32):
            return 0
        return <cint64_t> std_libcpp.count[vector[cset[cint32_t]].iterator, cset[cint32_t]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__i32>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Set__i32()


Sequence.register(List__Set__i32)

@__cython.auto_pickle(False)
cdef class List__Map__string_string(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Map__string_string):
            self._cpp_obj = (<List__Map__string_string> items)._cpp_obj
        else:
            self._cpp_obj = List__Map__string_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cmap[string,string]]] c_items):
        __fbthrift_inst = <List__Map__string_string>List__Map__string_string.__new__(List__Map__string_string)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__Map__string_string self):
        cdef shared_ptr[vector[cmap[string,string]]] cpp_obj = make_shared[vector[cmap[string,string]]](
            deref(self._cpp_obj)
        )
        return List__Map__string_string.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cmap[string,string]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cmap[string,string]]] c_inst = make_shared[vector[cmap[string,string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[str, str]")
                if not isinstance(item, Map__string_string):
                    item = Map__string_string(item)
                deref(c_inst).push_back(deref((<Map__string_string>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[string,string]]] c_inst
        cdef shared_ptr[cmap[string,string]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[string,string]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Map__string_string.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Map__string_string(self._cpp_obj, deref(self._cpp_obj)[index])
            return Map__string_string.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__string_string):
                item = Map__string_string(item)
        except Exception:
            return False
        if not isinstance(item, Map__string_string):
            return False
        return std_libcpp.find[vector[cmap[string,string]].iterator, cmap[string,string]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__string_string>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cmap[string,string]] citem
        cdef vector[cmap[string,string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Map__string_string(self._cpp_obj, deref(loc))
            yield Map__string_string.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cmap[string,string]] citem
        cdef vector[cmap[string,string]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Map__string_string(self._cpp_obj, deref(loc))
            yield Map__string_string.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__string_string):
                item = Map__string_string(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__string_string):
            raise err
        cdef vector[cmap[string,string]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cmap[string,string]].iterator loc = std_libcpp.find[vector[cmap[string,string]].iterator, cmap[string,string]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Map__string_string>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__string_string):
                item = Map__string_string(item)
        except Exception:
            return 0
        if not isinstance(item, Map__string_string):
            return 0
        return <cint64_t> std_libcpp.count[vector[cmap[string,string]].iterator, cmap[string,string]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__string_string>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Map__string_string()


Sequence.register(List__Map__string_string)

@__cython.auto_pickle(False)
cdef class List__binary(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__binary):
            self._cpp_obj = (<List__binary> items)._cpp_obj
        else:
            self._cpp_obj = List__binary._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[string]] c_items):
        __fbthrift_inst = <List__binary>List__binary.__new__(List__binary)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__binary self):
        cdef shared_ptr[vector[string]] cpp_obj = make_shared[vector[string]](
            deref(self._cpp_obj)
        )
        return List__binary.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[string]] _make_instance(object items) except *:
        cdef shared_ptr[vector[string]] c_inst = make_shared[vector[string]]()
        if items is not None:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.Sequence[bytes] field, explicitly convert it first.")
            for item in items:
                if not isinstance(item, bytes):
                    raise TypeError(f"{item!r} is not of type bytes")
                deref(c_inst).push_back(item)
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[string]] c_inst
        cdef string citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[string]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__binary.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return bytes(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, bytes):
            return False
        return std_libcpp.find[vector[string].iterator, string](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef vector[string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield bytes(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef string citem
        cdef vector[string].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield bytes(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, bytes):
            raise err
        cdef vector[string].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[string].iterator loc = std_libcpp.find[vector[string].iterator, string](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, bytes):
            return 0
        return <cint64_t> std_libcpp.count[vector[string].iterator, string](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__binary()


Sequence.register(List__binary)

@__cython.auto_pickle(False)
cdef class Set__binary(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__binary):
            self._cpp_obj = (<Set__binary> items)._cpp_obj
        else:
            self._cpp_obj = Set__binary._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        __fbthrift_inst = <Set__binary>Set__binary.__new__(Set__binary)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Set__binary self):
        cdef shared_ptr[cset[string]] cpp_obj = make_shared[cset[string]](
            deref(self._cpp_obj)
        )
        return Set__binary.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[string]] _make_instance(object items) except *:
        cdef shared_ptr[cset[string]] c_inst = make_shared[cset[string]]()
        if items is not None:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.AbstractSet[bytes] field, explicitly convert it first.")
            for item in items:
                if not isinstance(item, bytes):
                    raise TypeError(f"{item!r} is not of type bytes")
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, bytes):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __iter__(self):
        if not self:
            return
        cdef string citem
        cdef cset[string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield bytes(citem)
            inc(loc)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[string]] cself, cother
        cdef cset[string].iterator loc
        if (isinstance(self, Set__binary) and
                isinstance(other, Set__binary)):
            cself = (<Set__binary> self)._cpp_obj
            cother = (<Set__binary> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __and__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__binary> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__binary> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__binary.create(__fbthrift_move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__binary> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__binary> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__binary.create(__fbthrift_move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__binary> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__binary> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__binary.create(__fbthrift_move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__binary> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__binary> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__binary.create(__fbthrift_move_shared(shretval))


    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__binary()


Set.register(Set__binary)

@__cython.auto_pickle(False)
cdef class List__AnEnum(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__AnEnum):
            self._cpp_obj = (<List__AnEnum> items)._cpp_obj
        else:
            self._cpp_obj = List__AnEnum._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cAnEnum]] c_items):
        __fbthrift_inst = <List__AnEnum>List__AnEnum.__new__(List__AnEnum)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__AnEnum self):
        cdef shared_ptr[vector[cAnEnum]] cpp_obj = make_shared[vector[cAnEnum]](
            deref(self._cpp_obj)
        )
        return List__AnEnum.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cAnEnum]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cAnEnum]] c_inst = make_shared[vector[cAnEnum]]()
        if items is not None:
            for item in items:
                if not isinstance(item, AnEnum):
                    raise TypeError(f"{item!r} is not of type AnEnum")
                deref(c_inst).push_back(<cAnEnum><int>item)
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cAnEnum]] c_inst
        cdef cAnEnum citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cAnEnum]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__AnEnum.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return translate_cpp_enum_to_python(AnEnum, <int> citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, AnEnum):
            return False
        return std_libcpp.find[vector[cAnEnum].iterator, cAnEnum](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), <cAnEnum><int>item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef cAnEnum citem
        cdef vector[cAnEnum].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield translate_cpp_enum_to_python(AnEnum, <int> citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef cAnEnum citem
        cdef vector[cAnEnum].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield translate_cpp_enum_to_python(AnEnum, <int> citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, AnEnum):
            raise err
        cdef vector[cAnEnum].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cAnEnum].iterator loc = std_libcpp.find[vector[cAnEnum].iterator, cAnEnum](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            <cAnEnum><int>item        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, AnEnum):
            return 0
        return <cint64_t> std_libcpp.count[vector[cAnEnum].iterator, cAnEnum](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), <cAnEnum><int>item)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__AnEnum()


Sequence.register(List__AnEnum)

@__cython.auto_pickle(False)
cdef class Map__i32_double(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__i32_double):
            self._cpp_obj = (<Map__i32_double> items)._cpp_obj
        else:
            self._cpp_obj = Map__i32_double._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[cint32_t,double]] c_items):
        __fbthrift_inst = <Map__i32_double>Map__i32_double.__new__(Map__i32_double)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(Map__i32_double self):
        cdef shared_ptr[cmap[cint32_t,double]] cpp_obj = make_shared[cmap[cint32_t,double]](
            deref(self._cpp_obj)
        )
        return Map__i32_double.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[cint32_t,double]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cint32_t,double]] c_inst = make_shared[cmap[cint32_t,double]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <cint32_t> key
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")

                deref(c_inst)[key] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[cint32_t,double].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef double citem = deref(iter).second
        return citem

    def __iter__(self):
        if not self:
            return
        cdef cint32_t citem
        cdef cmap[cint32_t,double].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef cint32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def values(self):
        if not self:
            return
        cdef double citem
        cdef cmap[cint32_t,double].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            return
        cdef cint32_t ckey
        cdef double citem
        cdef cmap[cint32_t,double].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey, citem)
            inc(loc)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__i32_double()


Mapping.register(Map__i32_double)

@__cython.auto_pickle(False)
cdef class List__Map__i32_double(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Map__i32_double):
            self._cpp_obj = (<List__Map__i32_double> items)._cpp_obj
        else:
            self._cpp_obj = List__Map__i32_double._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cmap[cint32_t,double]]] c_items):
        __fbthrift_inst = <List__Map__i32_double>List__Map__i32_double.__new__(List__Map__i32_double)
        __fbthrift_inst._cpp_obj = __fbthrift_move_shared(c_items)
        return __fbthrift_inst

    def __copy__(List__Map__i32_double self):
        cdef shared_ptr[vector[cmap[cint32_t,double]]] cpp_obj = make_shared[vector[cmap[cint32_t,double]]](
            deref(self._cpp_obj)
        )
        return List__Map__i32_double.create(__fbthrift_move_shared(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cmap[cint32_t,double]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cmap[cint32_t,double]]] c_inst = make_shared[vector[cmap[cint32_t,double]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i32_double):
                    item = Map__i32_double(item)
                deref(c_inst).push_back(deref((<Map__i32_double>item)._cpp_obj))
        return c_inst

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[cint32_t,double]]] c_inst
        cdef shared_ptr[cmap[cint32_t,double]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[cint32_t,double]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Map__i32_double.create(__fbthrift_move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Map__i32_double(self._cpp_obj, deref(self._cpp_obj)[index])
            return Map__i32_double.create(citem)

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__i32_double):
                item = Map__i32_double(item)
        except Exception:
            return False
        if not isinstance(item, Map__i32_double):
            return False
        return std_libcpp.find[vector[cmap[cint32_t,double]].iterator, cmap[cint32_t,double]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__i32_double>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            return
        cdef shared_ptr[cmap[cint32_t,double]] citem
        cdef vector[cmap[cint32_t,double]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Map__i32_double(self._cpp_obj, deref(loc))
            yield Map__i32_double.create(citem)
            inc(loc)

    def __reversed__(self):
        if not self:
            return
        cdef shared_ptr[cmap[cint32_t,double]] citem
        cdef vector[cmap[cint32_t,double]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Map__i32_double(self._cpp_obj, deref(loc))
            yield Map__i32_double.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__i32_double):
                item = Map__i32_double(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__i32_double):
            raise err
        cdef vector[cmap[cint32_t,double]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <cint64_t>offset_end)
        cdef vector[cmap[cint32_t,double]].iterator loc = std_libcpp.find[vector[cmap[cint32_t,double]].iterator, cmap[cint32_t,double]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <cint64_t>offset_begin),
            end,
            deref((<Map__i32_double>item)._cpp_obj)        )
        if loc != end:
            return <cint64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__i32_double):
                item = Map__i32_double(item)
        except Exception:
            return 0
        if not isinstance(item, Map__i32_double):
            return 0
        return <cint64_t> std_libcpp.count[vector[cmap[cint32_t,double]].iterator, cmap[cint32_t,double]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__i32_double>item)._cpp_obj))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Map__i32_double()


Sequence.register(List__Map__i32_double)

A_BOOL = True
A_BYTE = 8
THE_ANSWER = 42
A_NUMBER = 84
A_BIG_NUMBER = 102
A_REAL_NUMBER = 3.14
A_FAKE_NUMBER = 3.0
A_WORD = cA_WORD().decode('UTF-8')
SOME_BYTES = <bytes> cSOME_BYTES()
A_STRUCT = SimpleStruct.create(constant_shared_ptr(cA_STRUCT()))
WORD_LIST = List__string.create(constant_shared_ptr(cWORD_LIST()))
SOME_MAP = List__Map__i32_double.create(constant_shared_ptr(cSOME_MAP()))
DIGITS = Set__i32.create(constant_shared_ptr(cDIGITS()))
A_CONST_MAP = Map__string_SimpleStruct.create(constant_shared_ptr(cA_CONST_MAP()))
IOBufPtr = __iobuf.IOBuf
IOBuf = __iobuf.IOBuf
foo_bar = bytes

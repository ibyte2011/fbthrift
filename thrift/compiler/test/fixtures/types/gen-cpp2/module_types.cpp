/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/types/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/types/gen-cpp2/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/types/gen-cpp2/module_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::size;
folly::Range<::apache::thrift::fixtures::types::has_bitwise_ops const*> const TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::has_bitwise_ops>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::has_bitwise_ops>::names);

char const* TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::findName(type value) {
  using factory = ::apache::thrift::fixtures::types::_has_bitwise_ops_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::fixtures::types::_has_bitwise_ops_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift { namespace fixtures { namespace types {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _has_bitwise_ops_EnumMapFactory::ValuesToNamesMapType _has_bitwise_ops_VALUES_TO_NAMES = _has_bitwise_ops_EnumMapFactory::makeValuesToNamesMap();
const _has_bitwise_ops_EnumMapFactory::NamesToValuesMapType _has_bitwise_ops_NAMES_TO_VALUES = _has_bitwise_ops_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}}} // apache::thrift::fixtures::types

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::size;
folly::Range<::apache::thrift::fixtures::types::is_unscoped const*> const TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::is_unscoped>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::is_unscoped>::names);

char const* TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::findName(type value) {
  using factory = ::apache::thrift::fixtures::types::_is_unscoped_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::fixtures::types::_is_unscoped_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift { namespace fixtures { namespace types {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _is_unscoped_EnumMapFactory::ValuesToNamesMapType _is_unscoped_VALUES_TO_NAMES = _is_unscoped_EnumMapFactory::makeValuesToNamesMap();
const _is_unscoped_EnumMapFactory::NamesToValuesMapType _is_unscoped_NAMES_TO_VALUES = _is_unscoped_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}}} // apache::thrift::fixtures::types

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::size;
folly::Range<::apache::thrift::fixtures::types::MyForwardRefEnum const*> const TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::MyForwardRefEnum>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::MyForwardRefEnum>::names);

char const* TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::findName(type value) {
  using factory = ::apache::thrift::fixtures::types::_MyForwardRefEnum_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::fixtures::types::_MyForwardRefEnum_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift { namespace fixtures { namespace types {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _MyForwardRefEnum_EnumMapFactory::ValuesToNamesMapType _MyForwardRefEnum_VALUES_TO_NAMES = _MyForwardRefEnum_EnumMapFactory::makeValuesToNamesMap();
const _MyForwardRefEnum_EnumMapFactory::NamesToValuesMapType _MyForwardRefEnum_NAMES_TO_VALUES = _MyForwardRefEnum_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}}} // apache::thrift::fixtures::types

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::fixtures::types::MyEnumA>::size;
folly::Range<::apache::thrift::fixtures::types::MyEnumA const*> const TEnumTraits<::apache::thrift::fixtures::types::MyEnumA>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::MyEnumA>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::fixtures::types::MyEnumA>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::MyEnumA>::names);

char const* TEnumTraits<::apache::thrift::fixtures::types::MyEnumA>::findName(type value) {
  using factory = ::apache::thrift::fixtures::types::_MyEnumA_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::fixtures::types::MyEnumA>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::fixtures::types::_MyEnumA_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift { namespace fixtures { namespace types {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _MyEnumA_EnumMapFactory::ValuesToNamesMapType _MyEnumA_VALUES_TO_NAMES = _MyEnumA_EnumMapFactory::makeValuesToNamesMap();
const _MyEnumA_EnumMapFactory::NamesToValuesMapType _MyEnumA_NAMES_TO_VALUES = _MyEnumA_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::decorated_struct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "field",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
decorated_struct::decorated_struct(apache::thrift::FragileConstructor, ::std::string field__arg) :
    field(std::move(field__arg)) {
  __isset.field = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void decorated_struct::__clear() {
  // clear all fields
  field = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool decorated_struct::operator==(const decorated_struct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field == rhs.field)) {
    return false;
  }
  return true;
}

bool decorated_struct::operator<(const decorated_struct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field == rhs.field)) {
    return lhs.field < rhs.field;
  }
  return false;
}


void swap(decorated_struct& a, decorated_struct& b) {
  using ::std::swap;
  swap(a.field_ref().value(), b.field_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void decorated_struct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t decorated_struct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t decorated_struct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t decorated_struct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void decorated_struct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t decorated_struct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t decorated_struct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t decorated_struct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::ContainerStruct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 8;
  static constexpr folly::StringPiece _names[] = {
    "fieldA",
    "fieldB",
    "fieldC",
    "fieldD",
    "fieldE",
    "fieldF",
    "fieldG",
    "fieldH",
  };
  static constexpr int16_t _ids[] = {
    12,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
  };
  static constexpr TType _types[] = {
    TType::T_LIST,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_SET,
    TType::T_MAP,
    TType::T_MAP,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ContainerStruct::ContainerStruct() {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


ContainerStruct::~ContainerStruct() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ContainerStruct::ContainerStruct(apache::thrift::FragileConstructor, ::std::vector<int32_t> fieldA__arg, std::list<int32_t> fieldB__arg, std::deque<int32_t> fieldC__arg, folly::fbvector<int32_t> fieldD__arg, folly::small_vector<int32_t> fieldE__arg, folly::sorted_vector_set<int32_t> fieldF__arg, folly::sorted_vector_map<int32_t, ::std::string> fieldG__arg,  ::apache::thrift::fixtures::types::SomeMap fieldH__arg) :
    fieldA(std::move(fieldA__arg)),
    fieldB(std::move(fieldB__arg)),
    fieldC(std::move(fieldC__arg)),
    fieldD(std::move(fieldD__arg)),
    fieldE(std::move(fieldE__arg)),
    fieldF(std::move(fieldF__arg)),
    fieldG(std::move(fieldG__arg)),
    fieldH(std::move(fieldH__arg)) {
  __isset.fieldA = true;
  __isset.fieldB = true;
  __isset.fieldC = true;
  __isset.fieldD = true;
  __isset.fieldE = true;
  __isset.fieldF = true;
  __isset.fieldG = true;
  __isset.fieldH = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ContainerStruct::__clear() {
  // clear all fields
  fieldA.clear();
  fieldB.clear();
  fieldC.clear();
  fieldD.clear();
  fieldE.clear();
  fieldF.clear();
  fieldG.clear();
  fieldH.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ContainerStruct::operator==(const ContainerStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.fieldA == rhs.fieldA)) {
    return false;
  }
  if (!(lhs.fieldB == rhs.fieldB)) {
    return false;
  }
  if (!(lhs.fieldC == rhs.fieldC)) {
    return false;
  }
  if (!(lhs.fieldD == rhs.fieldD)) {
    return false;
  }
  if (!(lhs.fieldE == rhs.fieldE)) {
    return false;
  }
  if (!(lhs.fieldF == rhs.fieldF)) {
    return false;
  }
  if (!(lhs.fieldG == rhs.fieldG)) {
    return false;
  }
  if (!(lhs.fieldH == rhs.fieldH)) {
    return false;
  }
  return true;
}

const ::std::vector<int32_t>& ContainerStruct::get_fieldA() const& {
  return fieldA;
}

::std::vector<int32_t> ContainerStruct::get_fieldA() && {
  return std::move(fieldA);
}

const std::list<int32_t>& ContainerStruct::get_fieldB() const& {
  return fieldB;
}

std::list<int32_t> ContainerStruct::get_fieldB() && {
  return std::move(fieldB);
}

const std::deque<int32_t>& ContainerStruct::get_fieldC() const& {
  return fieldC;
}

std::deque<int32_t> ContainerStruct::get_fieldC() && {
  return std::move(fieldC);
}

const folly::fbvector<int32_t>& ContainerStruct::get_fieldD() const& {
  return fieldD;
}

folly::fbvector<int32_t> ContainerStruct::get_fieldD() && {
  return std::move(fieldD);
}

const folly::small_vector<int32_t>& ContainerStruct::get_fieldE() const& {
  return fieldE;
}

folly::small_vector<int32_t> ContainerStruct::get_fieldE() && {
  return std::move(fieldE);
}

const folly::sorted_vector_set<int32_t>& ContainerStruct::get_fieldF() const& {
  return fieldF;
}

folly::sorted_vector_set<int32_t> ContainerStruct::get_fieldF() && {
  return std::move(fieldF);
}

const folly::sorted_vector_map<int32_t, ::std::string>& ContainerStruct::get_fieldG() const& {
  return fieldG;
}

folly::sorted_vector_map<int32_t, ::std::string> ContainerStruct::get_fieldG() && {
  return std::move(fieldG);
}

const  ::apache::thrift::fixtures::types::SomeMap& ContainerStruct::get_fieldH() const& {
  return fieldH;
}

 ::apache::thrift::fixtures::types::SomeMap ContainerStruct::get_fieldH() && {
  return std::move(fieldH);
}


void swap(ContainerStruct& a, ContainerStruct& b) {
  using ::std::swap;
  swap(a.fieldA_ref().value(), b.fieldA_ref().value());
  swap(a.fieldB_ref().value(), b.fieldB_ref().value());
  swap(a.fieldC_ref().value(), b.fieldC_ref().value());
  swap(a.fieldD_ref().value(), b.fieldD_ref().value());
  swap(a.fieldE_ref().value(), b.fieldE_ref().value());
  swap(a.fieldF_ref().value(), b.fieldF_ref().value());
  swap(a.fieldG_ref().value(), b.fieldG_ref().value());
  swap(a.fieldH_ref().value(), b.fieldH_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ContainerStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ContainerStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ContainerStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ContainerStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ContainerStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ContainerStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ContainerStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ContainerStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::CppTypeStruct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "fieldA",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_LIST,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CppTypeStruct::CppTypeStruct(apache::thrift::FragileConstructor, std::list<int32_t> fieldA__arg) :
    fieldA(std::move(fieldA__arg)) {
  __isset.fieldA = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CppTypeStruct::__clear() {
  // clear all fields
  fieldA.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CppTypeStruct::operator==(const CppTypeStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.fieldA == rhs.fieldA)) {
    return false;
  }
  return true;
}

bool CppTypeStruct::operator<(const CppTypeStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.fieldA == rhs.fieldA)) {
    return lhs.fieldA < rhs.fieldA;
  }
  return false;
}

const std::list<int32_t>& CppTypeStruct::get_fieldA() const& {
  return fieldA;
}

std::list<int32_t> CppTypeStruct::get_fieldA() && {
  return std::move(fieldA);
}


void swap(CppTypeStruct& a, CppTypeStruct& b) {
  using ::std::swap;
  swap(a.fieldA_ref().value(), b.fieldA_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CppTypeStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CppTypeStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CppTypeStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CppTypeStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CppTypeStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CppTypeStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CppTypeStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CppTypeStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::VirtualStruct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "MyIntField",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_I64,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
VirtualStruct::VirtualStruct(apache::thrift::FragileConstructor, int64_t MyIntField__arg) :
    MyIntField(std::move(MyIntField__arg)) {
  __isset.MyIntField = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void VirtualStruct::__clear() {
  // clear all fields
  MyIntField = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool VirtualStruct::operator==(const VirtualStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.MyIntField == rhs.MyIntField)) {
    return false;
  }
  return true;
}

bool VirtualStruct::operator<(const VirtualStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.MyIntField == rhs.MyIntField)) {
    return lhs.MyIntField < rhs.MyIntField;
  }
  return false;
}


void swap(VirtualStruct& a, VirtualStruct& b) {
  using ::std::swap;
  swap(a.MyIntField_ref().value(), b.MyIntField_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void VirtualStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t VirtualStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t VirtualStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t VirtualStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void VirtualStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t VirtualStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t VirtualStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t VirtualStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::MyStructWithForwardRefEnum>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "a",
    "b",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStructWithForwardRefEnum::MyStructWithForwardRefEnum(apache::thrift::FragileConstructor,  ::apache::thrift::fixtures::types::MyForwardRefEnum a__arg,  ::apache::thrift::fixtures::types::MyForwardRefEnum b__arg) :
    a(std::move(a__arg)),
    b(std::move(b__arg)) {
  __isset.a = true;
  __isset.b = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MyStructWithForwardRefEnum::__clear() {
  // clear all fields
  a =  ::apache::thrift::fixtures::types::MyForwardRefEnum::NONZERO;
  b =  ::apache::thrift::fixtures::types::MyForwardRefEnum::NONZERO;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MyStructWithForwardRefEnum::operator==(const MyStructWithForwardRefEnum& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a == rhs.a)) {
    return false;
  }
  if (!(lhs.b == rhs.b)) {
    return false;
  }
  return true;
}

bool MyStructWithForwardRefEnum::operator<(const MyStructWithForwardRefEnum& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a == rhs.a)) {
    return lhs.a < rhs.a;
  }
  if (!(lhs.b == rhs.b)) {
    return lhs.b < rhs.b;
  }
  return false;
}


void swap(MyStructWithForwardRefEnum& a, MyStructWithForwardRefEnum& b) {
  using ::std::swap;
  swap(a.a_ref().value(), b.a_ref().value());
  swap(a.b_ref().value(), b.b_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MyStructWithForwardRefEnum::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStructWithForwardRefEnum::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStructWithForwardRefEnum::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStructWithForwardRefEnum::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStructWithForwardRefEnum::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStructWithForwardRefEnum::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStructWithForwardRefEnum::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStructWithForwardRefEnum::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::TrivialNumeric>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "a",
    "b",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_BOOL,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
TrivialNumeric::TrivialNumeric(apache::thrift::FragileConstructor, int32_t a__arg, bool b__arg) :
    a(std::move(a__arg)),
    b(std::move(b__arg)) {
  __isset.a = true;
  __isset.b = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void TrivialNumeric::__clear() {
  // clear all fields
  a = 0;
  b = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool TrivialNumeric::operator==(const TrivialNumeric& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a == rhs.a)) {
    return false;
  }
  if (!(lhs.b == rhs.b)) {
    return false;
  }
  return true;
}

bool TrivialNumeric::operator<(const TrivialNumeric& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a == rhs.a)) {
    return lhs.a < rhs.a;
  }
  if (!(lhs.b == rhs.b)) {
    return lhs.b < rhs.b;
  }
  return false;
}


void swap(TrivialNumeric& a, TrivialNumeric& b) {
  using ::std::swap;
  swap(a.a_ref().value(), b.a_ref().value());
  swap(a.b_ref().value(), b.b_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void TrivialNumeric::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TrivialNumeric::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TrivialNumeric::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TrivialNumeric::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TrivialNumeric::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TrivialNumeric::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TrivialNumeric::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TrivialNumeric::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::TrivialNestedWithDefault>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "z",
    "n",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
TrivialNestedWithDefault::TrivialNestedWithDefault(apache::thrift::FragileConstructor, int32_t z__arg,  ::apache::thrift::fixtures::types::TrivialNumeric n__arg) :
    z(std::move(z__arg)),
    n(std::move(n__arg)) {
  __isset.z = true;
  __isset.n = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void TrivialNestedWithDefault::__clear() {
  // clear all fields
  z = 4;
  ::apache::thrift::Cpp2Ops<  ::apache::thrift::fixtures::types::TrivialNumeric>::clear(&n);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool TrivialNestedWithDefault::operator==(const TrivialNestedWithDefault& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.z == rhs.z)) {
    return false;
  }
  if (!(lhs.n == rhs.n)) {
    return false;
  }
  return true;
}

bool TrivialNestedWithDefault::operator<(const TrivialNestedWithDefault& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.z == rhs.z)) {
    return lhs.z < rhs.z;
  }
  if (!(lhs.n == rhs.n)) {
    return lhs.n < rhs.n;
  }
  return false;
}

const  ::apache::thrift::fixtures::types::TrivialNumeric& TrivialNestedWithDefault::get_n() const& {
  return n;
}

 ::apache::thrift::fixtures::types::TrivialNumeric TrivialNestedWithDefault::get_n() && {
  return std::move(n);
}


void swap(TrivialNestedWithDefault& a, TrivialNestedWithDefault& b) {
  using ::std::swap;
  swap(a.z_ref().value(), b.z_ref().value());
  swap(a.n_ref().value(), b.n_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void TrivialNestedWithDefault::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TrivialNestedWithDefault::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TrivialNestedWithDefault::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TrivialNestedWithDefault::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TrivialNestedWithDefault::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TrivialNestedWithDefault::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TrivialNestedWithDefault::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TrivialNestedWithDefault::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        TrivialNestedWithDefault,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::TrivialNumeric>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        TrivialNestedWithDefault,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::TrivialNumeric>,
    "inconsistent use of nimble option");

}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::ComplexString>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "a",
    "b",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_MAP,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ComplexString::ComplexString(apache::thrift::FragileConstructor, ::std::string a__arg, ::std::map<::std::string, int32_t> b__arg) :
    a(std::move(a__arg)),
    b(std::move(b__arg)) {
  __isset.a = true;
  __isset.b = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ComplexString::__clear() {
  // clear all fields
  a = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  b.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ComplexString::operator==(const ComplexString& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a == rhs.a)) {
    return false;
  }
  if (!(lhs.b == rhs.b)) {
    return false;
  }
  return true;
}

bool ComplexString::operator<(const ComplexString& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a == rhs.a)) {
    return lhs.a < rhs.a;
  }
  if (!(lhs.b == rhs.b)) {
    return lhs.b < rhs.b;
  }
  return false;
}

const ::std::map<::std::string, int32_t>& ComplexString::get_b() const& {
  return b;
}

::std::map<::std::string, int32_t> ComplexString::get_b() && {
  return std::move(b);
}


void swap(ComplexString& a, ComplexString& b) {
  using ::std::swap;
  swap(a.a_ref().value(), b.a_ref().value());
  swap(a.b_ref().value(), b.b_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ComplexString::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ComplexString::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ComplexString::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ComplexString::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ComplexString::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ComplexString::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ComplexString::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ComplexString::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::ComplexNestedWithDefault>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "z",
    "n",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ComplexNestedWithDefault::ComplexNestedWithDefault(apache::thrift::FragileConstructor, ::std::string z__arg,  ::apache::thrift::fixtures::types::ComplexString n__arg) :
    z(std::move(z__arg)),
    n(std::move(n__arg)) {
  __isset.z = true;
  __isset.n = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ComplexNestedWithDefault::__clear() {
  // clear all fields
  z = apache::thrift::StringTraits< std::string>::fromStringLiteral("4");
  ::apache::thrift::Cpp2Ops<  ::apache::thrift::fixtures::types::ComplexString>::clear(&n);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ComplexNestedWithDefault::operator==(const ComplexNestedWithDefault& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.z == rhs.z)) {
    return false;
  }
  if (!(lhs.n == rhs.n)) {
    return false;
  }
  return true;
}

bool ComplexNestedWithDefault::operator<(const ComplexNestedWithDefault& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.z == rhs.z)) {
    return lhs.z < rhs.z;
  }
  if (!(lhs.n == rhs.n)) {
    return lhs.n < rhs.n;
  }
  return false;
}

const  ::apache::thrift::fixtures::types::ComplexString& ComplexNestedWithDefault::get_n() const& {
  return n;
}

 ::apache::thrift::fixtures::types::ComplexString ComplexNestedWithDefault::get_n() && {
  return std::move(n);
}


void swap(ComplexNestedWithDefault& a, ComplexNestedWithDefault& b) {
  using ::std::swap;
  swap(a.z_ref().value(), b.z_ref().value());
  swap(a.n_ref().value(), b.n_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ComplexNestedWithDefault::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ComplexNestedWithDefault::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ComplexNestedWithDefault::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ComplexNestedWithDefault::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ComplexNestedWithDefault::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ComplexNestedWithDefault::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ComplexNestedWithDefault::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ComplexNestedWithDefault::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ComplexNestedWithDefault,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::ComplexString>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ComplexNestedWithDefault,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::ComplexString>,
    "inconsistent use of nimble option");

}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::MinPadding>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 5;
  static constexpr folly::StringPiece _names[] = {
    "small",
    "big",
    "medium",
    "biggish",
    "tiny",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
  };
  static constexpr TType _types[] = {
    TType::T_BYTE,
    TType::T_I64,
    TType::T_I16,
    TType::T_I32,
    TType::T_BYTE,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MinPadding::MinPadding(apache::thrift::FragileConstructor, int8_t small__arg, int64_t big__arg, int16_t medium__arg, int32_t biggish__arg, int8_t tiny__arg) :
    big(std::move(big__arg)),
    biggish(std::move(biggish__arg)),
    medium(std::move(medium__arg)),
    small(std::move(small__arg)),
    tiny(std::move(tiny__arg)) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MinPadding::__clear() {
  // clear all fields
  small = 0;
  big = 0;
  medium = 0;
  biggish = 0;
  tiny = 0;
}

bool MinPadding::operator==(const MinPadding& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.small == rhs.small)) {
    return false;
  }
  if (!(lhs.big == rhs.big)) {
    return false;
  }
  if (!(lhs.medium == rhs.medium)) {
    return false;
  }
  if (!(lhs.biggish == rhs.biggish)) {
    return false;
  }
  if (!(lhs.tiny == rhs.tiny)) {
    return false;
  }
  return true;
}

bool MinPadding::operator<(const MinPadding& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.small == rhs.small)) {
    return lhs.small < rhs.small;
  }
  if (!(lhs.big == rhs.big)) {
    return lhs.big < rhs.big;
  }
  if (!(lhs.medium == rhs.medium)) {
    return lhs.medium < rhs.medium;
  }
  if (!(lhs.biggish == rhs.biggish)) {
    return lhs.biggish < rhs.biggish;
  }
  if (!(lhs.tiny == rhs.tiny)) {
    return lhs.tiny < rhs.tiny;
  }
  return false;
}


void swap(MinPadding& a, MinPadding& b) {
  using ::std::swap;
  swap(a.small_ref().value(), b.small_ref().value());
  swap(a.big_ref().value(), b.big_ref().value());
  swap(a.medium_ref().value(), b.medium_ref().value());
  swap(a.biggish_ref().value(), b.biggish_ref().value());
  swap(a.tiny_ref().value(), b.tiny_ref().value());
}

template void MinPadding::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MinPadding::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MinPadding::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MinPadding::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MinPadding::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MinPadding::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MinPadding::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MinPadding::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::MyDataItem>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyDataItem::MyDataItem(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MyDataItem::__clear() {
  // clear all fields
}




void swap(MyDataItem& a, MyDataItem& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void MyDataItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyDataItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyDataItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyDataItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyDataItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyDataItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyDataItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyDataItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::MyStruct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "MyIntField",
    "MyStringField",
    "majorVer",
    "data",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
  };
  static constexpr TType _types[] = {
    TType::T_I64,
    TType::T_STRING,
    TType::T_I64,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStruct::MyStruct(apache::thrift::FragileConstructor, int64_t MyIntField__arg, ::std::string MyStringField__arg, int64_t majorVer__arg,  ::apache::thrift::fixtures::types::MyDataItem data__arg) :
    MyIntField(std::move(MyIntField__arg)),
    MyStringField(std::move(MyStringField__arg)),
    majorVer(std::move(majorVer__arg)),
    data(std::move(data__arg)) {
  __isset.MyIntField = true;
  __isset.MyStringField = true;
  __isset.majorVer = true;
  __isset.data = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MyStruct::__clear() {
  // clear all fields
  MyIntField = 0;
  MyStringField = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  majorVer = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}



const  ::apache::thrift::fixtures::types::MyDataItem& MyStruct::get_data() const& {
  return data;
}

 ::apache::thrift::fixtures::types::MyDataItem MyStruct::get_data() && {
  return std::move(data);
}


void swap(MyStruct& a, MyStruct& b) {
  using ::std::swap;
  swap(a.MyIntField_ref().value(), b.MyIntField_ref().value());
  swap(a.MyStringField_ref().value(), b.MyStringField_ref().value());
  swap(a.majorVer_ref().value(), b.majorVer_ref().value());
  swap(a.data_ref().value(), b.data_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MyStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyStruct,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::MyDataItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyStruct,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::MyDataItem>,
    "inconsistent use of nimble option");

}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::Renaming>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "foo",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_I64,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
Renaming::Renaming(apache::thrift::FragileConstructor, int64_t bar__arg) :
    bar(std::move(bar__arg)) {
  __isset.bar = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void Renaming::__clear() {
  // clear all fields
  bar = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool Renaming::operator==(const Renaming& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.bar == rhs.bar)) {
    return false;
  }
  return true;
}

bool Renaming::operator<(const Renaming& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.bar == rhs.bar)) {
    return lhs.bar < rhs.bar;
  }
  return false;
}


void swap(Renaming& a, Renaming& b) {
  using ::std::swap;
  swap(a.bar_ref().value(), b.bar_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void Renaming::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Renaming::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Renaming::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Renaming::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Renaming::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Renaming::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Renaming::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Renaming::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::AnnotatedTypes>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "binary_field",
    "list_field",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_LIST,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AnnotatedTypes::AnnotatedTypes(apache::thrift::FragileConstructor,  ::apache::thrift::fixtures::types::TBinary binary_field__arg,  ::apache::thrift::fixtures::types::SomeListOfTypeMap list_field__arg) :
    binary_field(std::move(binary_field__arg)),
    list_field(std::move(list_field__arg)) {
  __isset.binary_field = true;
  __isset.list_field = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AnnotatedTypes::__clear() {
  // clear all fields
  binary_field = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  list_field.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AnnotatedTypes::operator==(const AnnotatedTypes& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.binary_field, rhs.binary_field)) {
    return false;
  }
  if (!(lhs.list_field == rhs.list_field)) {
    return false;
  }
  return true;
}

const  ::apache::thrift::fixtures::types::SomeListOfTypeMap& AnnotatedTypes::get_list_field() const& {
  return list_field;
}

 ::apache::thrift::fixtures::types::SomeListOfTypeMap AnnotatedTypes::get_list_field() && {
  return std::move(list_field);
}


void swap(AnnotatedTypes& a, AnnotatedTypes& b) {
  using ::std::swap;
  swap(a.binary_field_ref().value(), b.binary_field_ref().value());
  swap(a.list_field_ref().value(), b.list_field_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AnnotatedTypes::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AnnotatedTypes::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AnnotatedTypes::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AnnotatedTypes::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AnnotatedTypes::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AnnotatedTypes::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AnnotatedTypes::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AnnotatedTypes::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::ForwardUsageStruct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "foo",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ForwardUsageStruct::ForwardUsageStruct(apache::thrift::FragileConstructor,  ::apache::thrift::fixtures::types::ForwardUsageRoot foo__arg) :
    foo(std::move(foo__arg)) {
  __isset.foo = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ForwardUsageStruct::__clear() {
  // clear all fields
  ::apache::thrift::Cpp2Ops<  ::apache::thrift::fixtures::types::ForwardUsageRoot>::clear(&foo);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ForwardUsageStruct::operator==(const ForwardUsageStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.foo_ref() != rhs.foo_ref()) {
    return false;
  }
  return true;
}

bool ForwardUsageStruct::operator<(const ForwardUsageStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.foo_ref() != rhs.foo_ref()) {
    return lhs.foo_ref() < rhs.foo_ref();
  }
  return false;
}

const  ::apache::thrift::fixtures::types::ForwardUsageRoot* ForwardUsageStruct::get_foo() const& {
  return foo_ref().has_value() ? std::addressof(foo) : nullptr;
}

 ::apache::thrift::fixtures::types::ForwardUsageRoot* ForwardUsageStruct::get_foo() & {
  return foo_ref().has_value() ? std::addressof(foo) : nullptr;
}


void swap(ForwardUsageStruct& a, ForwardUsageStruct& b) {
  using ::std::swap;
  swap(a.foo_ref().value_unchecked(), b.foo_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ForwardUsageStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ForwardUsageStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ForwardUsageStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ForwardUsageStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ForwardUsageStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ForwardUsageStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ForwardUsageStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ForwardUsageStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ForwardUsageStruct,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::ForwardUsageRoot>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ForwardUsageStruct,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::ForwardUsageRoot>,
    "inconsistent use of nimble option");

}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::ForwardUsageRoot>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "ForwardUsageStruct",
    "ForwardUsageByRef",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

ForwardUsageRoot::ForwardUsageRoot(const ForwardUsageRoot& srcObj) {
  ForwardUsageStruct = srcObj.ForwardUsageStruct;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset.ForwardUsageStruct = srcObj.__isset.ForwardUsageStruct;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  if (srcObj.ForwardUsageByRef) ForwardUsageByRef.reset(new  ::apache::thrift::fixtures::types::ForwardUsageByRef(*srcObj.ForwardUsageByRef));
}

ForwardUsageRoot& ForwardUsageRoot::operator=(const ForwardUsageRoot& src) {
  ForwardUsageRoot tmp(src);
  swap(*this, tmp);
  return *this;
}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ForwardUsageRoot::ForwardUsageRoot(apache::thrift::FragileConstructor,  ::apache::thrift::fixtures::types::ForwardUsageStruct ForwardUsageStruct__arg, std::unique_ptr< ::apache::thrift::fixtures::types::ForwardUsageByRef> ForwardUsageByRef__arg) :
    ForwardUsageStruct(std::move(ForwardUsageStruct__arg)),
    ForwardUsageByRef(std::move(ForwardUsageByRef__arg)) {
  __isset.ForwardUsageStruct = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ForwardUsageRoot::__clear() {
  // clear all fields
  ::apache::thrift::Cpp2Ops<  ::apache::thrift::fixtures::types::ForwardUsageStruct>::clear(&ForwardUsageStruct);
  ForwardUsageByRef.reset();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ForwardUsageRoot::operator==(const ForwardUsageRoot& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.ForwardUsageStruct_ref() != rhs.ForwardUsageStruct_ref()) {
    return false;
  }
  if (!!lhs.ForwardUsageByRef != !!rhs.ForwardUsageByRef) {
    return false;
  }
  if (!!lhs.ForwardUsageByRef) {
    if (lhs.ForwardUsageByRef != rhs.ForwardUsageByRef && !(*lhs.ForwardUsageByRef == *rhs.ForwardUsageByRef)) {
      return false;
    }
  }
  return true;
}

bool ForwardUsageRoot::operator<(const ForwardUsageRoot& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.ForwardUsageStruct_ref() != rhs.ForwardUsageStruct_ref()) {
    return lhs.ForwardUsageStruct_ref() < rhs.ForwardUsageStruct_ref();
  }
  if (!!lhs.ForwardUsageByRef != !!rhs.ForwardUsageByRef) {
    return !!lhs.ForwardUsageByRef < !!rhs.ForwardUsageByRef;
  }
  if (!!lhs.ForwardUsageByRef) {
    if (lhs.ForwardUsageByRef != rhs.ForwardUsageByRef && !(*lhs.ForwardUsageByRef == *rhs.ForwardUsageByRef)) {
      return *lhs.ForwardUsageByRef < *rhs.ForwardUsageByRef;
    }
  }
  return false;
}

const  ::apache::thrift::fixtures::types::ForwardUsageStruct* ForwardUsageRoot::get_ForwardUsageStruct() const& {
  return ForwardUsageStruct_ref().has_value() ? std::addressof(ForwardUsageStruct) : nullptr;
}

 ::apache::thrift::fixtures::types::ForwardUsageStruct* ForwardUsageRoot::get_ForwardUsageStruct() & {
  return ForwardUsageStruct_ref().has_value() ? std::addressof(ForwardUsageStruct) : nullptr;
}


void swap(ForwardUsageRoot& a, ForwardUsageRoot& b) {
  using ::std::swap;
  swap(a.ForwardUsageStruct_ref().value_unchecked(), b.ForwardUsageStruct_ref().value_unchecked());
  swap(a.ForwardUsageByRef, b.ForwardUsageByRef);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ForwardUsageRoot::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ForwardUsageRoot::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ForwardUsageRoot::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ForwardUsageRoot::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ForwardUsageRoot::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ForwardUsageRoot::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ForwardUsageRoot::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ForwardUsageRoot::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ForwardUsageRoot,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::ForwardUsageStruct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ForwardUsageRoot,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::ForwardUsageByRef>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ForwardUsageRoot,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::ForwardUsageStruct>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ForwardUsageRoot,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::ForwardUsageByRef>,
    "inconsistent use of nimble option");

}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::ForwardUsageByRef>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "foo",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ForwardUsageByRef::ForwardUsageByRef(apache::thrift::FragileConstructor,  ::apache::thrift::fixtures::types::ForwardUsageRoot foo__arg) :
    foo(std::move(foo__arg)) {
  __isset.foo = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ForwardUsageByRef::__clear() {
  // clear all fields
  ::apache::thrift::Cpp2Ops<  ::apache::thrift::fixtures::types::ForwardUsageRoot>::clear(&foo);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ForwardUsageByRef::operator==(const ForwardUsageByRef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.foo_ref() != rhs.foo_ref()) {
    return false;
  }
  return true;
}

bool ForwardUsageByRef::operator<(const ForwardUsageByRef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.foo_ref() != rhs.foo_ref()) {
    return lhs.foo_ref() < rhs.foo_ref();
  }
  return false;
}

const  ::apache::thrift::fixtures::types::ForwardUsageRoot* ForwardUsageByRef::get_foo() const& {
  return foo_ref().has_value() ? std::addressof(foo) : nullptr;
}

 ::apache::thrift::fixtures::types::ForwardUsageRoot* ForwardUsageByRef::get_foo() & {
  return foo_ref().has_value() ? std::addressof(foo) : nullptr;
}


void swap(ForwardUsageByRef& a, ForwardUsageByRef& b) {
  using ::std::swap;
  swap(a.foo_ref().value_unchecked(), b.foo_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ForwardUsageByRef::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ForwardUsageByRef::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ForwardUsageByRef::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ForwardUsageByRef::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ForwardUsageByRef::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ForwardUsageByRef::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ForwardUsageByRef::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ForwardUsageByRef::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ForwardUsageByRef,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::ForwardUsageRoot>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ForwardUsageByRef,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::fixtures::types::ForwardUsageRoot>,
    "inconsistent use of nimble option");

}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::NoexceptMoveEmpty>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NoexceptMoveEmpty::NoexceptMoveEmpty(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void NoexceptMoveEmpty::__clear() {
  // clear all fields
}

bool NoexceptMoveEmpty::operator==(const NoexceptMoveEmpty& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool NoexceptMoveEmpty::operator<(const NoexceptMoveEmpty& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(NoexceptMoveEmpty& a, NoexceptMoveEmpty& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void NoexceptMoveEmpty::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NoexceptMoveEmpty::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NoexceptMoveEmpty::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NoexceptMoveEmpty::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NoexceptMoveEmpty::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NoexceptMoveEmpty::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NoexceptMoveEmpty::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NoexceptMoveEmpty::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::NoexceptMoveSimpleStruct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "boolField",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_I64,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NoexceptMoveSimpleStruct::NoexceptMoveSimpleStruct(apache::thrift::FragileConstructor, int64_t boolField__arg) :
    boolField(std::move(boolField__arg)) {
  __isset.boolField = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void NoexceptMoveSimpleStruct::__clear() {
  // clear all fields
  boolField = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool NoexceptMoveSimpleStruct::operator==(const NoexceptMoveSimpleStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.boolField == rhs.boolField)) {
    return false;
  }
  return true;
}

bool NoexceptMoveSimpleStruct::operator<(const NoexceptMoveSimpleStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.boolField == rhs.boolField)) {
    return lhs.boolField < rhs.boolField;
  }
  return false;
}


void swap(NoexceptMoveSimpleStruct& a, NoexceptMoveSimpleStruct& b) {
  using ::std::swap;
  swap(a.boolField_ref().value(), b.boolField_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void NoexceptMoveSimpleStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NoexceptMoveSimpleStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NoexceptMoveSimpleStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NoexceptMoveSimpleStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NoexceptMoveSimpleStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NoexceptMoveSimpleStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NoexceptMoveSimpleStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NoexceptMoveSimpleStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::NoexceptMoveComplexStruct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 9;
  static constexpr folly::StringPiece _names[] = {
    "MyBoolField",
    "MyIntField",
    "MyStringField",
    "MyStringField2",
    "MyBinaryField",
    "MyBinaryField2",
    "MyBinaryField3",
    "MyBinaryListField4",
    "MyMapEnumAndInt",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
  };
  static constexpr TType _types[] = {
    TType::T_BOOL,
    TType::T_I64,
    TType::T_STRING,
    TType::T_STRING,
    TType::T_STRING,
    TType::T_STRING,
    TType::T_STRING,
    TType::T_LIST,
    TType::T_MAP,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NoexceptMoveComplexStruct::NoexceptMoveComplexStruct() :
      MyBoolField(0),
      MyIntField(12LL),
      MyStringField(apache::thrift::StringTraits< std::string>::fromStringLiteral("test")),
      MyMapEnumAndInt(std::initializer_list<std::pair<const  ::apache::thrift::fixtures::types::MyEnumA, ::std::string>>{{ ::apache::thrift::fixtures::types::MyEnumA::fieldA, apache::thrift::StringTraits< std::string>::fromStringLiteral("fieldA")},
  { ::apache::thrift::fixtures::types::MyEnumA::fieldC, apache::thrift::StringTraits< std::string>::fromStringLiteral("fieldC")}}) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NoexceptMoveComplexStruct::NoexceptMoveComplexStruct(NoexceptMoveComplexStruct&& other) noexcept :
    MyBoolField(std::move(other.MyBoolField)),
    MyIntField(std::move(other.MyIntField)),
    MyStringField(std::move(other.MyStringField)),
    MyStringField2(std::move(other.MyStringField2)),
    MyBinaryField(std::move(other.MyBinaryField)),
    MyBinaryField2(std::move(other.MyBinaryField2)),
    MyBinaryField3(std::move(other.MyBinaryField3)),
    MyBinaryListField4(std::move(other.MyBinaryListField4)),
    MyMapEnumAndInt(std::move(other.MyMapEnumAndInt)),
    __isset(other.__isset) {}
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NoexceptMoveComplexStruct::~NoexceptMoveComplexStruct() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NoexceptMoveComplexStruct::NoexceptMoveComplexStruct(apache::thrift::FragileConstructor, bool MyBoolField__arg, int64_t MyIntField__arg, ::std::string MyStringField__arg, ::std::string MyStringField2__arg, ::std::string MyBinaryField__arg, ::std::string MyBinaryField2__arg, ::std::string MyBinaryField3__arg, ::std::vector<::std::string> MyBinaryListField4__arg, ::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string> MyMapEnumAndInt__arg) :
    MyBoolField(std::move(MyBoolField__arg)),
    MyIntField(std::move(MyIntField__arg)),
    MyStringField(std::move(MyStringField__arg)),
    MyStringField2(std::move(MyStringField2__arg)),
    MyBinaryField(std::move(MyBinaryField__arg)),
    MyBinaryField2(std::move(MyBinaryField2__arg)),
    MyBinaryField3(std::move(MyBinaryField3__arg)),
    MyBinaryListField4(std::move(MyBinaryListField4__arg)),
    MyMapEnumAndInt(std::move(MyMapEnumAndInt__arg)) {
  __isset.MyBoolField = true;
  __isset.MyIntField = true;
  __isset.MyStringField = true;
  __isset.MyStringField2 = true;
  __isset.MyBinaryField = true;
  __isset.MyBinaryField2 = true;
  __isset.MyBinaryListField4 = true;
  __isset.MyMapEnumAndInt = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void NoexceptMoveComplexStruct::__clear() {
  // clear all fields
  MyBoolField = 0;
  MyIntField = 12LL;
  MyStringField = apache::thrift::StringTraits< std::string>::fromStringLiteral("test");
  MyStringField2 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  MyBinaryField = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  MyBinaryField2 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  MyBinaryField3 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  MyBinaryListField4.clear();
  MyMapEnumAndInt.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool NoexceptMoveComplexStruct::operator==(const NoexceptMoveComplexStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.MyBoolField == rhs.MyBoolField)) {
    return false;
  }
  if (!(lhs.MyIntField == rhs.MyIntField)) {
    return false;
  }
  if (!(lhs.MyStringField == rhs.MyStringField)) {
    return false;
  }
  if (!(lhs.MyStringField2 == rhs.MyStringField2)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.MyBinaryField, rhs.MyBinaryField)) {
    return false;
  }
  if (lhs.MyBinaryField2_ref().has_value() != rhs.MyBinaryField2_ref().has_value()) {
    return false;
  }
  if (lhs.MyBinaryField2_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.MyBinaryField2, rhs.MyBinaryField2)) {
      return false;
    }
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.MyBinaryField3, rhs.MyBinaryField3)) {
    return false;
  }
  if (!(lhs.MyBinaryListField4 == rhs.MyBinaryListField4)) {
    return false;
  }
  if (!(lhs.MyMapEnumAndInt == rhs.MyMapEnumAndInt)) {
    return false;
  }
  return true;
}

bool NoexceptMoveComplexStruct::operator<(const NoexceptMoveComplexStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.MyBoolField == rhs.MyBoolField)) {
    return lhs.MyBoolField < rhs.MyBoolField;
  }
  if (!(lhs.MyIntField == rhs.MyIntField)) {
    return lhs.MyIntField < rhs.MyIntField;
  }
  if (!(lhs.MyStringField == rhs.MyStringField)) {
    return lhs.MyStringField < rhs.MyStringField;
  }
  if (!(lhs.MyStringField2 == rhs.MyStringField2)) {
    return lhs.MyStringField2 < rhs.MyStringField2;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.MyBinaryField, rhs.MyBinaryField)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.MyBinaryField, rhs.MyBinaryField);
  }
  if (lhs.MyBinaryField2_ref().has_value() != rhs.MyBinaryField2_ref().has_value()) {
    return lhs.MyBinaryField2_ref().has_value() < rhs.MyBinaryField2_ref().has_value();
  }
  if (lhs.MyBinaryField2_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.MyBinaryField2, rhs.MyBinaryField2)) {
      return apache::thrift::StringTraits<std::string>::isLess(lhs.MyBinaryField2, rhs.MyBinaryField2);
    }
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.MyBinaryField3, rhs.MyBinaryField3)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.MyBinaryField3, rhs.MyBinaryField3);
  }
  if (!(lhs.MyBinaryListField4 == rhs.MyBinaryListField4)) {
    return lhs.MyBinaryListField4 < rhs.MyBinaryListField4;
  }
  if (!(lhs.MyMapEnumAndInt == rhs.MyMapEnumAndInt)) {
    return lhs.MyMapEnumAndInt < rhs.MyMapEnumAndInt;
  }
  return false;
}

const ::std::vector<::std::string>& NoexceptMoveComplexStruct::get_MyBinaryListField4() const& {
  return MyBinaryListField4;
}

::std::vector<::std::string> NoexceptMoveComplexStruct::get_MyBinaryListField4() && {
  return std::move(MyBinaryListField4);
}

const ::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string>& NoexceptMoveComplexStruct::get_MyMapEnumAndInt() const& {
  return MyMapEnumAndInt;
}

::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string> NoexceptMoveComplexStruct::get_MyMapEnumAndInt() && {
  return std::move(MyMapEnumAndInt);
}


void swap(NoexceptMoveComplexStruct& a, NoexceptMoveComplexStruct& b) {
  using ::std::swap;
  swap(a.MyBoolField_ref().value(), b.MyBoolField_ref().value());
  swap(a.MyIntField_ref().value(), b.MyIntField_ref().value());
  swap(a.MyStringField_ref().value(), b.MyStringField_ref().value());
  swap(a.MyStringField2_ref().value(), b.MyStringField2_ref().value());
  swap(a.MyBinaryField_ref().value(), b.MyBinaryField_ref().value());
  swap(a.MyBinaryField2_ref().value_unchecked(), b.MyBinaryField2_ref().value_unchecked());
  swap(a.MyBinaryField3_ref().value(), b.MyBinaryField3_ref().value());
  swap(a.MyBinaryListField4_ref().value(), b.MyBinaryListField4_ref().value());
  swap(a.MyMapEnumAndInt_ref().value(), b.MyMapEnumAndInt_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void NoexceptMoveComplexStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NoexceptMoveComplexStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NoexceptMoveComplexStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NoexceptMoveComplexStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NoexceptMoveComplexStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NoexceptMoveComplexStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NoexceptMoveComplexStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NoexceptMoveComplexStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::NoExceptMoveUnion>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "string_field",
    "i32_field",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::size;
folly::Range<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type const*> const TEnumTraits<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::names);

char const* TEnumTraits<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace apache { namespace thrift { namespace fixtures { namespace types {

void NoExceptMoveUnion::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::string_field:
    {
      destruct(value_.string_field);
      break;
    }
    case Type::i32_field:
    {
      destruct(value_.i32_field);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool NoExceptMoveUnion::operator==(const NoExceptMoveUnion& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::string_field:
    {
      return value_.string_field == rhs.value_.string_field;
    }
    case Type::i32_field:
    {
      return value_.i32_field == rhs.value_.i32_field;
    }
    default:
    {
      return true;
    }
  }
}

bool NoExceptMoveUnion::operator<(const NoExceptMoveUnion& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::string_field:
      return lhs.value_.string_field < rhs.value_.string_field;
    case Type::i32_field:
      return lhs.value_.i32_field < rhs.value_.i32_field;
    default:
      return false;
  }
}

void swap(NoExceptMoveUnion& a, NoExceptMoveUnion& b) {
  NoExceptMoveUnion temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void NoExceptMoveUnion::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NoExceptMoveUnion::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NoExceptMoveUnion::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NoExceptMoveUnion::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NoExceptMoveUnion::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NoExceptMoveUnion::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NoExceptMoveUnion::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NoExceptMoveUnion::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::AllocatorAware>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 5;
  static constexpr folly::StringPiece _names[] = {
    "aa_list",
    "aa_set",
    "aa_map",
    "aa_string",
    "not_a_container",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
  };
  static constexpr TType _types[] = {
    TType::T_LIST,
    TType::T_SET,
    TType::T_MAP,
    TType::T_STRING,
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AllocatorAware::AllocatorAware() :
      not_a_container(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


AllocatorAware::~AllocatorAware() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AllocatorAware::AllocatorAware(apache::thrift::FragileConstructor, ::std::vector<int32_t> aa_list__arg, ::std::set<int32_t> aa_set__arg, ::std::map<int32_t, int32_t> aa_map__arg, ::std::string aa_string__arg, int32_t not_a_container__arg) :
    aa_list(std::move(aa_list__arg)),
    aa_set(std::move(aa_set__arg)),
    aa_map(std::move(aa_map__arg)),
    aa_string(std::move(aa_string__arg)),
    not_a_container(std::move(not_a_container__arg)) {
  __isset.aa_list = true;
  __isset.aa_set = true;
  __isset.aa_map = true;
  __isset.aa_string = true;
  __isset.not_a_container = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AllocatorAware::__clear() {
  // clear all fields
  aa_list.clear();
  aa_set.clear();
  aa_map.clear();
  aa_string = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  not_a_container = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AllocatorAware::operator==(const AllocatorAware& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.aa_list == rhs.aa_list)) {
    return false;
  }
  if (!(lhs.aa_set == rhs.aa_set)) {
    return false;
  }
  if (!(lhs.aa_map == rhs.aa_map)) {
    return false;
  }
  if (!(lhs.aa_string == rhs.aa_string)) {
    return false;
  }
  if (!(lhs.not_a_container == rhs.not_a_container)) {
    return false;
  }
  return true;
}

bool AllocatorAware::operator<(const AllocatorAware& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.aa_list == rhs.aa_list)) {
    return lhs.aa_list < rhs.aa_list;
  }
  if (!(lhs.aa_set == rhs.aa_set)) {
    return lhs.aa_set < rhs.aa_set;
  }
  if (!(lhs.aa_map == rhs.aa_map)) {
    return lhs.aa_map < rhs.aa_map;
  }
  if (!(lhs.aa_string == rhs.aa_string)) {
    return lhs.aa_string < rhs.aa_string;
  }
  if (!(lhs.not_a_container == rhs.not_a_container)) {
    return lhs.not_a_container < rhs.not_a_container;
  }
  return false;
}

const ::std::vector<int32_t>& AllocatorAware::get_aa_list() const& {
  return aa_list;
}

::std::vector<int32_t> AllocatorAware::get_aa_list() && {
  return std::move(aa_list);
}

const ::std::set<int32_t>& AllocatorAware::get_aa_set() const& {
  return aa_set;
}

::std::set<int32_t> AllocatorAware::get_aa_set() && {
  return std::move(aa_set);
}

const ::std::map<int32_t, int32_t>& AllocatorAware::get_aa_map() const& {
  return aa_map;
}

::std::map<int32_t, int32_t> AllocatorAware::get_aa_map() && {
  return std::move(aa_map);
}


void swap(AllocatorAware& a, AllocatorAware& b) {
  using ::std::swap;
  swap(a.aa_list_ref().value(), b.aa_list_ref().value());
  swap(a.aa_set_ref().value(), b.aa_set_ref().value());
  swap(a.aa_map_ref().value(), b.aa_map_ref().value());
  swap(a.aa_string_ref().value(), b.aa_string_ref().value());
  swap(a.not_a_container_ref().value(), b.not_a_container_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AllocatorAware::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AllocatorAware::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AllocatorAware::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AllocatorAware::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AllocatorAware::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AllocatorAware::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AllocatorAware::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AllocatorAware::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::AllocatorAware2>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "not_a_container",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AllocatorAware2::AllocatorAware2(apache::thrift::FragileConstructor, int32_t not_a_container__arg) :
    not_a_container(std::move(not_a_container__arg)) {
  __isset.not_a_container = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void AllocatorAware2::__clear() {
  // clear all fields
  not_a_container = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool AllocatorAware2::operator==(const AllocatorAware2& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.not_a_container == rhs.not_a_container)) {
    return false;
  }
  return true;
}

bool AllocatorAware2::operator<(const AllocatorAware2& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.not_a_container == rhs.not_a_container)) {
    return lhs.not_a_container < rhs.not_a_container;
  }
  return false;
}


void swap(AllocatorAware2& a, AllocatorAware2& b) {
  using ::std::swap;
  swap(a.not_a_container_ref().value(), b.not_a_container_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void AllocatorAware2::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AllocatorAware2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AllocatorAware2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AllocatorAware2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AllocatorAware2::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AllocatorAware2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AllocatorAware2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AllocatorAware2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}}} // apache::thrift::fixtures::types
